---
title: Graphiques anim√©s avec D3.js üßë‚Äçüé®
description: Dans ce projet, nous utilisons des donn√©es sur les tremblements de terre pour cr√©er un nuage de points anim√© avec D3.js
---

import { Callout } from "nextra/components";
import { NoticeIntro, NoticeEnd } from "../../components/Notices.jsx";

# Graphiques anim√©s avec D3.js üßë‚Äçüé®

[D3.js](https://d3js.org/) est la librairie de visualisation de donn√©es la plus c√©l√®bre, et pour une bonne raison : c‚Äôest une collection ing√©nieusement con√ßue de fonctions et de m√©thodes qui permettent de cr√©er des visualisations de donn√©es enti√®rement personnalisables sur le Web sous forme d‚Äô[images SVG](https://www.w3schools.com/graphics/svg_intro.asp). Elle a √©t√© cr√©√©e vers 2011 par [Mike Bostock](https://github.com/mbostock) et d'autres informaticiens. Plus r√©cemment, [Philippe Rivi√®re](https://github.com/fil) est devenu l‚Äôun des principaux mainteneurs et contributeurs.

Dans une le√ßon pr√©c√©dente, nous avons utilis√© la [librairie Plot](https://observablehq.com/plot/) pour nos visualisations. En coulisses, Plot utilise... D3 ! Et elle est principalement maintenue par Bostock et Rivi√®re ! Surprise ! üòÅ Plot est formidable et je l‚Äôutilise la majorit√© du temps pour mes dataviz. Mais lorsque je veux cr√©er quelque chose de tr√®s personnalis√©, en particulier avec des animations, D3 reste ma pr√©f√©rence.

Dans ce projet, nous allons utiliser des donn√©es sur les tremblements de terre pour cr√©er un nuage de points anim√©s avec D3 et Svelte, comme montr√© ci-dessous. Je vous recommande fortement de compl√©ter les sections pr√©c√©dentes du cours avant de vous lancer. Je ne passerai pas beaucoup de temps sur la configuration, l‚Äôutilisation de la [librairie Simple Data Analysis](https://github.com/nshiab/simple-data-analysis) ou du [framework Svelte](https://svelte.dev/).

![Un nuage de points anim√©s.](/assets/d3-chart/final-animation-scatter.gif)

<NoticeIntro lang="fr" />

## Configuration

Nous allons utiliser [setup-sda](https://github.com/nshiab/setup-sda) pour tout configurer et installer ce dont nous avons besoin.

Ouvrez un nouveau dossier avec VS Code et ex√©cutez `deno -A jsr:@nshiab/setup-sda --svelte`.

![Une capture d‚Äô√©cran de VS Code apr√®s avoir ex√©cut√© la librairie setup-sda.](/assets/d3-chart/setup.png)

## Donn√©es sur les tremblements de terre

Pour r√©cup√©rer les donn√©es sur les tremblements de terre, j‚Äôai utilis√© le [catalogue USGS Earthquake](https://earthquake.usgs.gov/earthquakes/search/). Comme l‚Äôann√©e 2021 semblait particuli√®rement active, j‚Äôai t√©l√©charg√© deux fichiers CSV pour cette ann√©e et je les ai mis en ligne sur GitHub.

En utilisant la librairie Simple Data Analysis dans le dossier `sda`, nous pouvons facilement les r√©cup√©rer et les mettre en cache. Mettez √† jour `sda/main.ts`, puis ex√©cutez `deno task sda` pour l‚Äôex√©cuter et l‚Äôobserver.



```ts showLineNumbers filename="sda/main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const earthquakes = sdb.newTable("earthquakes");
await earthquakes.cache(async () => {
  await earthquakes.loadData([
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-1.csv",
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-2.csv",
  ]);
});

await earthquakes.logTable();

await sdb.done();
```

![Une capture d‚Äô√©cran de VS Code apr√®s avoir ex√©cut√© la librairie Simple Data Analysis.](/assets/d3-chart/retrieve-earthquakes.png)

Comme vous pouvez le voir, notre jeu de donn√©es contient plus de 28 000 tremblements de terre et de nombreuses colonnes. Nous pouvons le filtrer et ne garder que ce qui nous int√©resse :
- Nous ne voulons que `earthquake` dans la colonne `type` et `reviewed` dans la colonne `status`.
- Nous filtrons pour ne garder que les tremblements de terre qui pourraient causer des dommages, avec une magnitude de 5 ou plus.
- Nous renommons les colonnes `latitude` et `longitude` avec des noms plus courts.
- Nous ne gardons que les colonnes `time`, `lat`, `lon`, `depth` et `mag`.
- Nous arrondissons les valeurs num√©riques √† 3 d√©cimales.
- Pour que ce soit plus logique, nous rendons les valeurs de `depth` n√©gatives.
- Et enfin, nous supprimons les doublons.

Nous obtenons environ 2 000 tremblements de terre.


```ts showLineNumbers filename="sda/main.ts" {13-31}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const earthquakes = sdb.newTable("earthquakes");
await earthquakes.cache(async () => {
  await earthquakes.loadData([
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-1.csv",
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-2.csv",
  ]);
});

await earthquakes.sort({ time: "asc" });
await earthquakes.keep({
  "type": "earthquake",
  "status": "reviewed",
});
await earthquakes.filter(`mag >= 5`);
await earthquakes.renameColumns({ latitude: "lat", longitude: "lon" });
await earthquakes.selectColumns([
  "time",
  "lat",
  "lon",
  "depth",
  "mag",
]);
await earthquakes.round(["lat", "lon", "depth", "mag"], {
  decimals: 3,
});
await earthquakes.updateColumn("depth", `depth * -1`);
await earthquakes.removeDuplicates();
await earthquakes.logTable();

await sdb.done();
```

![Les donn√©es sur les tremblements de terre nettoy√©es dans le terminal de VS Code.](/assets/d3-chart/filter-and-clean.png)

## Exploration des donn√©es

Avant de plonger dans des visualisations personnalis√©es, il est important d‚Äôexplorer un peu les donn√©es. Nous pouvons utiliser la fonction `writeChart` avec Plot pour dessiner rapidement quelques graphiques et avoir une id√©e de ce avec quoi nous travaillons :
- `sda/output/earthquakes-lat-lon.png` nous montre o√π se produisent la plupart des tremblements de terre ‚Äî le long des failles sismiques. Toutes les coordonn√©es semblent correctes.
- Avec `sda/output/earthquakes-time-mag.png`, on peut clairement voir les tremblements de terre les plus puissants. Les trois de magnitude sup√©rieure √† 8 correspondent √† la [Liste des tremblements de terre en 2021](https://en.wikipedia.org/wiki/List_of_earthquakes_in_2021) sur Wikip√©dia.
- `sda/output/earthquakes-mag-depth.png` sugg√®re que la plupart des s√©ismes se produisent √† moins de 250 km de profondeur. Les quatre plus puissants √©taient proches de la surface.

```ts showLineNumbers filename="sda/main.ts" {2, 34-70}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { dot, plot } from "@observablehq/plot";

const sdb = new SimpleDB();

const earthquakes = sdb.newTable("earthquakes");
await earthquakes.cache(async () => {
  await earthquakes.loadData([
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-1.csv",
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-2.csv",
  ]);
});

await earthquakes.sort({ time: "asc" });
await earthquakes.keep({
  "type": "earthquake",
  "status": "reviewed",
});
await earthquakes.filter(`mag >= 5`);
await earthquakes.renameColumns({ latitude: "lat", longitude: "lon" });
await earthquakes.selectColumns([
  "time",
  "lat",
  "lon",
  "depth",
  "mag",
]);
await earthquakes.round(["lat", "lon", "depth", "mag"], {
  decimals: 3,
});
await earthquakes.updateColumn("depth", `depth * -1`);
await earthquakes.removeDuplicates();
await earthquakes.logTable();
await earthquakes.writeChart(
  (data) =>
    plot({
      marks: [
        dot(data, {
          x: "lon",
          y: "lat",
        }),
      ],
    }),
  "sda/output/earthquakes-lat-lon.png",
);
await earthquakes.writeChart(
  (data) =>
    plot({
      marks: [
        dot(data, {
          x: "time",
          y: "mag",
        }),
      ],
    }),
  "sda/output/earthquakes-time-mag.png",
);
await earthquakes.writeChart(
  (data) =>
    plot({
      y: { labelArrow: "down" },
      marks: [
        dot(data, {
          x: "mag",
          y: "depth",
        }),
      ],
    }),
  "sda/output/earthquakes-mag-depth.png",
);

await sdb.done();
```
![Trois graphiques g√©n√©r√©s avec Simple Data Analysis et Plot dans VS Code.](/assets/d3-chart/exploratory-charts.png)

<Callout type="info" emoji="üí°">
   Pour ouvrir deux onglets l‚Äôun au-dessus de l‚Äôautre, faites un clic droit sur l‚Äôonglet que vous voulez en bas et cliquez sur `Split down`. Vous pouvez aussi utiliser `Split left`, `Split right` ou `Split top`. Vous pouvez √©galement faire glisser un onglet vers un autre √©cran, si vous en avez plusieurs.
</Callout>

## √âcriture des donn√©es pour le web

Comme nos donn√©es sont pr√™tes, nous pouvons maintenant les √©crire dans un fichier JSON que Svelte ‚Äî et tout navigateur web ‚Äî pourra lire. Il suffit d‚Äôajouter une ligne avec la m√©thode `writeData` et de s‚Äôassurer d‚Äô√©crire le fichier dans le dossier `src` (au lieu de `sda`, o√π nous avons travaill√© jusqu‚Äôici).

Si vous vous souvenez des le√ßons pr√©c√©dentes, `writeData` cr√©e une liste d‚Äôobjets. C‚Äôest exactement ce dont D3 a besoin. üòâ

Notez que les fichiers JSON ne peuvent pas stocker d‚Äôobjets `Date`, donc nos dates ont √©t√© s√©rialis√©es. Elles sont enregistr√©es en tant que cha√Ænes de caract√®res au format [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). Elles seront faciles √† reconvertir en dates.



```ts showLineNumbers filename="sda/main.ts" {71}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { dot, plot } from "@observablehq/plot";

const sdb = new SimpleDB();

const earthquakes = sdb.newTable("earthquakes");
await earthquakes.cache(async () => {
  await earthquakes.loadData([
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-1.csv",
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-2.csv",
  ]);
});

await earthquakes.sort({ time: "asc" });
await earthquakes.keep({
  "type": "earthquake",
  "status": "reviewed",
});
await earthquakes.filter(`mag >= 5`);
await earthquakes.renameColumns({ latitude: "lat", longitude: "lon" });
await earthquakes.selectColumns([
  "time",
  "lat",
  "lon",
  "depth",
  "mag",
]);
await earthquakes.round(["lat", "lon", "depth", "mag"], {
  decimals: 3,
});
await earthquakes.updateColumn("depth", `depth * -1`);
await earthquakes.removeDuplicates();
await earthquakes.logTable();
await earthquakes.writeChart(
  (data) =>
    plot({
      marks: [
        dot(data, {
          x: "lon",
          y: "lat",
        }),
      ],
    }),
  "sda/output/earthquakes-lat-lon.png",
);
await earthquakes.writeChart(
  (data) =>
    plot({
      marks: [
        dot(data, {
          x: "time",
          y: "mag",
        }),
      ],
    }),
  "sda/output/earthquakes-time-mag.png",
);
await earthquakes.writeChart(
  (data) =>
    plot({
      y: { labelArrow: "down" },
      marks: [
        dot(data, {
          x: "mag",
          y: "depth",
        }),
      ],
    }),
  "sda/output/earthquakes-mag-depth.png",
);
await earthquakes.writeData("src/data/earthquakes.json");

await sdb.done();
```
![Un fichier JSON √©crit par la librairie Simple Data Analysis.](/assets/d3-chart/serialized-dates.png)

## Composant de graphique

Cr√©ons un nouveau composant Svelte avec une fonction utilitaire pour notre nuage de points.

Mais avant cela, il est toujours utile de d√©finir quelques types que nous allons utiliser √† plusieurs reprises. Dans `src/lib/index.ts`, nous pouvons placer les types et variables qui seront facilement accessibles dans tout notre projet Svelte.

Nous pouvons cr√©er les types `earthquake` et `variable`, et les exporter. Ils seront tr√®s pratiques par la suite.


```ts showLineNumbers filename="src/lib/index.ts"
type earthquake = {
  time: Date;
  lat: number;
  lon: number;
  depth: number;
  mag: number;
};

type variable = keyof earthquake;

export type { earthquake, variable };
```

Cr√©ons maintenant la fonction utilitaire `drawChart.ts` dans le dossier `src/helpers` (et non dans `sda`, encore une fois). C‚Äôest l√† que notre code D3 va vivre. Cette fonction aura besoin de quelques √©l√©ments :
- Un `id`, qui sera l‚Äôidentifiant de l‚Äô√©l√©ment `svg` dans lequel nous allons dessiner notre graphique. Plus d‚Äôinformations sur `svg` ci-dessous.
- Les donn√©es `earthquakes`.
- Les variables `x`, `y` et `r` (le rayon de nos points).
- La `width` et la `height` du graphique.

Pour l‚Äôinstant, contentons-nous d‚Äôafficher ces param√®tres dans la console.

Notez que comme nous utilisons `src/lib/index.ts`, nous pouvons facilement importer nos types (et tout ce que nous voulons y mettre) avec `from $lib`. C‚Äôest un raccourci bien pratique !


```ts showLineNumbers filename="src/helpers/drawChart.ts"
import type { earthquake, variable } from "$lib";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  console.log({ id, earthquakes, x, y, r, width, height });
}
```

Nous pouvons maintenant cr√©er un nouveau composant `Chart.svelte` qui :

- Importe les donn√©es de `earthquakes.json` sous le nom `earthquakesRaw` (ligne 3), puis les transforme pour convertir les valeurs `time` en objets `Date` (lignes 13‚Äì16).
- R√©cup√®re `id`, `x`, `y` et `r` comme `props` (lignes 6‚Äì11).
- Cr√©e les √©tats `width` et `height` (lignes 18‚Äì19) et les lie √† `clientWidth` et `clientHeight` de l‚Äô√©l√©ment `svg` dans lequel nous allons dessiner notre graphique (ligne 26). Nous parlerons plus en d√©tail des √©l√©ments `svg` plus tard.
- Utilise la rune `$effect` pour appeler `drawChart` avec toutes les `props` et les √©tats. Cela signifie que Svelte rappellera `drawChart` si un des arguments change, y compris `width` et `height`, rendant ainsi le graphique r√©actif.
- D√©finit une `margin-top`, une `width` et une `height` pour le `svg` dans les balises `style`.



```svelte showLineNumbers filename="src/components/Chart.svelte"
<script lang="ts">
    import type { variable } from "$lib";
    import earthquakesRaw from "../data/earthquakes.json";
    import drawChart from "../helpers/drawChart";

    const { id, x, y, r }: {
      id: string;
      x: variable;
      y: variable;
      r: variable
    } = $props();

    const earthquakes = earthquakesRaw.map((d) => ({
        ...d,
        time: new Date(d.time),
    }));

    let width = $state(0);
    let height = $state(0);

    $effect(() => {
        drawChart(id, earthquakes, x, y, r, width, height);
    });
</script>

<svg {id} bind:clientWidth={width} bind:clientHeight={height}></svg>

<style>
    svg {
        margin-top: 2rem;
        width: 100%;
        height: 400px;
    }
</style>
```

Et enfin, nous pouvons importer notre nouveau composant `<Chart />` dans notre page, qui se trouve dans `src/routes/+page.svelte`. Nous d√©finissons les `props` appropri√©s : `id`, `x`, `y` et `r`. Pour commencer, dessinons un graphique des tremblements de terre et de leur magnitude au fil du temps. Au passage, nous pouvons ajouter des titres et un peu de texte.

Si vous surveillez encore `sda/main.ts`, vous pouvez l‚Äôarr√™ter (`CTRL` + `C`) et lancer `deno task dev` √† la place pour d√©marrer un serveur local. Ouvrez l‚ÄôURL affich√©e dans votre terminal dans votre navigateur pr√©f√©r√©.

Dans la console de votre navigateur, vous devriez voir le log provenant de `drawChart.ts`. Nous sommes pr√™ts √† coder notre graphique !

```svelte showLineNumbers filename="src/routes/+page.svelte"
<script lang="ts">
    import Chart from "../components/Chart.svelte";
</script>

<h1>Earthquakes</h1>
<p>
    The data used below includes only earthquakes with a magnitude of 5 or more
    that occurred in 2021.
</p>

<h2>Scatter plot</h2>
<Chart id="scatterplot" x="time" y="mag" r="mag" />
```

![VS Code et Code avec un projet Svelte lanc√© en local.](/assets/d3-chart/chart-component.png)

## Dessiner avec D3

Toute cette configuration peut sembler compliqu√©e... mais il y a en r√©alit√© beaucoup d‚Äôavantages √† compartimenter votre code. Quand chaque fichier est d√©di√© √† une seule t√¢che, il est plus facile √† d√©boguer. Il y a moins de r√©p√©tition dans votre projet. De plus, de petits morceaux de code qui ne font des choses pr√©cises sont plus faciles √† retravailler qu‚Äôun gros fichier qui fait tout. Cela deviendra particuli√®rement √©vident quand nous ajouterons des animations.

Mais nous avons assez attendu ‚Äî jouons enfin avec D3 !

Arr√™tez votre serveur local (`CTRL` + `C`) et installez D3 avec `deno add npm:d3`. Puis relancez votre serveur local avec `deno task dev`.

Commen√ßons doucement en dessinant un grand cercle bleu dans notre `svg` avec la fonction `drawChart`. Dans le code ci-dessous, D3 :
- S√©lectionne l‚Äô√©l√©ment `svg` avec l‚Äô`id` donn√©.
- Ajoute un √©l√©ment `circle` au `svg`.
- Sp√©cifie plusieurs attributs pour le cercle en encha√Ænant les m√©thodes.
- `cx` et `cy` sont les coordonn√©es du centre du cercle. Nous le pla√ßons au centre du `svg` en utilisant `width / 2` et `height / 2`.
- `r` est le rayon du cercle ‚Äî ici, 50 pixels.
- `fill` est la couleur √† l‚Äôint√©rieur du cercle ‚Äî ici, bleu.



```ts showLineNumbers filename="src/helpers/drawChart.ts" {2, 13-19}
import type { earthquake, variable } from "$lib";
import { select } from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  svg.append("circle")
    .attr("cx", width / 2)
    .attr("cy", height / 2)
    .attr("r", 50)
    .attr("fill", "blue");
}
```

Si vous faites un clic droit sur votre cercle bleu et que vous l‚Äôinspectez dans votre navigateur, vous verrez votre `svg` avec le `circle` ajout√© au code de votre page. C‚Äôest ainsi que l‚Äôon dessine des √©l√©ments SVG avec D3 : en lui indiquant exactement ce que l‚Äôon veut et o√π le placer.

![Du code D3 cr√©ant un cercle bleu affich√© dans Google Chrome.](/assets/d3-chart/blue-circle.png)

Pour l‚Äôinstant, ce cercle n‚Äôest li√© √† aucune donn√©e. Et nous avons plus de deux mille tremblements de terre. Comment les afficher tous ?

D‚Äôabord, nous avons besoin d‚Äô√©chelles (`scales`) pour convertir les valeurs des tremblements de terre en pixels, rayons et couleurs. Les √©chelles D3 ([il y en a beaucoup](https://d3js.org/d3-scale)) ont besoin de deux choses : un **domain** et un **range**.

Par exemple, dans le code ci-dessous, nous utilisons la fonction `extent` pour r√©cup√©rer les valeurs minimale et maximale des donn√©es `x`. Cette fonction retourne une liste du type `[min, max]`. Au cas o√π vous ne vous en souvenez pas, `x` est d√©fini comme `time` dans `src/routes/+page.svelte`.

Nous cr√©ons ensuite une `scaleTime` (car `x` contient des dates) avec :
- les valeurs minimales et maximales de temps comme *domain*
- `[0, width]` comme *range*

D√©sormais, cette √©chelle peut convertir des objets `Date` en valeurs de pixels. Au lieu de `width / 2` pour `cx`, nous pouvons maintenant utiliser une date en 2021 ! `xScale` la convertira automatiquement en la bonne position en pixels.


```ts showLineNumbers filename="src/helpers/drawChart.ts" {2, 15-16} /xScale(new Date("2021-06-01T00:00:00Z"))/
import type { earthquake, variable } from "$lib";
import { extent, scaleTime, select } from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xScale = scaleTime().domain(xDomain).range([0, width]);

  svg.append("circle")
    .attr("cx", xScale(new Date("2021-06-01T00:00:00Z")))
    .attr("cy", height / 2)
    .attr("r", 50)
    .attr("fill", "blue");
}
```

Nous pouvons faire la m√™me chose pour `y` (qui est actuellement d√©fini sur `mag`) et `cy` en utilisant une `scaleLinear`.

Encore une fois, modifiez la valeur de magnitude √† la ligne 23 pour voir `yScale` en action. Rappelez-vous que les magnitudes dans nos donn√©es varient entre 5 et 8.


```ts showLineNumbers filename="src/helpers/drawChart.ts" {2, 18-19} /yScale(7)/
import type { earthquake, variable } from "$lib";
import { extent, scaleLinear, scaleTime, select } from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xScale = scaleTime().domain(xDomain).range([0, width]);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([height, 0]);

  svg.append("circle")
    .attr("cx", xScale(new Date("2021-06-01T00:00:00Z")))
    .attr("cy", yScale(7))
    .attr("r", 50)
    .attr("fill", "blue");
}
```

Nous pouvons aussi ajouter une √©chelle pour l‚Äôattribut `r` ‚Äî cette fois en utilisant une √©chelle racine carr√©e (`scaleSqrt`), car nous voulons que la surface du cercle soit proportionnelle aux donn√©es.

Et ajoutons une autre √©chelle pour la couleur, qui pourrait √©galement √™tre li√©e √† `rDomain`.

Oui, je sais ‚Äî les √©chelles D3 sont incroyables ! Et comme ce sont simplement des fonctions, vous pouvez les utiliser pour tout ce que vous voulez, que ce soit dans des graphiques D3 ou ailleurs !

```ts showLineNumbers filename="src/helpers/drawChart.ts" {2, 21-23} /rScale(7)/ /fillScale(7)/
import type { earthquake, variable } from "$lib";
import { extent, scaleLinear, scaleSqrt, scaleTime, select } from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xScale = scaleTime().domain(xDomain).range([0, width]);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([height, 0]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  svg.append("circle")
    .attr("cx", xScale(new Date("2021-06-01T00:00:00Z")))
    .attr("cy", yScale(7))
    .attr("r", rScale(7))
    .attr("fill", fillScale(7));
}
```

Maintenant que nous avons nos √©chelles, nous pouvons exploiter tout le potentiel de D3 ! Au lieu d‚Äôajouter un seul cercle, attachons des √©l√©ments SVG √† nos donn√©es.

Voici une explication √©tape par √©tape du nouveau code ci-dessous :
- D‚Äôabord, nous s√©lectionnons tous les cercles dans le SVG (ligne 25). Lors du premier rendu, il n‚Äôy en a aucun ‚Äî et c‚Äôest normal.
- Ensuite, nous lions les donn√©es (ligne 26). Ici, nous avons plus de 2 000 tremblements de terre. Cela signifie que nous disons √† D3 : ¬´ H√©, je vais te demander de dessiner quelque chose plus de 2 000 fois. ¬ª
- Nous lions les donn√©es aux √©l√©ments SVG (ligne 27). Pour chaque tremblement de terre, nous allons dessiner un `circle`.
- Nous pouvons maintenant utiliser des fonctions pour indiquer √† D3 quels attributs nous voulons pour chaque tremblement de terre. Ici, nous utilisons `x`, `y` et `r` avec les √©chelles appropri√©es.

Comme certains tremblements de terre se chevauchent, j‚Äôai √©galement d√©fini l‚Äô`opacity` √† `0.5`.


```ts showLineNumbers filename="src/helpers/drawChart.ts" {25-32}
import type { earthquake, variable } from "$lib";
import { extent, scaleLinear, scaleSqrt, scaleTime, select } from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xScale = scaleTime().domain(xDomain).range([0, width]);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([height, 0]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  svg.selectAll("circle")
    .data(earthquakes)
    .join("circle")
    .attr("cx", (d: earthquake) => xScale(d[x]))
    .attr("cy", (d: earthquake) => yScale(d[y]))
    .attr("r", (d: earthquake) => rScale(d[r]))
    .attr("fill", (d: earthquake) => fillScale(d[r]))
    .attr("opacity", 0.5);
}
```

Et regardez-moi √ßa ! Vous avez maintenant tous vos tremblements de terre ajout√©s √† votre `svg` ! Et si vous inspectez un cercle et consultez ses `Properties`, vous verrez les donn√©es du tremblement de terre. Elles sont r√©ellement *li√©es* √† l‚Äô√©l√©ment SVG.

![Deux mille cercles dessin√©s dans un √©l√©ment SVG avec D3.](/assets/d3-chart/join-data.png)

## Axes

Nous avons dessin√© nos tremblements de terre, mais ce serait bien d‚Äôajouter des axes `x` et `y`. Pour nous assurer qu‚Äôil y ait suffisamment d‚Äôespace autour, nous devons aussi d√©finir des marges.

Cr√©ons un objet `margins` pour ajouter de l‚Äôespace autour du graphique et pour positionner correctement nos axes.

Pour dessiner les axes, nous pouvons utiliser les fonctions `axisLeft` et `axisBottom` avec nos √©chelles. En g√©n√©ral, on les place dans un √©l√©ment `g` (pour *group*) afin de pouvoir facilement les identifier (avec une `class` ou un `id`) ou les d√©placer si n√©cessaire.

Les axes D3 sont assez intelligents et essaient automatiquement de cr√©er des √©tiquettes de graduation pertinentes. Ici, comme nous utilisons une `scaleTime` pour l‚Äôaxe du bas (`axisBottom`), et que son domaine est limit√© √† 2021, la fonction affiche 2021 au d√©but, puis uniquement les mois. Toutefois, pour √©viter le chevauchement des √©tiquettes, j‚Äôai d√©fini le nombre de *ticks* √† 3.

Aussi, pour √©viter de redessiner les axes encore et encore lorsqu‚Äôune `prop` ou un √©tat change (comme lors du redimensionnement de la fen√™tre), je leur ai donn√© une `class` appel√©e `axis` et je l‚Äôutilise pour les s√©lectionner et les supprimer avant de les redessiner (ligne 55). Notez que nous n‚Äôavons pas besoin de faire cela pour les cercles car ils sont li√©s √† leurs donn√©es, m√™me entre les rendus.


```ts showLineNumbers filename="src/helpers/drawChart.ts" {3-4, 23-28, 55-70}
import type { earthquake, variable } from "$lib";
import {
  axisBottom,
  axisLeft,
  extent,
  scaleLinear,
  scaleSqrt,
  scaleTime,
  select,
} from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const margins = {
    top: 20,
    right: 20,
    bottom: 35,
    left: 80,
  };

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xScale = scaleTime().domain(xDomain).range([
    margins.left,
    width - margins.right,
  ]);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([
    height - margins.bottom,
    margins.top,
  ]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  svg.selectAll("circle")
    .data(earthquakes)
    .join("circle")
    .attr("cx", (d: earthquake) => xScale(d[x]))
    .attr("cy", (d: earthquake) => yScale(d[y]))
    .attr("r", (d: earthquake) => rScale(d[r]))
    .attr("fill", (d: earthquake) => fillScale(d[r]))
    .attr("opacity", 0.5);

  svg.selectAll(".axis").remove();

  svg
    .append("g")
    .attr("class", "axis")
    .attr(
      "transform",
      `translate(0, ${height - margins.bottom})`,
    )
    .call(axisBottom(xScale).ticks(3));

  svg
    .append("g")
    .attr("class", "axis")
    .attr("transform", `translate(${margins.left}, 0)`)
    .call(axisLeft(yScale));
}
```

Enfin, ce serait une bonne id√©e d‚Äôajouter des √©tiquettes aux axes √©galement ‚Äî et peut-√™tre un peu de marge int√©rieure pour √©viter que les cercles ne chevauchent les axes.

Pour avoir de vraies √©tiquettes au lieu des abr√©viations utilis√©es dans nos donn√©es, j‚Äôai cr√©√© un objet `labels` que nous pouvons utiliser pour le texte.

```ts showLineNumbers filename="src/helpers/drawChart.ts" {29, 73-94} /+ inset/ /- inset/
import type { earthquake, variable } from "$lib";
import {
  axisBottom,
  axisLeft,
  extent,
  scaleLinear,
  scaleSqrt,
  scaleTime,
  select,
} from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const margins = {
    top: 20,
    right: 20,
    bottom: 35,
    left: 80,
  };
  const inset = 10;

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xScale = scaleTime().domain(xDomain).range([
    margins.left,
    width - margins.right,
  ]);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([
    height - margins.bottom,
    margins.top,
  ]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  svg.selectAll("circle")
    .data(earthquakes)
    .join("circle")
    .attr("cx", (d: earthquake) => xScale(d[x]))
    .attr("cy", (d: earthquake) => yScale(d[y]))
    .attr("r", (d: earthquake) => rScale(d[r]))
    .attr("fill", (d: earthquake) => fillScale(d[r]))
    .attr("opacity", 0.5);

  svg.selectAll(".axis").remove();

  svg
    .append("g")
    .attr("class", "axis")
    .attr(
      "transform",
      `translate(0, ${height - margins.bottom + inset})`,
    )
    .call(axisBottom(xScale).ticks(3));

  svg
    .append("g")
    .attr("class", "axis")
    .attr("transform", `translate(${margins.left - inset}, 0)`)
    .call(axisLeft(yScale));

  svg.selectAll(".labels").remove();

  const labels: { [key: string]: string } = {
    "time": "Time",
    "mag": "Magnitude",
  };

  svg.append("text")
    .attr("class", "labels")
    .attr("x", width - margins.right)
    .attr("y", height)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(`${labels[x]} ‚Üí`);

  svg.append("text")
    .attr("class", "labels")
    .attr("x", margins.left - inset / 2)
    .attr("y", margins.top - inset)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(`${labels[y]} ‚Üë`);
}
```

Ce rendu est vraiment chouette pour un premier graphique D3 ! Et en plus, il est enti√®rement r√©actif ! Essayez de redimensionner votre navigateur et admirez la magie !

![Deux mille cercles dessin√©s dans un √©l√©ment SVG avec D3.](/assets/d3-chart/scatter-plot.png)

## Animations

Notre graphique est super, mais soyons honn√™tes : on pourrait cr√©er la m√™me chose beaucoup plus rapidement et facilement avec Plot...

Cependant, il y a une chose qui est difficile √† faire avec Plot : les animations.

Mettons √† jour notre fichier `src/routes/+page.svelte` pour offrir √† l‚Äôutilisateur deux types de graphiques. Nous pouvons utiliser le composant pr√©-cod√© `<Radio />`, qui cr√©e des boutons radio, et lier (`bind`) la variable `chartType` √† l‚Äôoption s√©lectionn√©e.

En fonction de l‚Äô√©tat de `chartType`, nous pouvons mettre √† jour les √©tats `x` et `y` nouvellement cr√©√©s, qui seront ensuite transmis √† notre composant `<Chart />`.


```svelte showLineNumbers filename="src/routes/+pages.svelte" {2, 4, 8-9, 11-19, 29-33} /{x}/ /{y}/
<script lang="ts">
    import type { variable } from "$lib";
    import Chart from "../components/Chart.svelte";
    import Radio from "../components/Radio.svelte";

    let chartType = $state("Time/Magnitude");

    let x = $state<variable>("time");
    let y = $state<variable>("mag");

    $effect(() => {
        if (chartType === "Time/Magnitude") {
            x = "time";
            y = "mag";
        } else {
            x = "mag";
            y = "depth";
        }
    });
</script>

<h1>Earthquakes</h1>
<p>
    The data used below includes only earthquakes with a magnitude of 5 or more
    that occurred in 2021.
</p>

<h2>Scatter plot</h2>
<Radio
    bind:value={chartType}
    values={["Time/Magnitude", "Magnitude/Depth"]}
    label="Pick a chart:"
/>
<Chart id="scatterplot" {x} {y} r="mag" />
```
<Callout type="info" emoji="üí°">
   Vous vous demandez peut-√™tre ce que signifie `<variable>` aux lignes 8 et 9. Tout comme vous pouvez passer des arguments √† certaines fonctions, vous pouvez aussi passer des types. C‚Äôest la syntaxe pr√©vue pour cela. Ici, cela indique √† `$state` que l‚Äô√©tat cr√©√© devra √™tre du type `variable`.
</Callout>

Maintenant, chaque fois que nous changeons le type de graphique, notre composant `<Chart />` est re-rendu avec de nouvelles valeurs `x` et `y`, qui sont utilis√©es par notre fonction `drawChart` !

![Des boutons radio mettant √† jour un graphique D3.](/assets/d3-chart/chart-types.png)

Il y a quelques petits bugs visuels que nous pouvons corriger tout de suite dans `src/helpers/drawChart.ts` :
- Si `x` est `time`, nous devons utiliser une `scaleTime`, mais si c‚Äôest `mag`, nous devons utiliser `scaleLinear`.
- Si `x` est `time`, nous pouvons garder 3 ticks, mais si c‚Äôest `mag`, on peut laisser D3 d√©cider.
- Nous pouvons ajouter `Depth` √† notre objet `labels` et inverser la fl√®che de l‚Äôaxe Y si c‚Äôest `depth`.
- Nous pouvons ajuster les `margins` et la position des √©tiquettes pour √©viter que notre nouveau texte soit coup√©.

```ts showLineNumbers filename="src/helpers/drawChart.ts" {26-27, 32-38, 68, 81, 87, 98}
import type { earthquake, variable } from "$lib";
import {
  axisBottom,
  axisLeft,
  extent,
  scaleLinear,
  scaleSqrt,
  scaleTime,
  select,
} from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const margins = {
    top: 20,
    right: 20,
    bottom: 45,
    left: 85,
  };
  const inset = 10;

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xRange = [
    margins.left,
    width - margins.right,
  ];
  const xScale = x === "time"
    ? scaleTime().domain(xDomain).range(xRange)
    : scaleLinear().domain(xDomain).range(xRange);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([
    height - margins.bottom,
    margins.top,
  ]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  svg.selectAll("circle")
    .data(earthquakes)
    .join("circle")
    .attr("cx", (d: earthquake) => xScale(d[x]))
    .attr("cy", (d: earthquake) => yScale(d[y]))
    .attr("r", (d: earthquake) => rScale(d[r]))
    .attr("fill", (d: earthquake) => fillScale(d[r]))
    .attr("opacity", 0.5);

  svg.selectAll(".axis").remove();

  svg
    .append("g")
    .attr("class", "axis")
    .attr(
      "transform",
      `translate(0, ${height - margins.bottom + inset})`,
    )
    .call(x === "time" ? axisBottom(xScale).ticks(3) : axisBottom(xScale));

  svg
    .append("g")
    .attr("class", "axis")
    .attr("transform", `translate(${margins.left - inset}, 0)`)
    .call(axisLeft(yScale));

  svg.selectAll(".labels").remove();

  const labels: { [key: string]: string } = {
    "time": "Time",
    "mag": "Magnitude",
    "depth": "Depth (km)",
  };

  svg.append("text")
    .attr("class", "labels")
    .attr("x", width - margins.right)
    .attr("y", height - 3)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(`${labels[x]} ‚Üí`);

  svg.append("text")
    .attr("class", "labels")
    .attr("x", margins.left - inset / 2)
    .attr("y", margins.top - inset)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(y === "depth" ? `${labels[y]} ‚Üì` : `${labels[y]} ‚Üë`);
}
```
![Un nuage de points redessin√© avec diff√©rentes variables.](/assets/d3-chart/no-animations.gif)

C‚Äôest sympa, mais ce n‚Äôest pas anim√©. Le graphique est simplement redessin√© √† chaque fois, sans aucune transition. Reprenons `src/helpers/drawChart.ts` pour cr√©er une transition fluide des cercles.

Cr√©er des animations avec D3 est tr√®s simple. Il suffit d‚Äôabord de s√©lectionner les √©l√©ments que vous voulez animer, d‚Äôappeler `.transition()`, puis d‚Äôencha√Æner les attributs que vous souhaitez modifier.

Dans notre cas, nous devons d‚Äôabord v√©rifier s‚Äôil faut dessiner ou animer. Pour cela, on regarde s‚Äôil y a d√©j√† quelque chose dans le `svg` (ligne 23). S‚Äôil n‚Äôy a rien, cela signifie qu‚Äôon doit dessiner (lignes 53‚Äì60). Sinon, on veut animer les √©l√©ments d√©j√† pr√©sents (lignes 62‚Äì65).

Pour animer, on s√©lectionne tous les cercles, on appelle `.transition()` pour dire √† D3 d‚Äôinterpoler entre leurs attributs actuels et les nouveaux. Ici, on met simplement √† jour `cx` et `cy` √† l‚Äôaide du *domain* et *range* mis √† jour de `xScale` et `yScale`.

Facile !


```ts showLineNumbers filename="src/helpers/drawChart.ts" {23, 52, 61-66}
import type { earthquake, variable } from "$lib";
import {
  axisBottom,
  axisLeft,
  extent,
  scaleLinear,
  scaleSqrt,
  scaleTime,
  select,
} from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const animate = svg.selectAll("*").nodes().length > 0;

  const margins = {
    top: 20,
    right: 20,
    bottom: 45,
    left: 85,
  };
  const inset = 10;

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xRange = [
    margins.left,
    width - margins.right,
  ];
  const xScale = x === "time"
    ? scaleTime().domain(xDomain).range(xRange)
    : scaleLinear().domain(xDomain).range(xRange);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([
    height - margins.bottom,
    margins.top,
  ]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  if (!animate) {
    svg.selectAll("circle")
      .data(earthquakes)
      .join("circle")
      .attr("cx", (d: earthquake) => xScale(d[x]))
      .attr("cy", (d: earthquake) => yScale(d[y]))
      .attr("r", (d: earthquake) => rScale(d[r]))
      .attr("fill", (d: earthquake) => fillScale(d[r]))
      .attr("opacity", 0.5);
  } else {
    svg.selectAll("circle")
      .transition()
      .attr("cx", (d: earthquake) => xScale(d[x]))
      .attr("cy", (d: earthquake) => yScale(d[y]));
  }

  svg.selectAll(".axis").remove();

  svg
    .append("g")
    .attr("class", "axis")
    .attr(
      "transform",
      `translate(0, ${height - margins.bottom + inset})`,
    )
    .call(x === "time" ? axisBottom(xScale).ticks(3) : axisBottom(xScale));

  svg
    .append("g")
    .attr("class", "axis")
    .attr("transform", `translate(${margins.left - inset}, 0)`)
    .call(axisLeft(yScale));

  svg.selectAll(".labels").remove();

  const labels: { [key: string]: string } = {
    "time": "Time",
    "mag": "Magnitude",
    "depth": "Depth (km)",
  };

  svg.append("text")
    .attr("class", "labels")
    .attr("x", width - margins.right)
    .attr("y", height - 3)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(`${labels[x]} ‚Üí`);

  svg.append("text")
    .attr("class", "labels")
    .attr("x", margins.left - inset / 2)
    .attr("y", margins.top - inset)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(y === "depth" ? `${labels[y]} ‚Üì` : `${labels[y]} ‚Üë`);
}
```

Mais si vous testez l‚Äôanimation maintenant, ce n‚Äôest pas tr√®s int√©ressant. Elle est trop rapide, et tous les points bougent en m√™me temps. On peut rendre √ßa plus sympa en ajoutant une `duration`, une `ease` et un `delay`.

![Une animation simple d‚Äôun nuage de points.](/assets/d3-chart/basic-animation-scatter.gif)

Pour la dur√©e, j‚Äôai choisi 1 000 millisecondes. Pour l‚Äôeasing, j‚Äôaime bien `easeCubicInOut`, mais vous avez [plein d‚Äôoptions](https://observablehq.com/@d3/easing-animations) avec D3. Et pour le d√©lai, j‚Äôutilise simplement la dur√©e multipli√©e par un nombre al√©atoire entre 0 et 1. Ainsi, chaque point aura un d√©lai diff√©rent ‚Äî compris entre 0 et la dur√©e choisie.

Maintenant, l‚Äôensemble para√Æt plus organique et agr√©able √† regarder !

```ts showLineNumbers filename="src/helpers/drawChart.ts" {5, 25, 66-68}
import type { earthquake, variable } from "$lib";
import {
  axisBottom,
  axisLeft,
  easeCubicInOut,
  extent,
  scaleLinear,
  scaleSqrt,
  scaleTime,
  select,
} from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const animate = svg.selectAll("*").nodes().length > 0;
  const duration = 1000;

  const margins = {
    top: 20,
    right: 20,
    bottom: 45,
    left: 85,
  };
  const inset = 10;

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xRange = [
    margins.left,
    width - margins.right,
  ];
  const xScale = x === "time"
    ? scaleTime().domain(xDomain).range(xRange)
    : scaleLinear().domain(xDomain).range(xRange);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([
    height - margins.bottom,
    margins.top,
  ]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  if (!animate) {
    svg.selectAll("circle")
      .data(earthquakes)
      .join("circle")
      .attr("cx", (d: earthquake) => xScale(d[x]))
      .attr("cy", (d: earthquake) => yScale(d[y]))
      .attr("r", (d: earthquake) => rScale(d[r]))
      .attr("fill", (d: earthquake) => fillScale(d[r]))
      .attr("opacity", 0.5);
  } else {
    svg.selectAll("circle")
      .transition()
      .duration(duration)
      .ease(easeCubicInOut)
      .delay(() => Math.random() * duration)
      .attr("cx", (d: earthquake) => xScale(d[x]))
      .attr("cy", (d: earthquake) => yScale(d[y]));
  }

  svg.selectAll(".axis").remove();

  svg
    .append("g")
    .attr("class", "axis")
    .attr(
      "transform",
      `translate(0, ${height - margins.bottom + inset})`,
    )
    .call(x === "time" ? axisBottom(xScale).ticks(3) : axisBottom(xScale));

  svg
    .append("g")
    .attr("class", "axis")
    .attr("transform", `translate(${margins.left - inset}, 0)`)
    .call(axisLeft(yScale));

  svg.selectAll(".labels").remove();

  const labels: { [key: string]: string } = {
    "time": "Time",
    "mag": "Magnitude",
    "depth": "Depth (km)",
  };

  svg.append("text")
    .attr("class", "labels")
    .attr("x", width - margins.right)
    .attr("y", height - 3)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(`${labels[x]} ‚Üí`);

  svg.append("text")
    .attr("class", "labels")
    .attr("x", margins.left - inset / 2)
    .attr("y", margins.top - inset)
    .attr("font-size", 12)
    .attr("text-anchor", "end")
    .text(y === "depth" ? `${labels[y]} ‚Üì` : `${labels[y]} ‚Üë`);
}
```

Nous pourrions aussi animer les axes et les √©tiquettes.

Pour l‚Äôaxe des x, comme il passe de dates √† des nombres et inversement, il n‚Äôy a pas de mani√®re fluide de faire la transition des valeurs comme on le fait avec l‚Äôaxe des y. √Ä la place, j‚Äôai encha√Æn√© des transitions pour le faire dispara√Ætre, le mettre √† jour, puis le faire r√©appara√Ætre. C‚Äôest le m√™me principe pour les √©tiquettes de texte.

√Ä noter √©galement : nous n‚Äôavons plus besoin de supprimer les axes ou les √©tiquettes, puisqu‚Äôon les met d√©sormais √† jour directement.


```ts showLineNumbers filename="src/helpers/drawChart.ts" {73, 76, 82-94, 96, 99, 102-106, 114, 116, 124, 130-154}
import type { earthquake, variable } from "$lib";
import {
  axisBottom,
  axisLeft,
  easeCubicInOut,
  extent,
  scaleLinear,
  scaleSqrt,
  scaleTime,
  select,
} from "d3";

export default function drawChart(
  id: string,
  earthquakes: earthquake[],
  x: variable,
  y: variable,
  r: variable,
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);

  const animate = svg.selectAll("*").nodes().length > 0;
  const duration = 1000;

  const margins = {
    top: 20,
    right: 20,
    bottom: 45,
    left: 85,
  };
  const inset = 10;

  const xDomain = extent(earthquakes, (d: earthquake) => d[x]);
  const xRange = [
    margins.left,
    width - margins.right,
  ];
  const xScale = x === "time"
    ? scaleTime().domain(xDomain).range(xRange)
    : scaleLinear().domain(xDomain).range(xRange);

  const yDomain = extent(earthquakes, (d: earthquake) => d[y]);
  const yScale = scaleLinear().domain(yDomain).range([
    height - margins.bottom,
    margins.top,
  ]);

  const rDomain = extent(earthquakes, (d: earthquake) => d[r]);
  const rScale = scaleSqrt().domain(rDomain).range([0, 20]);
  const fillScale = scaleLinear().domain(rDomain).range(["yellow", "red"]);

  if (!animate) {
    svg.selectAll("circle")
      .data(earthquakes)
      .join("circle")
      .attr("cx", (d: earthquake) => xScale(d[x]))
      .attr("cy", (d: earthquake) => yScale(d[y]))
      .attr("r", (d: earthquake) => rScale(d[r]))
      .attr("fill", (d: earthquake) => fillScale(d[r]))
      .attr("opacity", 0.5);
  } else {
    svg.selectAll("circle")
      .transition()
      .duration(duration)
      .ease(easeCubicInOut)
      .delay(() => Math.random() * duration)
      .attr("cx", (d: earthquake) => xScale(d[x]))
      .attr("cy", (d: earthquake) => yScale(d[y]));
  }

  if (!animate) {
    svg
      .append("g")
      .attr("id", "x-axis")
      .attr(
        "transform",
        `translate(0, ${height - margins.bottom + inset})`,
      )
      .call(x === "time" ? axisBottom(xScale).ticks(3) : axisBottom(xScale));
  } else {
    svg.select("#x-axis")
      .attr("opacity", 1)
      .transition()
      .duration(duration / 2)
      .attr("opacity", 0)
      .transition()
      .duration(0)
      .call(x === "time" ? axisBottom(xScale).ticks(3) : axisBottom(xScale))
      .transition()
      .duration(duration / 2)
      .attr("opacity", 1);
  }

  if (!animate) {
    svg
      .append("g")
      .attr("id", "y-axis")
      .attr("transform", `translate(${margins.left - inset}, 0)`)
      .call(axisLeft(yScale));
  } else {
    svg.select("#y-axis")
      .transition()
      .duration(duration).call(axisLeft(yScale));
  }

  const labels: { [key: string]: string } = {
    "time": "Time",
    "mag": "Magnitude",
    "depth": "Depth (km)",
  };

  if (!animate) {
    svg.append("text")
      .attr("id", "label-x")
      .attr("x", width - margins.right)
      .attr("y", height - 3)
      .attr("font-size", 12)
      .attr("text-anchor", "end")
      .text(`${labels[x]} ‚Üí`);

    svg.append("text")
      .attr("id", "label-y")
      .attr("x", margins.left - inset / 2)
      .attr("y", margins.top - inset)
      .attr("font-size", 12)
      .attr("text-anchor", "end")
      .text(y === "depth" ? `${labels[y]} ‚Üì` : `${labels[y]} ‚Üë`);
  } else {
    svg.select("#label-x")
      .attr("opacity", 1)
      .transition()
      .duration(duration / 2)
      .attr("opacity", 0)
      .transition()
      .duration(0)
      .text(`${labels[x]} ‚Üí`)
      .transition()
      .duration(duration / 2)
      .attr("opacity", 1);

    svg.select("#label-y")
      .attr("opacity", 1)
      .transition()
      .duration(duration / 2)
      .attr("opacity", 0)
      .transition()
      .duration(0)
      .text(y === "depth" ? `${labels[y]} ‚Üì` : `${labels[y]} ‚Üë`)
      .transition()
      .duration(duration / 2)
      .attr("opacity", 1);
  }
}
```
![Un nuage de points anim√©s.](/assets/d3-chart/final-animation-scatter.gif)

## Construction de la page

Jusqu'√† pr√©sent, nous avons ex√©cut√© notre page avec un serveur local. Si vous souhaitez construire votre site web, ex√©cutez la commande `deno task build`. Svelte minimisera et optimisera votre code et cr√©era les fichiers de votre site web dans le dossier `build`. Vous pourrez ensuite h√©berger ces fichiers sur un serveur pour partager votre travail avec le monde entier !

## Conclusion

Notre graphique est magniiifiiiique ! Nous pourrions continuer √† it√©rer pour l'am√©liorer encore plus, mais je pense que nous en avons d√©j√† fait beaucoup. Vous pouvez √™tre fier de vous.

Si vous souhaitez explorer davantage d'exemples D3, n'oubliez pas de consulter la [galerie D3](https://observablehq.com/@d3/gallery). Tout le code est en code ouvert !

Si vous √™tes pr√™t √† relever un d√©fi suppl√©mentaire, nous n'avons pas utilis√© les valeurs `lat` et `lon`. Essayez d'ajouter une autre option aux boutons radio qui met √† jour `x` vers `lon` et `y` vers `lat`, puis ajustez la fonction `drawChart` pour vous assurer que tout fonctionne correctement avec cette nouvelle option.

D3 n'est pas seulement bon pour les graphiques. C'est aussi G-√â-N-I-A-L pour les cartes ! Et c'est ce dont traitera la prochaine le√ßon. √Ä bient√¥t !

<NoticeEnd lang="fr" />
