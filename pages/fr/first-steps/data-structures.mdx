---
title: Structures de donn√©es en TypeScript
description: Apprenez √† organiser vos donn√©es avec des objets, des listes et... des listes d'objets !
---

import { Callout } from "nextra/components";
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Structures de donn√©es

Pour organiser vos donn√©es et les traiter efficacement, vous devez les structurer. Les deux structures de donn√©es les plus courantes sont les objets et les listes (*arrays*).

Dans cette le√ßon, nous allons utiliser ces structures pour stocker des donn√©es √† propos d'√©tudiants. Pr√©parez-vous, il y a beaucoup de concepts fondamentaux ici !

<NoticeIntro lang="fr" />

Avant de plonger dans le vif du sujet, configurons notre environnement de travail.

Cr√©ez un nouveau dossier quelque part sur votre ordinateur, ouvrez-le avec VS Code, et cr√©ez deux fichiers :

- `main.ts`, o√π nous √©crirons notre code. Pour commencer, vous pouvez y ajouter `console.log("Hello!");`.
- `deno.json`, qui informe VS Code qu'il s'agit d'un projet Deno et active l'extension Deno. Vous pouvez ajuster les param√®tres dans ce fichier, mais nous le laisserons vide pour l'instant.

Ouvrez le terminal et ex√©cutez la commande suivante :  `deno run --watch --check main.ts`

Cette commande efface le terminal et relance `main.ts` √† chaque fois que vous le sauvegardez (`CMD` + `S` sur Mac ou `CTRL` + `S` sur PC).

Vous pouvez utiliser cette configuration pour tester le code fourni dans cette le√ßon. (Oui, j'ai oubli√© d'inclure le fichier `deno.json` avant de prendre toutes les captures d'√©cran de cette le√ßon. Soyez plus attentifs que moi ! ü•≤)

![Une capture d'√©cran montrant VS Code ex√©cutant et surveillant un fichier TypeScript.](/assets/first-steps/data-structures/watch.png)

## Objets

Les objets stockent les donn√©es sous forme de **paires cl√©-valeur** encadr√©es par des accolades (`{}`), avec chaque paire s√©par√©e par une virgule. Les **cl√©s** sont de simples identifiants, et les **valeurs** peuvent √™tre de n'importe quel type de donn√©es.

Par exemple, l'objet ci-dessous stocke des donn√©es sur un √©tudiant. Les cl√©s sont `firstName`, `lastName`, `gender` et `age`. Les valeurs correspondantes sont `"Nael"`, `"Shiab"`, `"man"`, et `22` (c'est un Nael d'il y a quelques ann√©es üòÖ) :


```ts showLineNumbers filename="main.ts"
const student = {
  firstName: "Nael",
  lastName: "Shiab",
  gender: "man",
  age: 22,
};
console.log(student);
```

<Callout type="info" emoji="üí°">
 Dans un objet, les cl√©s peuvent √™tre √©crites sous forme d'identifiants simples (sans espaces ni caract√®res sp√©ciaux) ou sous forme de cha√Ænes de caract√®res. Par exemple, vous pourriez remplacer `firstName` par `"first name"`. Cependant, comme nous le verrons ci-dessous, √©viter les espaces vous simplifiera grandement la vie.
</Callout>

Pour savoir ce qu'un objet contient et conna√Ætre les types de ses valeurs, vous pouvez survoler avec votre curseur le nom de l'objet dans VS Code.

![Une capture d'√©cran montrant VS Code avec une fen√™tre contextuelle affichant le type d'un objet.](/assets/first-steps/data-structures/object-types.png)

### Acc√©der aux valeurs

Pour acc√©der √† la valeur d'une cl√© sp√©cifique, utilisez un `.` directement apr√®s la variable qui fait r√©f√©rence √† l'objet.

Par exemple, le code suivant affichera `Nael` dans votre terminal :

```ts showLineNumbers filename="main.ts"
const student = {
  firstName: "Nael",
  lastName: "Shiab",
  gender: "man",
  age: 22,
};
console.log(student.firstName);
```

<Callout type="info" emoji="üí°">
  Si la cl√© `firstName` √©tait √©crite avec un espace, comme `"first name"`, vous devriez √©crire `student["first name"]` pour acc√©der √† sa valeur. Cela est moins intuitif et peut rendre votre code plus difficile √† lire et √† maintenir. Pour cette raison, il est g√©n√©ralement recommand√© d'√©viter les espaces dans les cl√©s.
</Callout>

### Modifier des valeurs

Vous utilisez la m√™me syntaxe pour modifier une valeur dans un objet que pour y acc√©der, mais avec l'op√©rateur `=`.

Comme mentionn√© dans la le√ßon sur les [Variables](/first-steps/variables), vous devez respecter le type de la valeur lorsque vous la modifiez. Par exemple, si la valeur d'une cl√© est initialement un `number` (comme avec `age`), elle ne peut √™tre mise √† jour qu'avec un autre `number`.

```ts showLineNumbers filename="main.ts"
const student = {
  firstName: "Nael",
  lastName: "Shiab",
  gender: "man",
  age: 22,
};

// Me voici tr√®s vieux.
student.age = 100;

console.log(student);
```

![Une capture d'√©cran montrant VS Code et un script modifiant un objet.](/assets/first-steps/data-structures/object-update.png)

### Autocompl√©tion et v√©rifications

Lorsque vous travaillez avec des objets, vous pouvez profiter de la fonctionnalit√© pratique d'autocompl√©tion (√©galement appel√©e _IntelliSense_).

Si vous tapez un `.` apr√®s une variable faisant r√©f√©rence √† un objet, une fen√™tre contextuelle appara√Ætra avec la liste des cl√©s disponibles. Vous pouvez utiliser les fl√®ches haut et bas pour naviguer parmi les cl√©s et voir leurs types. Appuyez sur **Entr√©e** pour s√©lectionner la cl√© souhait√©e.

![Une capture d'√©cran montrant VS Code et sa fonctionnalit√© IntelliSense.](/assets/first-steps/data-structures/object-auto-completion.png)

De plus, comme les objets sont typ√©s, si vous essayez d'acc√©der √† une cl√© qui n'existe pas dans l'objet, TypeScript g√©n√©rera une erreur avant m√™me que vous n'ex√©cutiez le script. Cela est illustr√© dans la capture d'√©cran ci-dessous.

De nombreux bogues et erreurs sont caus√©s par de simples fautes de frappe. Gr√¢ce √† cette fonctionnalit√©, TypeScript vous aide √† d√©tecter ces erreurs en amont. üôè

![Une capture d'√©cran montrant VS Code et une erreur caus√©e par l'acc√®s √† une cl√© inexistante dans un objet.](/assets/first-steps/data-structures/object-no-key.png)

## Listes

Il est temps de parler d'une autre structure de donn√©es : les listes !

Les listes stockent des donn√©es dans un ordre sp√©cifique, encadr√©es par des crochets (`[` et `]`). Vous pouvez stocker n'importe quel type de donn√©es dans une liste.

Par exemple, voici une liste de noms d'√©tudiants.

```ts showLineNumbers filename="main.ts"
const names = ["James", "John", "Patricia", "Jennifer"];
console.log(names);
```

Si vous survolez la variable `names`, vous verrez que son type est `string[]`, ce qui signifie qu‚Äôil s‚Äôagit d‚Äôune liste compos√©e exclusivement de cha√Ænes de caract√®res. Il est g√©n√©ralement pr√©f√©rable de cr√©er des listes contenant un seul type de donn√©es (ou un type et `null`, comme nous le verrons plus tard).

![Une capture d'√©cran montrant VS Code avec un type `string[]` au survol.](/assets/first-steps/data-structures/string-array-type.png)

### Index

√âtant donn√© que les listes sont ordonn√©es, nous pouvons r√©cup√©rer un √©l√©ment sp√©cifique en utilisant un **index**. Les index commencent √† `0`.

Par exemple :
- Pour r√©cup√©rer le nom du premier √©tudiant, utilisez l‚Äôindex `0`.
- Pour le deuxi√®me √©tudiant, utilisez l‚Äôindex `1`, et ainsi de suite.

Pour acc√©der √† une valeur d'une liste en utilisant un index, placez l‚Äôindex entre crochets (`[]`) imm√©diatement apr√®s la liste ou la variable r√©f√©rant √† la liste.

```ts showLineNumbers filename="main.ts"
const names = ["James", "John", "Patricia", "Jennifer"];

// Modifiez l‚Äôindex pour voir ce qui est affich√© dans le terminal.
// Si vous entrez un nombre sup√©rieur √† 3, vous verrez un undefined
// parce qu‚Äôil n‚Äôy a que quatre √©l√©ments dans la liste !
const student = names[0];
console.log(student);
```

![Une capture d'√©cran montrant VS Code affichant une cha√Æne de caract√®res provenant d'une liste.](/assets/first-steps/data-structures/names-index.png)

Vous pouvez √©galement modifier une valeur dans une liste en utilisant son index et l'op√©rateur `=`. Rappelez-vous que les listes sont typ√©es en TypeScript. Par exemple, si le type de `names` est `string[]`, vous ne pouvez remplacer une valeur que par un autre `string`.

```ts showLineNumbers filename="main.ts"
const names = ["James", "John", "Patricia", "Jennifer"];

// Modification de la cha√Æne
// √† l'index 0.
names[0] = "Nael";

console.log(names);
```

![Une capture d'√©cran montrant VS Code affichant un script modifiant une valeur de cha√Æne dans une liste.](/assets/first-steps/data-structures/array-updating.png)

### Propri√©t√©s

Les listes ont une propri√©t√© appel√©e `length`, qui renvoie le nombre d'√©l√©ments dans la liste. Cela est utile pour d√©terminer la taille de la liste, que ce soit pour des it√©rations, des validations ou d'autres op√©rations.

Pour acc√©der √† une propri√©t√©, tapez un `.` juste apr√®s la liste ou la variable qui la r√©f√©rence.

```ts showLineNumbers filename="main.ts"
const names = ["James", "John", "Patricia", "Jennifer"];
console.log(names.length);
```

![Une capture d'√©cran montrant VS Code affichant la longueur d'une liste.](/assets/first-steps/data-structures/array-length.png)

### M√©thodes

L'une des fonctionnalit√©s les plus puissantes des listes est leurs **m√©thodes**. Ces m√©thodes vous permettent de traiter et de manipuler facilement vos donn√©es.

Pour acc√©der aux m√©thodes, tapez un `.` juste apr√®s la liste ou la variable qui la r√©f√©rence, comme pour acc√©der aux propri√©t√©s. La diff√©rence est que les m√©thodes doivent √™tre appel√©es avec des `()` pour √™tre d√©clench√©es. Souvent, vous devrez fournir un ou plusieurs arguments entre les parenth√®ses (nous y reviendrons plus tard).

Voici quelques exemples de m√©thodes couramment utilis√©es pour les listes.

#### `.push()`

La m√©thode `.push()` ajoute un ou plusieurs √©l√©ments √† la fin d'une liste.

```ts showLineNumbers filename="main.ts"
const names = ["James", "John", "Patricia", "Jennifer"];

names.push("Nael");

console.log(names);
// => [ "James", "John", "Patricia", "Jennifer", "Nael" ]
```

#### `.sort()`

La m√©thode `.sort()` trie la liste par ordre croissant par d√©faut.

Il est √©galement possible de passer un argument pour trier d'autres types de donn√©es d'une mani√®re sp√©cifique, mais nous aborderons cela plus tard.

```ts showLineNumbers filename="main.ts"
const names = ["James", "John", "Patricia", "Jennifer"];

names.sort();

console.log(names);
// => [ "James", "Jennifer", "John", "Patricia" ]
```

#### `.includes()`

La m√©thode `.includes()` v√©rifie si une valeur existe dans la liste et renvoie un bool√©en.

```ts showLineNumbers filename="main.ts"
const marks = [33, 45, 78, 98];

console.log(marks.includes(45));
// => true

console.log(marks.includes(100));
// => false
```

#### `.find()`

La m√©thode `.find()` recherche une valeur dans la liste. Si aucune valeur ne correspond √† la condition, elle renvoie `undefined`. Si plusieurs valeurs correspondent √† la condition, elle renvoie la premi√®re.

Cette m√©thode n√©cessite une `function` comme argument. Nous aborderons les fonctions dans les prochaines le√ßons.

```ts showLineNumbers filename="main.ts"
const marks = [33, 45, 78, 98];

// Trouve la premi√®re note sup√©rieure √† 50
// et la stocke dans une variable.
const above50 = marks.find((mark) => mark > 50);
console.log(above50);
//=> 78

// Trouve la premi√®re note sup√©rieure √† 100.
const above100 = marks.find((mark) => mark > 100);
// Il n'y en a pas, donc la valeur est undefined.
console.log(above100);
// => undefined
```

#### `.filter()`

La m√©thode `.filter()` cr√©e une nouvelle liste contenant uniquement les √©l√©ments qui correspondent √† une condition sp√©cifique.

Cette m√©thode n√©cessite une `function` comme argument. Nous aborderons les fonctions dans les prochaines le√ßons.

```ts showLineNumbers filename="main.ts"
const marks = [33, 45, 78, 98];

// Cr√©e une nouvelle liste avec
// des notes sup√©rieures √† 50.
const above50 = marks.filter((mark) => mark > 50);

// La liste originale reste inchang√©e.
console.log(marks);
// => [33, 45, 78, 98]

// La nouvelle liste contient uniquement
// des notes sup√©rieures √† 50.
console.log(above50);
// => [78, 98]
```

#### `.map()`

La m√©thode `.map()` vous permet de transformer chaque √©l√©ment de la liste en une nouvelle valeur et place le r√©sultat dans une nouvelle liste.

Cette m√©thode n√©cessite une `function` comme argument. Nous aborderons les fonctions dans les prochaines le√ßons.

Par exemple, le code ci-dessous double chaque note.

```ts showLineNumbers filename="main.ts"
const allMarks = [33, 45, 78, 98];

// Ici, nous multiplions chaque note par 2
// et stockons le r√©sultat dans une nouvelle liste.
const marksMultiplied = allMarks.map((mark) => mark * 2);

// La liste originale n'est pas modifi√©e.
console.log(allMarks);
// => [33, 45, 78, 98]

// La nouvelle liste contient les notes
// multipli√©es par 2.
console.log(marksMultiplied);
// => [ 66, 90, 156, 196 ]
```

#### Encha√Ænement

Un autre avantage de l'utilisation des m√©thodes de liste est qu'elles peuvent √™tre encha√Æn√©es. Puisqu'elles renvoient une liste, vous pouvez appeler une m√©thode apr√®s l'autre.

```ts showLineNumbers filename="main.ts"
const allMarks = [33, 45, 78, 98];

// Ici, nous encha√Ænons les m√©thodes de liste.
// D'abord, nous multiplions chaque note par 2.
// Ensuite, nous filtrons les notes inf√©rieures
// ou √©gales √† 100.
// Enfin, nous trions les notes par ordre d√©croissant.
const newMarks = allMarks
    .map((mark) => mark * 2)
    .filter((mark) => mark > 100)
    .sort((a, b) => b - a);

console.log(newMarks);
// Logs => [196, 156]
```

<Callout type="info" emoji="üí°">
Jusqu'√† pr√©sent dans notre code, chaque ligne se terminait par un `;`. Cependant, des lignes 8 √† 11, il n'y a pas de point-virgule parce que nous encha√Ænons des m√©thodes. Tout ce qui se trouve entre ces lignes fait partie de la m√™me instruction. Techniquement, vous pourriez tout √©crire sur une seule ligne, mais cela rendrait le code moins lisible. Comme TypeScript ne prend pas en compte les sauts de ligne ou l'indentation, c'est √† l'utilisateur de formater le code comme il le souhaite. Dans notre cas, nous laissons le formateur Deno s'en charger pour nous.
</Callout>

#### Autres

Il existe de nombreuses autres m√©thodes pour les listes, mais celles mentionn√©es ci-dessus sont celles que vous utiliserez le plus souvent.

Si vous √™tes curieux, vous pouvez consulter la [documentation de W3Schools](https://www.w3schools.com/js/js_array_methods.asp) pour en savoir plus.

Vous pouvez √©galement utiliser *IntelliSense* directement dans VS Code. Tapez un `.` juste apr√®s une variable faisant r√©f√©rence √† une liste pour voir appara√Ætre une liste des propri√©t√©s et m√©thodes disponibles. Utilisez les fl√®ches haut et bas pour explorer.

De plus, les m√©thodes sont typ√©es. Pas d'inqui√©tude si vous faites une faute de frappe : elle sera d√©tect√©e avant l'ex√©cution de votre code et √©vitera un plantage complet. ü§ì

![Une capture d'√©cran montrant VS Code affichant les m√©thodes disponibles pour une liste.](/assets/first-steps/data-structures/pop-up-methods-arrays.png)

## Listes d'objets !

Les objets sont excellents pour stocker des donn√©es dans un format intuitif, tandis que les listes offrent des m√©thodes pratiques pour traiter facilement les donn√©es. Alors pourquoi ne pas combiner les deux ?

Voici les **listes d'objets** !

C'est l'une des fa√ßons les plus courantes de repr√©senter des donn√©es : une liste d'objets o√π chaque objet partage les m√™mes cl√©s.

Voici un exemple utilisant les noms et notes de nos √©tudiants. Chaque objet stocke des donn√©es sur un √©tudiant, et tous les √©tudiants ont les m√™mes cl√©s. Ces objets sont ensuite regroup√©s dans une liste.

Vous pouvez consid√©rer chaque objet comme une ligne dans un tableur. En fait, vous pouvez remplacer `console.log` par `console.table` et voir un magnifique tableau s'afficher dans votre terminal!

```ts showLineNumbers filename="main.ts"
const students = [
  { name: "James", mark: 33 },
  { name: "John", mark: 45 },
  { name: "Patricia", mark: 78 },
  { name: "Jennifer", mark: 98 },
];
console.table(students);
```

![Une capture d'√©cran montrant VS Code affichant une liste d'objets sous forme de tableau dans le terminal.](/assets/first-steps/data-structures/table.png)

Les choses deviennent int√©ressantes. Ce mod√®le offre une mani√®re flexible de travailler avec des donn√©es.

Par exemple, vous pouvez filtrer en fonction d'une cl√© sp√©cifique tout en pr√©servant le reste des donn√©es pour chaque √©tudiant.

C'est le meilleur des deux mondes !

```ts showLineNumbers filename="main.ts"
const students = [
  { name: "James", mark: 33 },
  { name: "John", mark: 45 },
  { name: "Patricia", mark: 78 },
  { name: "Jennifer", mark: 98 },
];

// Remarquez comment nous acc√©dons √† la cl√© mark
// pour chaque objet √©tudiant.
const studentAbove50 = students.filter((student) => student.mark > 50);

// La liste originale n'est pas modifi√©e.
console.table(students);

// La nouvelle liste contient uniquement les √©tudiants
// ayant des notes sup√©rieures √† 50.
console.table(studentAbove50);
```

![Une capture d'√©cran montrant VS Code filtrant une liste d'objets.](/assets/first-steps/data-structures/array-objects-filter.png)

## Conclusion

Il y a encore beaucoup √† explorer sur les objets et les listes... Et il existe d'autres structures de donn√©es comme `Map` et `Set`. Cependant, je pense que ceci constitue d√©j√† une base solide pour vous.

Ce que nous avons couvert repr√©sente environ 90 % de ce que vous utiliserez au quotidien. Et je ne veux pas surcharger votre cerveau trop vite ! (Trop tard ? üò¨)

Passons maintenant aux boucles et aux conditions. Nous sommes plus proches que jamais de construire notre tout premier projet concret !

<NoticeEnd lang="fr" />