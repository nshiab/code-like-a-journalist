---
title: Comment visualiser des donn√©es avec TypeScript
description: Dans cette le√ßon, nous apprenons √† visualiser des donn√©es tabulaires et g√©ospatiales avec Simple Data Analysis et Plot.
---

import { Callout } from 'nextra/components'
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Visualiser des donn√©es avec Simple Data Analysis et Plot

Les visualisations de donn√©es vous aident √† mieux comprendre vos donn√©es et √† communiquer vos conclusions. Dans cette le√ßon, nous allons apprendre √† visualiser des tables SDA, que ce soit avec des graphiques simples dans le terminal ou des visualisations plus pouss√©es avec la librairie Plot.

Nous utiliserons des donn√©es sur les feux de for√™t au Canada en 2023 et explorerons diff√©rentes techniques de visualisation, y compris des graphiques en ligne, des diagrammes en essaim et des cartes ! üåé

Cette le√ßon suppose que vous avez d√©j√† compl√©t√© les le√ßons sur les [Donn√©es tabulaires](/simple-data-analysis/tabular-data) et les [Donn√©es g√©ospatiales](/simple-data-analysis/geospatial).

<NoticeIntro lang="fr" />

## Configuration

Comme dans la le√ßon pr√©c√©dente, cr√©ez un nouveau dossier sur votre ordinateur, ouvrez-le avec VS Code et ex√©cutez la commande suivante dans le terminal : `deno -A jsr:@nshiab/setup-sda`

Apr√®s l'ex√©cution de cette commande, votre terminal affichera une description des fichiers cr√©√©s et des librairies install√©es.

Ensuite, ex√©cutez la t√¢che sugg√©r√©e pour d√©marrer et surveiller `sda/main.ts` : `deno task sda`

![Une capture d'√©cran montrant VS Code apr√®s l'ex√©cution de setup-sda.](/assets/simple-data-analysis/dataviz/setup.png)

Pour organiser notre code de mani√®re claire, nous allons cr√©er deux fonctions :
- `crunchData`, o√π nous allons r√©cup√©rer et nettoyer les donn√©es sur les feux de for√™t.
- `visualizeData`, o√π nous allons g√©n√©rer nos graphiques et nos cartes.

Commen√ßons par `crunchData`. Cr√©ez un fichier `crunchData.ts` dans `./sda/helpers/`. Cette fonction `async` attend un param√®tre `fires` de type `SimpleTable`, qui est une table SDA. La fonction n'a pas besoin de renvoyer de valeur.

√Ä l'int√©rieur, nous allons r√©cup√©rer et mettre en cache les donn√©es sur les feux de for√™t. Cet ensemble de donn√©es est une version l√©g√®rement modifi√©e de celui utilis√© dans la le√ßon pr√©c√©dente. Il inclut des dates et uniquement les feux ayant une superficie br√ªl√©e (`hectares`) sup√©rieure √† z√©ro.

```ts showLineNumbers filename="crunchData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });
}
````

Nous pouvons maintenant nous occuper de `visualizeData`. Cr√©ez un fichier `visualizeData.ts` dans `./sda/helpers/`. C'est √©galement une fonction `async` qui prend un param√®tre `fires` de type `SimpleTable`. Pour l'instant, contentons-nous d'afficher la table dans la console.

```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
}
```

Mettons √† jour `main.ts` pour cr√©er la table `fires` et la passer √† nos nouvelles fonctions.

```ts  showLineNumbers filename="main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";
import crunchData from "./helpers/crunchData.ts";
import visualizeData from "./helpers/visualizeData.ts";

const sdb = new SimpleDB();
const fires = sdb.newTable("fires");

await crunchData(fires);
await visualizeData(fires);

await sdb.done();
```
![Une capture d'√©cran montrant VS Code apr√®s l'ex√©cution des fonctions d'aide.](/assets/simple-data-analysis/dataviz/helpers.png)

## Pr√©paration des donn√©es

Nous avons environ 5 000 feux de for√™t. Disons que nous aimerions visualiser la superficie br√ªl√©e au fil de l'ann√©e pour chaque province. Nous devons calculer la somme cumulative de la superficie br√ªl√©e.

Dans `crunchData.ts`, additionnons les superficies br√ªl√©es par date et par province.

```ts showLineNumbers filename="crunchData.ts" {10-15}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });

  await fires.summarize({
    values: "hectares",
    categories: ["province", "startdate"],
    summaries: "sum",
    decimals: 1,
  });
}
```
![Une capture d'√©cran montrant VS Code affichant des tables de donn√©es.](/assets/simple-data-analysis/dataviz/summary.png)

Nous pouvons maintenant calculer la somme cumulative par province avec la m√©thode `accumulate`. Nous pouvons √©galement arrondir les valeurs avec la m√©thode `round` pour √©viter les erreurs d'arrondi li√©es aux nombres √† virgule flottante.

```ts showLineNumbers filename="crunchData.ts" {16-19}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });

  await fires.summarize({
    values: "hectares",
    categories: ["province", "startdate"],
    summaries: "sum",
    decimals: 1,
  });
  await fires.accumulate("sum", "cumulativeHectares", {
    categories: "province",
  });
  await fires.round("cumulativeHectares", { decimals: 1 });
}
```
![Une capture d'√©cran montrant une nouvelle colonne cumulativeHectares dans une table de donn√©es.](/assets/simple-data-analysis/dataviz/cumulative.png)

Visualisons maintenant ces donn√©es !

## Dans le terminal

SDA propose des m√©thodes pour afficher facilement des graphiques dans votre terminal. C'est un excellent moyen d'inspecter rapidement vos donn√©es. Travaillons dans `visualizeData.ts`.

Dans l'exemple ci-dessous, nous utilisons la m√©thode `logDotChart` avec :
- La colonne `startdate` pour les valeurs en abscisse (x).
- La colonne `cumulativeHectares` pour les valeurs en ordonn√©e (y).

J'ai √©galement ajout√© quelques options :
- Nous utilisons la valeur `province` pour cr√©er des graphiques multiples (un graphique par province).
- Nous appliquons la m√™me √©chelle √† tous les graphiques, ce qui facilite la comparaison entre les provinces.
- Nous formatons les libell√©s de l'axe des y avec la fonction `formatNumber` de la librairie [journalism](https://github.com/nshiab/journalism). J'ai cr√©√© cette librairie pour fournir des fonctions utilitaires g√©n√©rales. Elle est automatiquement install√©e avec `setup-sda`.

```ts showLineNumbers filename="visualizeData.ts" {6-14}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { formatNumber } from "@nshiab/journalism/web";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  await fires.logDotChart(
    "startdate",
    "cumulativeHectares",
    {
      smallMultiples: "province",
      fixedScales: true,
      formatY: (d) => formatNumber(d as number, { decimals: 0, suffix: " ha" }),
    },
  );
}
```
![Une capture d'√©cran montrant des graphiques en points dans le terminal.](/assets/simple-data-analysis/dataviz/dot-charts.png)

Vous n'√™tes pas limit√© aux graphiques en points. Vous pouvez √©galement utiliser les m√©thodes `logLineChart`, `logBarChart` et `logHistogram`.

Cependant, bien que ces m√©thodes soient tr√®s pratiques, elles restent assez limit√©es.

## Avec Plot

### Hectares br√ªl√©s cumul√©s par province

[Plot](https://github.com/observablehq/plot) est une librairie fantastique pour cr√©er des graphiques. Elle est bas√©e sur la c√©l√®bre librairie [d3](https://github.com/d3/d3) (d√©velopp√©e par la m√™me √©quipe, dont [Mike Bostock](https://github.com/mbostock) et [Philippe Rivi√®re](https://github.com/Fil)). Cependant, elle est bien plus facile √† utiliser, car de nombreux √©l√©ments qui doivent √™tre g√©r√©s manuellement avec d3 (√©chelles, axes, etc.) sont pris en charge automatiquement par Plot.

SDA int√®gre Plot de mani√®re transparente et l'installe automatiquement lorsque vous configurez votre projet avec `setup-sda`.

Pour cr√©er un graphique et l'enregistrer sous forme de fichier (`.jpeg`, `.png` ou `.svg` si vous souhaitez le retravailler dans Illustrator), vous pouvez utiliser la m√©thode `writeChart`.

La m√©thode `writeChart` n√©cessite deux arguments :
- Une fonction qui g√©n√®re un graphique Plot.
- Un chemin d'acc√®s pour enregistrer le fichier image.

Dans `visualizeData.ts`, cr√©ons un graphique en ligne simple repr√©sentant la superficie br√ªl√©e au fil de l'ann√©e 2023 pour chaque province.


```ts showLineNumbers filename="visualizeData.ts" {2, 6-16}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique en ligne enregistr√© au format png.](/assets/simple-data-analysis/dataviz/draw-chart.png)

<Callout type="info" emoji="üí°">
   Pour ouvrir deux onglets l'un au-dessus de l'autre, faites un clic droit sur l'onglet que vous souhaitez placer en bas et cliquez sur `Split down`. Dans la capture d'√©cran ci-dessus, j'ai masqu√© le terminal, mais m√™me s'il n'est pas affich√©, il continue de s'ex√©cuter et surveille `main.ts`. Ainsi, √† chaque mise √† jour du code du graphique, `main.ts` est relanc√© et le graphique est mis √† jour.
</Callout>

Laissez-moi vous expliquer le code ci-dessus: 
- Aux lignes 6-15, je cr√©e une fonction `drawChart`. Cette fonction attend une liste de valeurs `unknown`, car elle ne sait pas √† l'avance ce que contient notre table. En r√©alit√©, nos donn√©es seront sous forme d'une liste d'objets, comme d'habitude.
- √Ä la ligne 7, j'appelle la fonction `plot` de Plot. Cette fonction cr√©e un graphique et n√©cessite un objet avec certaines options.
- √Ä la ligne 8, j'ajoute une cl√© `marks` contenant une liste. C'est l'option la plus importante. `marks` d√©finit les formes qui repr√©sentent nos donn√©es.
- Aux lignes 9-13, √† l'int√©rieur de la liste `marks`, j'appelle la fonction `line` pour tracer des lignes bas√©es sur nos `data`. Pour les options de `line`, je sp√©cifie les valeurs `x` (`startdate`), les valeurs `y` (`cumulativeHectares`), et la couleur de `stroke` (bas√©e sur les valeurs de `province`).
- Enfin, √† la ligne 16, j'appelle la m√©thode `writeChart` sur la table `fires`. Le premier argument est notre fonction `drawChart`, qui recevra automatiquement les donn√©es `fires`. Le deuxi√®me argument sp√©cifie l'emplacement o√π enregistrer le graphique, dans le dossier `output`.

Notre graphique est encore assez basique, et il y a quelques probl√®mes, comme l'axe des y. Corrigeons cela !

```ts showLineNumbers filename="visualizeData.ts" {8-14}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique avec un meilleur axe des y.](/assets/simple-data-analysis/dataviz/y-axis.png)

C'est mieux ! Pour mettre √† jour l'axe des y, vous pouvez passer des options √† `y` sous forme d'objet. Voici ce que nous faisons dans le code ci-dessus :
- Nous ajoutons des grilles pour rendre le graphique plus lisible.
- Nous formatons le libell√© de l'axe sup√©rieur pour le rendre plus compr√©hensible avec l'unit√©.
- Nous limitons le nombre de graduations de l'axe √† 5.
- Nous formatons les libell√©s des graduations pour afficher des millions d'hectares au lieu d'hectares simples.

J'ai √©galement ajout√© un `inset` de `10` pour laisser un peu plus d'espace au libell√© du haut.

Passons maintenant au libell√© de l'axe des x. Il n'est pas n√©cessaire de modifier les libell√©s des graduations pour l'axe des x, car Plot g√®re tr√®s bien les dates et affiche automatiquement les ann√©es, mois, jours, voire l'heure, en fonction des valeurs de l'√©chelle et de la largeur de l'axe.

Les couleurs sont actuellement attribu√©es automatiquement. Nous pourrions choisir un autre jeu de couleurs et peut-√™tre ajouter une l√©gende.

```ts showLineNumbers filename="visualizeData.ts" {15-21}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        legend: true,
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique avec une l√©gende de couleurs.](/assets/simple-data-analysis/dataviz/x-colors.png)

Hmmmm... La l√©gende des couleurs ne fonctionne pas tr√®s bien avec autant de cat√©gories. Il faut changer de strat√©gie. Plut√¥t qu'une l√©gende, nous pourrions ajouter un point et un libell√© √† la fin de chaque ligne.

Supprimons la l√©gende des couleurs et ajoutons une `mark` `dot`. Comme nous voulons placer les points √† la fin de chaque ligne, nous utilisons la transformation `selectLast`, qui s√©lectionnera uniquement le dernier point de donn√©es.

Notez que l'ordre des √©l√©ments dans la liste `marks` est important. Les `marks` sont dessin√©es dans l'ordre d'ajout. Si vous souhaitez qu'une forme apparaisse au-dessus d'une autre, ajoutez-la plus tard dans la liste.


```ts showLineNumbers filename="visualizeData.ts" {2, 27-34}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
        dot(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            fill: "province",
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique en ligne avec des points √† la fin.](/assets/simple-data-analysis/dataviz/dots.png)

Ajoutons maintenant les libell√©s. Nous utilisons √† nouveau `selectLast` avec quelques options suppl√©mentaires :
- En plus de `x` et `y`, nous utilisons `z` pour indiquer √† Plot que nous voulons un texte pour chaque province. Si nous avions utilis√© `fill` ou `stroke` avec les valeurs de `province`, cela aurait √©t√© automatique, car le texte aurait pris la m√™me couleur que les lignes. Cependant, je pr√©f√®re un texte noir pour plus de lisibilit√©.
- Nous utilisons les valeurs de la colonne `province` pour le `text`.
- Nous appliquons un `fill` noir avec un `stroke` blanc afin d'am√©liorer la lisibilit√©, garantissant que le texte reste visible m√™me lorsqu'il chevauche d'autres √©l√©ments du graphique.
- Nous d√©finissons `textAnchor` sur `start` afin que le texte s'aligne avec le `dot`, mais nous le d√©calons de 5 pixels avec `dx` pour √©viter qu'il ne touche le point.

```ts showLineNumbers filename="visualizeData.ts" {2, 35-47}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
        dot(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            fill: "province",
          }),
        ),
        text(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            z: "province",
            text: "province",
            fill: "black",
            stroke: "white",
            textAnchor: "start",
            dx: 5,
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique en ligne avec des points et des √©tiquettes de texte √† la fin.](/assets/simple-data-analysis/dataviz/text-labels.png)

C'est bien mieux ! Mais notre graphique n√©cessite encore quelques ajustements √©vidents.

Par exemple, les points et les libell√©s √† la fin des lignes ne sont pas align√©s... Comme nous avons agr√©g√© les donn√©es en fonction de la date de d√©but des feux (`startDate`), certaines provinces ont des trous dans leurs dates.

Nous constatons √©galement qu'il ne se passe pas grand-chose avant la mi-avril et apr√®s le 1er octobre.

Revenons √† `crunchData.ts` pour corriger cela :
- √Ä la ligne 10, nous filtrons les feux pour ne conserver que ceux ayant un `startDate` entre le 15 avril 2023 et le 1er octobre 2023.
- Aux lignes 21-30, nous r√©cup√©rons la valeur maximale de `cumulativeHectares` pour chaque province et stockons les r√©sultats dans une nouvelle table, `maxValuesPerProvince`. Ensuite, nous supprimons et renommons certaines colonnes pour correspondre √† celles de la table `fires`. Nous ajoutons √©galement une nouvelle colonne avec la date finale de nos donn√©es (1er octobre 2023). Enfin, nous ins√©rons les lignes de cette nouvelle table dans `fires`.


```ts showLineNumbers filename="crunchData.ts" {10, 21-30}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });

  await fires.filter(`startdate >= '2023-04-15' && startdate <= '2023-10-01'`);
  await fires.summarize({
    values: "hectares",
    categories: ["province", "startdate"],
    summaries: "sum",
    decimals: 1,
  });
  await fires.accumulate("sum", "cumulativeHectares", {
    categories: "province",
  });
  await fires.round("cumulativeHectares", { decimals: 1 });
  const maxValuesPerProvince = await fires.summarize({
    values: "cumulativeHectares",
    categories: "province",
    summaries: "max",
    outputTable: "maxValuesPerProvince",
  });
  await maxValuesPerProvince.removeColumns("value");
  await maxValuesPerProvince.renameColumns({ max: "cumulativeHectares" });
  await maxValuesPerProvince.addColumn("startdate", "date", `'2023-10-01'`);
  await fires.insertTables(maxValuesPerProvince);
}
```
![Une capture d'√©cran montrant un graphique en ligne avec des √©tiquettes align√©es.](/assets/simple-data-analysis/dataviz/labels-aligned.png)

Et maintenant, nos libell√©s sont correctement align√©s !

Retournons dans `visualizeData.ts` pour corriger la marge de droite. Nous pouvons √©galement filtrer certaines √©tiquettes afin d'√©viter le chevauchement du texte.

```ts showLineNumbers filename="visualizeData.ts" {8, 46}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      marginRight: 110,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
        dot(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            fill: "province",
          }),
        ),
        text(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            z: "province",
            text: "province",
            fill: "black",
            stroke: "white",
            textAnchor: "start",
            dx: 5,
            filter: (d) => d.cumulativeHectares >= 400_000,
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```

Et voici notre graphique ! Plut√¥t sympa, non ? üòä

![Le graphique final en ligne.](/assets/simple-data-analysis/dataviz/line-chart-final.png)

Bien s√ªr, vous pouvez faire bien plus avec Plot. N'h√©sitez pas √† consulter la [documentation](https://observablehq.com/plot/getting-started) et les [exemples](https://observablehq.com/@observablehq/plot-gallery).

Et si vous souhaitez cr√©er des graphiques modifiables dans des logiciels comme Illustrator, enregistrez-les simplement au format `.svg` au lieu de `.png`.

### Diagramme en essaim des feux de for√™t

Notre graphique pr√©c√©dent √©tait assez classique, mais vous pouvez √©galement cr√©er des visualisations plus originales.

Par exemple, cr√©ons un diagramme en essaim des feux de for√™t.

Nous pouvons mettre √† jour `crunchData.ts` pour revenir √† nos donn√©es brutes. Cependant, limitons-nous aux feux de plus de 1 hectare. Cela nous laisse environ 2 400 feux, ce qui est d√©j√† assez cons√©quent puisque nous voulons les visualiser individuellement !

```ts showLineNumbers filename="crunchData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });
  await fires.filter(`hectares > 1`);
}
```

And let's start by drawing our fires as simple dots on a y-axis.

```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      marks: [
        dot(data, { y: "hectares" }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![The fires as simple dots.](/assets/simple-data-analysis/dataviz/fires-dots.png)

Right now, our fires are overlapping. The purpose of a beeswarm chart is to stack data points in a way that ensures each one remains visible.

To create a beeswarm, we can use the `dodge` transform with the `middle` option. Let's update our code.

Rendering this chart may take a few seconds, depending on your machine's processing power.

```ts showLineNumbers filename="visualizeData.ts" {2, 9}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      marks: [
        dot(data, dodgeX("middle", { y: "hectares" })),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Our first beeswarm.](/assets/simple-data-analysis/dataviz/fires-dodge.png)

It looks like we have a looooot of small wildfires and a few very big ones.

A logarithmic scale could help with that! Let's change our `y` scale `type` to `log`.

```ts showLineNumbers filename="visualizeData.ts" {8-10}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      y: {
        type: "log",
      },
      marks: [
        dot(data, dodgeX("middle", { y: "hectares" })),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![The beeswarm chart with a logarithmic scale.](/assets/simple-data-analysis/dataviz/log-scale.png)

This is already much better. Another improvement would be to scale the dot radius based on fire size. 

We can update the options for the `dot` function and adjust the `r` scale to ensure a minimum radius of 1 pixel and a maximum of 20 pixels.


```ts showLineNumbers filename="visualizeData.ts" {11-13, 15}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      y: {
        type: "log",
      },
      r: {
        range: [1, 20],
      },
      marks: [
        dot(data, dodgeX("middle", { y: "hectares", r: "hectares" })),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![The beeswarm chart with the radius tied to the hectares burned.](/assets/simple-data-analysis/dataviz/radiuses.png)

We are getting there.

Let's fill the circles based on the cause of the fire and add a legend.

```ts showLineNumbers filename="visualizeData.ts" {14-16, 20}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      y: {
        type: "log",
      },
      r: {
        range: [1, 20],
      },
      color: {
        legend: true,
      },
      marks: [
        dot(
          data,
          dodgeX("middle", { y: "hectares", r: "hectares", fill: "cause" }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![The beeswarm chart with the color depending on the cause of fire.](/assets/simple-data-analysis/dataviz/fires-color.png)

To help compare the causes, we could use facets. Let's do that to create three small charts instead of one large one. 

To achieve this, we use the `fx` option to create horizontal facets. Let's also increase the chart width for better readability.

```ts showLineNumbers filename="visualizeData.ts" {8, 25}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      width: 800,
      y: {
        type: "log",
      },
      r: {
        range: [1, 20],
      },
      color: {
        legend: true,
      },
      marks: [
        dot(
          data,
          dodgeX("middle", {
            y: "hectares",
            r: "hectares",
            fill: "cause",
            fx: "cause",
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![The beeswarm chart with facets on the cause of fires.](/assets/simple-data-analysis/dataviz/facets.png)

This is starting to look very good. We probably don't need the color legend anymore. 

Let's tweak the labels and axes, then call it a day!

```ts showLineNumbers filename="visualizeData.ts" {8-9, 12-14, 19-21}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      width: 800,
      marginTop: 40,
      y: {
        type: "log",
        label: "Hectares",
        ticks: 5,
        grid: true,
      },
      r: {
        range: [1, 20],
      },
      fx: {
        label: null,
      },
      marks: [
        dot(
          data,
          dodgeX("middle", {
            y: "hectares",
            r: "hectares",
            fill: "cause",
            fx: "cause",
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```

This is quite nice, isn't it? By playing with marks and transforms, you can create stunning data visualizations with SDA and Plot.

Again, I encourage you to check the Plot [documentation](https://observablehq.com/plot/getting-started) and [examples](https://observablehq.com/@observablehq/plot-gallery). You'll have a lot of fun with this library! üíÉüï∫

![The beeswarm chart.](/assets/simple-data-analysis/dataviz/beeswarm.png)

### Fires map

With SDA, you can work with both tabular and geospatial data. When wrangling geospatial data, you often want to create maps!

Let's map our fires along with the Canadian province boundaries.

First, we need to store the fire geometries in the same table as the province boundaries.

Let's reuse what we did in the previous lesson and update `crunchData.ts`. We'll modify it to take a second table, `provinces`, as a parameter. We fetch and cache the province boundaries, then insert them into the `fires` table. Before inserting, we add a column `isFire` to the `fires` table to easily differentiate them later.


```ts showLineNumbers filename="crunchData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(
  fires: SimpleTable,
  provinces: SimpleTable,
) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
    await fires.points("lat", "lon", "geom");
    await fires.addColumn("isFire", "boolean", `TRUE`);
  });

  await provinces.cache(async () => {
    await provinces.loadGeoData(
      "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
    );
  });

  await fires.insertTables(provinces, { unifyColumns: true });
}
```

Let's remove everything except the `logTable` in `visualizeData.ts` for now.

```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
}
```

And let's update `main.ts` to create a new table `provinces` and pass it to `crunchData`.


```ts showLineNumbers filename="main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";
import crunchData from "./helpers/crunchData.ts";
import visualizeData from "./helpers/visualizeData.ts";

const sdb = new SimpleDB();
const fires = sdb.newTable("fires");
const provinces = sdb.newTable("provinces");

await crunchData(fires, provinces);
await visualizeData(fires);

await sdb.done();
```

Here's what you should see to start on the right foot.

![VS Code running and watching main.ts.](/assets/simple-data-analysis/dataviz/map-start.png)

Now, let's work on our map in `visualizeData`. Instead of using `writeChart`, we must use `writeMap`.

Since we are working with geospatial data, `writeMap` passes the data as GeoJSON to the drawing function. This is why `drawMap` expects data with the type `{ features: { properties: { [key: string]: unknown } }[] }`. Essentially, this means that our table data is now stored in each feature's `properties`.

To easily work with the fires and the provinces, we first isolate them on lines 9-14. Then, in the `plot` function, we use the `geo` mark, which handles the geospatial coordinates of the features.

```ts showLineNumbers filename="visualizeData.ts" {2, 6-23}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      marks: [
        geo(provincesPolygons),
        geo(firesPoints),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code showing a basic map.](/assets/simple-data-analysis/dataviz/basic-map.png)

As you can see in the screenshot above, the `geo` mark automatically detected the point coordinates of our fires and the polygon coordinates of the Canadian province boundaries. Pretty clever! ü§ì

Right now, the projection is Mercator. Fortunately, Plot supports better projections. Let's update the `projection` option:
- Set the `type` to `conic-conformal`.
- Use the `rotate` option to ensure the map isn't tilted with this projection.
- Use the `domain` option to help Plot make our geospatial data take up as much space as possible on the map.

```ts showLineNumbers filename="visualizeData.ts" {17-21}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      marks: [
        geo(provincesPolygons),
        geo(firesPoints),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code showing a conic conformal projection.](/assets/simple-data-analysis/dataviz/projection.png)

This is looking better. Let's style our province boundaries to create a nice light background.

```ts showLineNumbers filename="visualizeData.ts" {23-26}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        geo(firesPoints),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code showing province boundaries as light grey.](/assets/simple-data-analysis/dataviz/boundaries.png)

Now, let's work on the fires. Since they are point geometries, Plot automatically represents them as dots using the `geo` mark.

But nothing stops us from using another mark! Let's create a `spike` map instead.

Because the fires are a collection of GeoJSON features, we need to use arrow functions to specify where Plot should find the right values for the spike options.

```ts showLineNumbers filename="visualizeData.ts" {2, 22-24, 30-34}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot, spike } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      length: {
        range: [1, 100],
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        spike(firesPoints, {
          x: (d) => d.properties.lon,
          y: (d) => d.properties.lat,
          length: (d) => d.properties.hectares,
        }),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code showing a basic spike map.](/assets/simple-data-analysis/dataviz/basic-spike-map.png)

This is quite interesting! Now, let's color-code the spikes based on the cause of the wildfires.

```ts showLineNumbers filename="visualizeData.ts" {25-27, 37}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot, spike } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      length: {
        range: [1, 100],
      },
      color: {
        legend: true,
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        spike(firesPoints, {
          x: (d) => d.properties.lon,
          y: (d) => d.properties.lat,
          length: (d) => d.properties.hectares,
          stroke: (d) => d.properties.cause,
        }),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code showing a colored spike map.](/assets/simple-data-analysis/dataviz/spikes-color.png)

We have a lot of overlapping spikes. By default, Plot draws the spikes in the order they appear in the data.

Let's update `crunchData` to sort the fires in ascending order by their `hectares` values so that the larger fires are drawn last and appear on top of the others.


```ts showLineNumbers filename="crunchData.ts" {13}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(
  fires: SimpleTable,
  provinces: SimpleTable,
) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
    await fires.points("lat", "lon", "geom");
    await fires.addColumn("isFire", "boolean", `TRUE`);
    await fires.sort({ hectares: "asc" });
  });

  await provinces.cache(async () => {
    await provinces.loadGeoData(
      "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
    );
  });

  await fires.insertTables(provinces, { unifyColumns: true });
}
```

Also, by default, Plot assigns an opacity of 0.3 to the fill color of the spikes. Instead, we can use paler colors that match the color legend. Removing the transparency will help reduce visual confusion on the map.

Additionally, we can increase the maximum spike height for better visibility.

```ts showLineNumbers filename="visualizeData.ts" {23, 38-47}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot, spike } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      length: {
        range: [1, 200],
      },
      color: {
        legend: true,
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        spike(firesPoints, {
          x: (d) => d.properties.lon,
          y: (d) => d.properties.lat,
          length: (d) => d.properties.hectares,
          stroke: (d) => d.properties.cause,
          fillOpacity: 1,
          fill: (d) => {
            if (d.properties.cause === "Human") {
              return "#b5caff";
            } else if (d.properties.cause === "Natural") {
              return "#ffe6a8";
            } else {
              return "#ffb9ad";
            }
          },
        }),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
<Callout type="info" emoji="üí°">
   There are many ways to represent colors. Here, I am using HEX color values. Read [this](https://www.w3schools.com/html/html_colors_hex.asp) if you want to know more.
</Callout>

This is looking great! To learn more about maps, check out the [`geo` mark documentation](https://observablehq.com/plot/marks/geo) as well as the [`projection` documentation](https://observablehq.com/plot/features/projections).

![Our final spike map.](/assets/simple-data-analysis/dataviz/final-spike-map.png)

## Conclusion

Congrats! You now know how to create data visualizations with SDA and Plot!

I hope the step-by-step examples helped you understand how to build everything from simple charts to more innovative ones using both tabular and geospatial data.

Of course, these visualizations are static. There‚Äôs no user interaction since they are saved as images.

But don‚Äôt worry! We‚Äôll reuse everything we‚Äôve learned here to create interactive data visualizations on the web in a future lesson! üòÅ

See you soon!

<NoticeEnd lang="fr"/>
