---
title: Comment refactoriser du code TypeScript
description: Apprenez √† refactoriser du code TypeScript en le divisant en fonctions modulaires.
---

import { Callout } from 'nextra/components'

# Refactorisation

Coder, c'est comme un voyage. Vous savez d'o√π vous partez et o√π vous voulez aller (en th√©orie üòÖ). Mais vous ne savez pas quelle route emprunter. Alors, vous commencez √† explorer, essayez une direction, revenez en arri√®re, prenez un raccourci, tombez sur des impasses, et suivez des chemins plus longs jusqu'√†... finalement arriver √† destination. Et c'est totalement normal.

C'est la m√™me chose avec votre code. Vous √©crirez beaucoup, ferez des erreurs, trouverez des solutions de contournement et, finalement, obtiendrez vos premiers r√©sultats. Votre code sera d√©sordonn√© et long. Et c'est tout √† fait normal aussi.

C'est pourquoi la **refactorisation** est une √©tape importante. Elle consiste √† restructurer votre code pour am√©liorer sa lisibilit√©, sa maintenabilit√© et, parfois, ses performances, tout en conservant le m√™me r√©sultat.

Un aspect cl√© de la refactorisation est de diviser les longs scripts en fonctions modulaires.

Dans cette le√ßon, nous prendrons le code final du [calculateur de compte √©pargne üí∏](/saving-account-calculator) et le refactoriserons. Si vous n'avez pas fait ce projet, faites-le d'abord‚ÄØ! Je m'attends √©galement √† ce que vous ayez termin√© toutes les le√ßons de la section **Premiers pas** üßë‚Äçüéì.

## Configuration

Cr√©ez un nouveau dossier quelque part sur votre ordinateur, ouvrez-le avec VS Code, et cr√©ez deux fichiers :

- `main.ts`, o√π nous √©crirons notre code.
- `deno.json`, qui permet √† VS Code de savoir qu'il s'agit d'un projet Deno et active l'extension Deno. Vous pouvez ajuster les param√®tres dans ce fichier, mais nous le laisserons vide pour l'instant.

Ouvrez le terminal et ex√©cutez la commande suivante : `deno run --watch --check main.ts`

Cette commande efface le terminal et r√©ex√©cute `main.ts` √† chaque fois que vous le sauvegardez (`CMD` + `S` sur Mac ou `CTRL` + `S` sur PC).

Maintenant, copiez, collez et sauvegardez ce code dans `main.ts`. Le script ci-dessous calcule les gains ou pertes d'un compte √©pargne sur 10 ans.


```ts showLineNumbers filename="main.ts"
const initialAmount = 5000;
const interestRate = 2;
const interestRateRange = 20;
const startingYear = 2025;
const years = 10;
 
let balance = initialAmount;
 
const results = [];
 
for (let year = startingYear; year < startingYear + years; year++) {
  const randomNumber = Math.random() - 0.5;
  const randomFluctuation = randomNumber * interestRateRange;
  const randomInterestRate = Math.round(interestRate + randomFluctuation);
 
  const gainsOrLosses = Math.round(balance * (randomInterestRate / 100));
 
  balance += gainsOrLosses;
 
  results.push({
    year,
    interestRate: randomInterestRate,
    gainsOrLosses,
    balance,
  });
}
 
const lastResult = results[results.length - 1];
const finalGainsOrLosses = lastResult.balance - initialAmount;
const perc = Math.round(
  (finalGainsOrLosses / initialAmount) * 100,
);
 
if (finalGainsOrLosses > 0) {
  console.log(`
Congratulations! You've made money!
Initial amount: $${initialAmount}
Final amount: $${lastResult.balance}
Gains: $${finalGainsOrLosses} (+${perc}%)
`);
} else if (finalGainsOrLosses < 0) {
  console.log(`
Sorry! You've lost money!
Initial amount: $${initialAmount}
Final amount: $${lastResult.balance}
Losses: $${finalGainsOrLosses} (${perc}%)
`);
} else {
  console.log("\nYou've neither lost nor gained money!\n");
}
 
console.table(results);
```

Voici ce que vous devriez voir dans votre terminal, avec des valeurs diff√©rentes.

![Une capture d'√©cran montrant le terminal VS Code avec un tableau et des cha√Ænes de caract√®res affich√©s.](/assets/ninja-moves/refactoring/results.png)

## Fonctions utilitaires

Le script fonctionne bien, mais lire tout cela d'un coup peut √™tre un peu intimidant. Il pourrait √™tre refactoris√© pour √™tre plus facile √† lire et √† comprendre.

Nous pouvons le faire en d√©pla√ßant certaines parties du code dans des fonctions utilitaires. Commencez par cr√©er un nouveau dossier nomm√© `helpers` dans votre r√©pertoire.

Il semble que les lignes 12-14 pourraient facilement √™tre encapsul√©es dans une fonction. Ces lignes calculent un taux d'int√©r√™t al√©atoire. Cr√©ons un nouveau fichier nomm√© `randomInterestRate.ts` dans le dossier `helpers` et d√©pla√ßons ces lignes dans une fonction.

```ts showLineNumbers filename="randomInterestRate.ts"
export default function getRandomInterestRate(
  interestRate: number,
  interestRateRange: number,
) {
  const randomNumber = Math.random() - 0.5;
  const randomFluctuation = randomNumber * interestRateRange;
  const randomInterestRate = Math.round(interestRate + randomFluctuation);

  return randomInterestRate;
}
```

Les lignes 28-50 sont √©galement d'excellentes candidates pour la refactorisation. Ces lignes affichent un message bas√© sur les gains ou pertes. D√©pla√ßons-les dans une fonction nomm√©e `logAnswer`.

J'ai √©galement supprim√© le `console.table(results)` puisque nous n'en avons pas vraiment besoin.

```ts showLineNumbers filename="logAnswer.ts"
export default function logAnswer(
  initialAmount: number,
  results: { balance: number }[],
) {
  const lastResult = results[results.length - 1];
  const finalGainsOrLosses = lastResult.balance - initialAmount;
  const perc = Math.round(
    (finalGainsOrLosses / initialAmount) * 100,
  );

  if (finalGainsOrLosses > 0) {
    console.log(`
Congratulations! You've made money!
Initial amount: $${initialAmount}
Final amount: $${lastResult.balance}
Gains: $${finalGainsOrLosses} (+${perc}%)
`);
  } else if (finalGainsOrLosses < 0) {
    console.log(`
Sorry! You've lost money!
Initial amount: $${initialAmount}
Final amount: $${lastResult.balance}
Losses: $${finalGainsOrLosses} (${perc}%)
`);
  } else {
    console.log("\nYou've neither lost nor gained money!\n");
  }
}
```

Vous pourriez √™tre perplexe face au type de `results` dans le code ci-dessus.

`{ balance: number }` d√©crit un objet avec une cl√© `balance` et une valeur associ√©e de type `number`. Les `[]` √† la fin indiquent que nous nous attendons √† ce que `results` soit une liste compos√©es d'objets correspondant √† cette description.

Cette description de type est importante. Dans notre code, nous utilisons `balance`. Ce type garantit qu‚Äôil est pr√©sent. Si vous essayez de passer une liste d'objets sans une cl√© `balance` de type `number`, vous obtiendrez une erreur de type.

Pour trouver le type appropri√©, j'ai simplement survol√© `results` dans `main.ts` et copi√© le type inf√©r√©. Pas besoin de l'√©crire vous-m√™me ! J'ai supprim√© les cl√©s `year`, `interestRate` et `gainsOrLosses`, car nous ne les utilisons pas dans la fonction.

![Une capture d'√©cran montrant VS Code affichant les types inf√©r√©s.](/assets/ninja-moves/refactoring/inferred-types.png)

Nous pouvons maintenant mettre √† jour notre `main.ts`. Nous importons nos nouvelles fonctions et les utilisons. Notre script est maintenant plus simple et plus facile √† comprendre.

```ts showLineNumbers filename="main.ts" {1-2, 20, 32}
import getRandomInterestRate from "./helpers/getRandomInterestRate.ts";
import logAnswer from "./helpers/logAnswer.ts";

const initialAmount = 5000;
const interestRate = 2;
const interestRateRange = 20;
const startingYear = 2025;
const years = 10;

let balance = initialAmount;

const results = [];

for (let year = startingYear; year < startingYear + years; year++) {
  const randomInterestRate = getRandomInterestRate(
    interestRate,
    interestRateRange,
  );

  const gainsOrLosses = Math.round(balance * (randomInterestRate / 100));

  balance += gainsOrLosses;

  results.push({
    year,
    interestRate: randomInterestRate,
    gainsOrLosses,
    balance,
  });
}

logAnswer(initialAmount, results);
```

Nous pourrions m√™me aller plus loin en enveloppant tout le contenu de `main.ts` dans une fonction nomm√©e `runSimulation`.

Cr√©ons un autre fichier nomm√© `runSimulation.ts` dans le dossier `helpers` et d√©pla√ßons-y tout ce code.

Puisque nous sommes maintenant dans le dossier `helpers`, nous devons mettre √† jour les chemins d'acc√®s pour `getRandomInterestRate.ts` et `logAnswer.ts`.

De plus, les constantes `initialAmount`, `interestRate`, `interestRateRange`, `startingYear` et `years` deviendront d√©sormais des param√®tres pour la fonction `runSimulation`.

```ts showLineNumbers filename="runSimulation.ts"
import getRandomInterestRate from "./getRandomInterestRate.ts";
import logAnswer from "./logAnswer.ts";

export default function runSimulation(
  initialAmount: number,
  interestRate: number,
  interestRateRange: number,
  startingYear: number,
  years: number,
) {
  let balance = initialAmount;

  const results = [];

  for (let year = startingYear; year < startingYear + years; year++) {
    const randomInterestRate = getRandomInterestRate(
      interestRate,
      interestRateRange,
    );

    const gainsOrLosses = Math.round(balance * (randomInterestRate / 100));

    balance += gainsOrLosses;

    results.push({
      year,
      interestRate: randomInterestRate,
      gainsOrLosses,
      balance,
    });
  }

  logAnswer(initialAmount, results);
}
```

Nous pouvons maintenant mettre √† jour `main.ts` et le rendre... incroyablement simple.

```ts showLineNumbers filename="main.ts"
import runSimulation from "./helpers/runSimulation.ts";

runSimulation(5000, 2, 20, 2025, 10);
```

Notre code est maintenant tr√®s modulaire. Alors que notre script initial ne pouvait ex√©cuter qu'une seule simulation √† la fois, nous pouvons d√©sormais en ex√©cuter facilement un millier ou plus‚ÄØ!

```ts showLineNumbers filename="main.ts"
import runSimulation from "./helpers/runSimulation.ts";

for (let i = 1; i <= 1000; i++) {
  console.log(`Simulation ${i}`);
  runSimulation(5000, 2, 20, 2025, 10);
}
```

![Une capture d'√©cran montrant VS Code affichant mille simulations.](/assets/ninja-moves/refactoring/run-simulation.png)

<Callout type="info" emoji="üí°">
    Vous pourriez penser que cr√©er plusieurs fichiers rend votre code plus difficile √† naviguer. Mais si vous appuyez sur `CMD` sur Mac ou `CTRL` sur PC et cliquez sur une fonction dans votre code, VS Code vous am√®nera automatiquement au fichier de la fonction en ouvrant un nouvel onglet.
</Callout>

## Conclusion

Vous n‚Äôavez pas toujours le luxe du temps pour refactoriser votre code. Mais si vous pr√©voyez le r√©utiliser, le partager ou le maintenir pendant longtemps, c‚Äôest un investissement qui en vaut la peine, surtout si vous ajoutez des tests (mais les tests feront l‚Äôobjet d‚Äôune autre le√ßon).
