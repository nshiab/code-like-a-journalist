---
title: Les fonctions en TypeScript
description: Apprenez √† cr√©er et utiliser des fonctions en TypeScript.
---

import { Callout } from 'nextra/components'
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Les fonctions

En encapsulant du code dans des fonctions, vous pouvez r√©utiliser ce m√™me code facilement. Les fonctions aident √©galement √† diviser de longs scripts en morceaux modulaires, ce qui les rend plus faciles √† g√©rer et √† d√©boguer.

<NoticeIntro lang="fr"/>

Pr√©parons notre environnement de travail pour cette le√ßon.

Cr√©ez un nouveau dossier quelque part sur votre ordinateur, ouvrez-le avec VS Code, et cr√©ez deux fichiers :

- `main.ts`, o√π nous √©crirons notre code. Pour commencer, vous pouvez ajouter `console.log("Hello!");` dedans.
- `deno.json`, qui permet √† VS Code de savoir qu'il s'agit d'un projet Deno et active l'extension Deno. Vous pouvez ajuster les param√®tres dans ce fichier, mais nous le laisserons vide pour l'instant.

Ouvrez le terminal et ex√©cutez la commande suivante :  
`deno run --watch --check main.ts`

Cette commande efface le terminal et r√©ex√©cute `main.ts` √† chaque fois que vous le sauvegardez (`CMD` + `S` sur Mac ou `CTRL` + `S` sur PC).

Vous pouvez utiliser cette configuration pour tester le code fourni dans cette le√ßon.

![Une capture d'√©cran montrant VS Code ex√©cutant et surveillant un fichier TypeScript.](/assets/pushing-further/functions/setup.png)

## Fonction de base

Pour cr√©er une fonction, vous devez la d√©clarer en utilisant le mot-cl√© `function`, suivi de son nom avec des parenth√®ses `()` et des accolades `{}`.

Cr√©ons une fonction appel√©e `sayHello` qui affiche `"Hello!"`. Le code que vous voulez que la fonction ex√©cute doit √™tre plac√© entre les `{}`. (Nous parlerons de ce qui se place entre les `()` dans un instant.)

Copiez et collez le code ci-dessous dans `main.ts`.

```ts showLineNumbers filename="main.ts"
function sayHello() {
  console.log("Hello!");
}
```

Si vous sauvegardez et ex√©cutez ce code, rien ne sera affich√©. Vous avez cr√©√© une fonction, mais vous ne l‚Äôavez pas encore **appel√©e**.

Pour **appeler une fonction**, vous devez utiliser son nom suivi de `()`, comme montr√© √† la ligne 5 ci-dessous.

```ts showLineNumbers filename="main.ts"
function sayHello() {
  console.log("Hello!");
}

sayHello()
```
<Callout type="info" emoji="üí°">
    Donner des noms clairs et compr√©hensibles aux fonctions est essentiel pour maintenir une base de code propre, facile √† d√©boguer et r√©utilisable. Comme les fonctions sont cens√©es faire quelque chose, il est souvent judicieux d'utiliser un verbe pour les nommer.
</Callout>

![Une capture d'√©cran montrant VS Code affichant Hello!.](/assets/pushing-further/functions/hello.png)

Maintenant, vous pouvez la r√©utiliser autant de fois que vous le souhaitez !

```ts showLineNumbers filename="main.ts"
function sayHello() {
  console.log("Hello!");
}

sayHello()
sayHello()
sayHello()
sayHello()
sayHello()
```

![Une capture d'√©cran montrant VS Code affichant plusieurs fois Hello!.](/assets/pushing-further/functions/hellos.png)

## Param√®tres

Notre fonction est assez basique. Ce serait plus int√©ressant si nous pouvions **passer** un `name` pour une salutation personnalis√©e, comme `"Hello, Nael!"`.

Pour ce faire, nous devons ajouter un **param√®tre** √† notre fonction‚Äîquelque chose qu'elle peut utiliser.

Les param√®tres sont d√©finis entre les `()` lors de la d√©claration de la fonction, et ils sont typ√©s.

Dans le code ci-dessous, nous ajoutons un param√®tre `name` √† la fonction `sayHello` et sp√©cifions que `name` doit √™tre de type `string`.

```ts showLineNumbers filename="main.ts"
function sayHello(name: string) {
  console.log(`Hello, ${name}!`);
}

sayHello();
```
<Callout type="info" emoji="üí°">
    √Ä la ligne 1, la syntaxe `name: string` est appel√©e un **type explicite**. Cela signifie que `name` doit √™tre un `string`. La plupart du temps, les types dans votre code sont inf√©r√©s. Mais dans certains cas, vous devez sp√©cifier explicitement les types souhait√©s. La d√©finition des param√®tres de fonction est l‚Äôun de ces cas.
</Callout>

Si vous copiez, collez et sauvegardez ce code, vous rencontrerez une erreur. Cela se produit parce que votre fonction attend maintenant un param√®tre `name`, et vous ne le fournissez pas lorsque vous appelez la fonction √† la ligne 5.

![Une capture d'√©cran montrant VS Code affichant une erreur √† cause d‚Äôun argument manquant.](/assets/pushing-further/functions/missing-name.png)

Passons l‚Äô**argument** `"Nael"` √† la fonction √† la ligne 5. Maintenant, elle affiche `"Hello, Nael!"`.


```ts showLineNumbers filename="main.ts"
function sayHello(name: string) {
  console.log(`Hello, ${name}!`);
}

sayHello("Nael");
```

![Une capture d'√©cran montrant VS Code affichant "Hello Nael".](/assets/pushing-further/functions/hello-nael.png)

Et maintenant, nous pouvons appeler la m√™me fonction avec des noms diff√©rents.

```ts showLineNumbers filename="main.ts"
function sayHello(name: string) {
  console.log(`Hello, ${name}!`);
}

sayHello("Nael");
sayHello("Emily");
sayHello("Diana");
sayHello("John");
sayHello("Jane");
```

![Une capture d'√©cran montrant VS Code affichant plusieurs "Hello" avec diff√©rents noms.](/assets/pushing-further/functions/hello-names.png)

Rappelez-vous que les param√®tres des fonctions sont typ√©s. Si vous essayez de passer un nombre au lieu d‚Äôun texte comme `name`, vous obtiendrez une erreur.

Encore une fois, les types travaillent pour vous. La v√©rification des types sur les param√®tres des fonctions vous √©vitera de nombreuses s√©ances de d√©bogage.

![Une capture d'√©cran montrant VS Code affichant une erreur de type.](/assets/pushing-further/functions/type-error.png)

Tout peut √™tre un param√®tre de fonction : texte, nombres, bool√©ens, objets, ou m√™me d'autres fonctions !

Vous pouvez √©galement avoir plusieurs param√®tres entre les `()` de la fonction, s√©par√©s par une virgule.

Par exemple, ici, nous ajoutons un nouveau param√®tre `isTired`, qui doit √™tre un bool√©en. Lorsque `isTired` est `true`, nous ajoutons `"You look tired..."`. S‚Äôil est `false`, nous ajoutons `"You look great!"`.

```ts showLineNumbers filename="main.ts"
function sayHello(name: string, isTired: boolean) {
  if (isTired) {
    console.log(`Hello, ${name}! You look tired...`);
  } else {
    console.log(`Hello, ${name}! You look great!`);
  }
}

sayHello("Nael", true);
sayHello("Emily", false);
```
![Une capture d'√©cran montrant VS Code affichant une fonction avec plusieurs param√®tres.](/assets/pushing-further/functions/multiple-parameters.png)

## Retourner une valeur

Si vous survolez la fonction (ou commencez √† la taper), vous verrez la **signature de la fonction**, qui indique les types de ses param√®tres et ce qu‚Äôelle retourne.

Elle affiche `function sayHello(name: string, isTired: boolean): void`. Le `: void` √† la fin indique que la fonction ne retourne rien, ce qui est logique car, pour l‚Äôinstant, nous nous contentons d‚Äôafficher des informations dans le terminal.

![Une capture d'√©cran montrant VS Code affichant une signature de fonction.](/assets/pushing-further/functions/function-signature.png)

Cependant, dans de nombreux cas, vous voudrez qu'une fonction retourne quelque chose.

Par exemple, disons que vous √™tes Canadien et que vous voulez visiter la Tour Eiffel. Vous pourriez cr√©er une fonction pour convertir les dollars canadiens en euros. Au moment d'√©crire ces lignes (2025-01-22), le taux de conversion est de 0,67.

```ts showLineNumbers filename="main.ts"
function convertDollarsToEuros(dollars: number) {
  return dollars * 0.67;
}

convertDollarsToEuros(100);
```

Ici, la fonction utilise le mot-cl√© `return`. Si vous survolez la fonction, vous verrez `: number` √† la fin, ce qui signifie que cette fonction retourne un nombre.

![Une capture d'√©cran montrant VS Code affichant une fonction retournant un nombre.](/assets/pushing-further/functions/return-number.png)

Mais si vous ex√©cutez le code, il semble que rien ne se passe !

En fait, les calculs sont effectu√©s et retourn√©s, mais retourn√©s dans le vide ! Vous devez stocker le r√©sultat quelque part ou l‚Äôafficher directement.

Cr√©ons une variable `euros` pour stocker la valeur retourn√©e de `convertDollarsToEuros(dollars)` et affichons un message appropri√©.

```ts showLineNumbers filename="main.ts"
function convertDollarsToEuros(dollars: number) {
  return dollars * 0.67;
}

const dollars = 100;
const euros = convertDollarsToEuros(dollars);

console.log(`${dollars} Canadian dollars is ${euros} euros`);
```

![Une capture d'√©cran montrant VS Code affichant combien de dollars valent en euros.](/assets/pushing-further/functions/proper-message.png)

Comme pour les param√®tres, les valeurs retourn√©es peuvent √™tre de n‚Äôimporte quel type : texte, nombres, bool√©ens, objets ou m√™me fonctions.

Parce que les fonctions sont typ√©es, les variables qui stockent leurs valeurs retourn√©es sont automatiquement typ√©es √©galement.

Si vous survolez `euros`, vous verrez que son type est `number` parce que la valeur retourn√©e par `convertDollarsToEuros` est un `number`. Lorsque vous travaillez sur des algorithmes plus complexes avec de nombreuses fonctions, cette inf√©rence de type semble magique et vous aide √† garder le cap.

![Une capture d'√©cran montrant VS Code affichant le type d‚Äôune variable.](/assets/pushing-further/functions/euros-type.png)

## Exporter et importer

Puisque `main.ts` est notre point d'entr√©e principal pour le code, nous essayons de le garder simple et clair. L‚Äôencombrer avec des d√©clarations de fonctions n‚Äôest pas optimal.

En g√©n√©ral, nous mettons les fonctions dans leurs propres fichiers. Cela rend le d√©bogage plus facile et rend √©galement les fonctions r√©utilisables, car vous pouvez les `importer` dans d‚Äôautres fichiers.

Nous regroupons souvent ces fonctions dans un dossier appel√© `helpers`.

Dans votre r√©pertoire actuel :
  1) Cr√©ez un nouveau dossier nomm√© `helpers`.
  2) Cr√©ez un nouveau fichier nomm√© `convertDollarsToEuros.ts` dans `helpers`.
  3) Coupez et collez la d√©claration de la fonction `convertDollarsToEuros` dans ce fichier.

Rien ne fonctionnera pour le moment. C'est normal. Vous pouvez cliquer sur l‚Äôimage ci-dessous pour l‚Äôagrandir si n√©cessaire.

![Une capture d'√©cran montrant VS Code affichant deux fichiers TypeScript.](/assets/pushing-further/functions/new-file.png)

<Callout type="info" emoji="üí°">
    Dans VS Code, les fichiers s‚Äôouvrent sous forme d‚Äôonglets. Par d√©faut, un seul onglet est affich√©. Si vous voulez voir plusieurs onglets c√¥te √† c√¥te, faites un clic droit sur un onglet, puis cliquez sur `Split up`, `Split down`, `Split left` ou `Split right`. Dans la capture d‚Äô√©cran ci-dessous, j‚Äôai choisi `Split right`.
</Callout>

Maintenant, la fonction `convertDollarsToEuros` est dans un fichier s√©par√©, mais elle ne peut pas encore √™tre utilis√©e ailleurs. Il y a un avertissement jaune √† ce sujet.

Nous devons la rendre disponible en l‚Äô**exportant**.

Mettez √† jour votre code dans `convertDollarsToEuros.ts` en ajoutant les mots-cl√©s `export default` √† la ligne 1.

```ts showLineNumbers filename="convertDollarsToEuros.ts" /export default/
export default function convertDollarsToEuros(dollars: number) {
  return dollars * 0.67;
}
```

Maintenant que `convertDollarsToEuros` est export√©e, nous pouvons l'importer o√π nous voulons !

Dans notre cas, nous voulons l‚Äôutiliser dans `main.ts`. Pour ce faire, ajoutez la ligne suivante au d√©but du fichier :  `import convertDollarsToEuros from "./helpers/convertDollarsToEuros.ts";`.

IntelliSense reconna√Æt que la fonction est disponible. Si vous commencez √† taper, il vous la sugg√©rera. Pratique, non ? Appuyez sur `Entr√©e` pour accepter la suggestion.

Si vous √™tes sur un PC sous Windows, vous pourriez voir `\` au lieu de `/` dans le chemin d'acc√®s du fichier.

![Une capture d'√©cran montrant la suggestion d'importation dans VS Code.](/assets/pushing-further/functions/intellisense.png)

Voici le code que vous devriez avoir dans `main.ts` :

```ts showLineNumbers filename="main.ts"
import convertDollarsToEuros from "./helpers/convertDollarsToEuros.ts";

const dollars = 100;
const euros = convertDollarsToEuros(dollars);

console.log(`${dollars} Canadian dollars is ${euros} euros`);
```
<Callout type="info" emoji="üí°">
    Lorsque vous importez un fichier, vous devez indiquer √† votre ordinateur o√π le trouver avec un **chemin d'acc√®s**. Ici, `./helpers/convertDollarsToEuros.ts` est un **chemin d'acc√®s relatif** car il commence par `./`. Le `.` indique √† l‚Äôordinateur de commencer l√† o√π le fichier se trouve. Dans ce cas, puisque nous sommes dans `main.ts`, il commence dans le dossier o√π se trouve `main.ts`. Ensuite, `/helpers` indique √† l‚Äôordinateur d‚Äôaller dans le dossier `helpers`. Enfin, `/convertDollarsToEuros.ts` lui indique d‚Äôimporter le contenu de ce fichier. Sur un PC sous Windows, le chemin d'acc√®s peut utiliser `\` au lieu de `/`.
</Callout>

Et maintenant, tout fonctionne ! Si nous avions plusieurs fichiers o√π `convertDollarsToEuros` √©tait n√©cessaire, nous pourrions facilement importer la fonction et la r√©utiliser √† plusieurs endroits !

![Une capture d'√©cran montrant VS Code important et utilisant une fonction TypeScript.](/assets/pushing-further/functions/intellisense.png)

De plus, comme nous surveillons `main.ts` avec la commande `deno run --watch --check`, nous surveillons automatiquement toutes les d√©pendances de `main.ts`. Cela signifie que si vous mettez √† jour `convertDollarsToEuros.ts` et le sauvegardez, le terminal sera nettoy√© et le script sera r√©ex√©cut√©. Tellement pratique !

Changez `0.67` en `0.65` pour voir cela en action. Notez sur la premi√®re ligne du terminal quel fichier modifi√© a √©t√© d√©tect√© par le `Watcher`.

![Une capture d'√©cran montrant Deno d√©tectant un changement de fichier.](/assets/pushing-further/functions/file-change.png)
<Callout type="info" emoji="üí°">
    Vous pourriez penser que cr√©er plusieurs fichiers rend votre code plus difficile √† naviguer. Mais si vous appuyez sur `CMD` sur Mac ou `CTRL` sur PC et cliquez sur une fonction dans votre code, VS Code vous am√®nera automatiquement au fichier de la fonction en ouvrant un nouvel onglet.
</Callout>

## Documentation

Documenter vos fonctions est essentiel si vous voulez les r√©utiliser √† l‚Äôavenir. Les commentaires peuvent faire un bon travail, mais il existe quelque chose d‚Äôencore plus pratique : **JSDoc**.

Pour cr√©er une documentation avec la syntaxe JSDoc, vous devez utiliser `/**` au d√©but de la documentation et `*/` √† la fin. Chaque ligne doit commencer par un `*`. Et voil√† !

Voici une documentation de base ajout√©e au d√©but de `convertDollarsToEuros.ts`. Nous avons une description simple au d√©part, suivie d‚Äôune description du param√®tre `dollars`, et enfin d‚Äôune description de la valeur retourn√©e.

```ts showLineNumbers filename="convertDollarsToEuros.ts" {1-6}
/**
 * Converts an amount in Canadian dollars to euros.
 *
 * @param dollars - The amount in dollars to be converted.
 * @returns The equivalent amount in euros.
 */
export default function convertDollarsToEuros(dollars: number) {
  return dollars * 0.65;
}
```

La raison pour laquelle JSDoc est si pratique est que VS Code (et de nombreux autres outils) le comprend. Si vous survolez la fonction dans `main.ts` maintenant, vous verrez non seulement les types, mais aussi votre documentation qui s‚Äôaffiche !

![Une capture d'√©cran montrant VS Code affichant la documentation JSDoc pour une fonction.](/assets/pushing-further/functions/documentation.png)

Nous pouvons am√©liorer notre documentation en ajoutant un exemple.

Pour que VS Code reconnaissent l'exemple comme du code, nous utilisons un **bloc de code d√©limit√©** avec trois backticks `` ``` ``. Lors de l'ouverture du bloc, nous sp√©cifions √©galement `ts` pour que VS Code sache qu'il s'agit de TypeScript et applique la coloration syntaxique appropri√©e.

```ts showLineNumbers filename="convertDollarsToEuros.ts" {4-9}
/**
 * Converts an amount in Canadian dollars to euros.
 *
 * @example
 * ```ts
 * const dollars = 100;
 * const euros = convertDollarsToEuros(dollars);
 * console.log(euros); // 65
 * ```
 *
 * @param dollars - The amount in dollars to be converted.
 * @returns The equivalent amount in euros.
 */
export default function convertDollarsToEuros(dollars: number): number {
  return dollars * 0.65;
}
```

![Une capture d'√©cran montrant VS Code affichant JSDoc avec un exemple pour une fonction.](/assets/pushing-further/functions/documentation-example.png)

## Fonctions fl√©ch√©es

Parfois, vous avez juste besoin d‚Äôune fonction simple, surtout lorsque vous passez des fonctions en tant que param√®tres dans des m√©thodes comme celles pour les listes.

Les fonctions fl√©ch√©es (*arrow functions*) offrent une mani√®re plus courte d‚Äô√©crire des fonctions.

Par exemple, voici une fonction classique qui affiche du texte dans le terminal.

```ts showLineNumbers
function sayHello(name: string) {
  console.log(`Hello, ${name}!`);
}

sayHello("Nael") // "Hello, Nael!"
```

Elle pourrait √™tre r√©√©crite comme une fonction fl√©ch√©e comme ceci. Elle est appel√©e fonction fl√©ch√©e parce que le `=>` ressemble √† une fl√®che.

```ts showLineNumbers
const sayHello = (name: string) => console.log(`Hello, ${name}!`);

sayHello("Nael") // "Hello, Nael!"
```

Dans l'exemple ci-dessus, il n'y a pas de b√©n√©fice significatif √† utiliser une fonction fl√©ch√©e. Cependant, lorsque vous travaillez avec des m√©thodes de listes, les fonctions fl√©ch√©es peuvent simplifier et rendre votre code plus lisible.

Dans le code ci-dessous, nous avons une liste de nombres que nous voulons filtrer, en gardant uniquement les nombres positifs. La m√©thode `.filter()` n√©cessite une fonction en tant que param√®tre, nous d√©clarons donc la fonction `isPositive` et la passons √† `.filter()`.

Voici √† quoi cela ressemble avec une fonction classique.

```ts showLineNumbers
const numbers = [-2, -1, 0, 1, 2];

function isPositive(num: number) {
  return num > 0;
}

const positiveNumbers = numbers.filter(isPositive);

console.log(positiveNumbers); // [1, 2]
```

Mais nous pourrions simplifier tout cela en utilisant une fonction fl√©ch√©e directement √† l'int√©rieur des parenth√®ses de `.filter()`.

```ts showLineNumbers /(num) => num > 0/
const numbers = [-2, -1, 0, 1, 2];

const positiveNumbers = numbers.filter((num) => num > 0);

console.log(positiveNumbers); // [1, 2]
```

Comme le type de `numbers` est inf√©r√© comme un `number[]`, votre ordinateur en d√©duit que le param√®tre de la fonction fl√©ch√©e `num` ne peut √™tre qu‚Äôun `number`. C‚Äôest tr√®s pratique.

Avec la fonction classique, vous deviez taper explicitement `num: number` car votre ordinateur n‚Äôavait aucun moyen de savoir avec certitude ce que `num` √©tait cens√© √™tre.

## Conclusion

Les fonctions sont une partie fondamentale de la programmation. Elles vous aident √† organiser votre code, √† le rendre r√©utilisable et √† le garder propre.

Si vous voulez approfondir vos connaissances sur les fonctions, consultez la [le√ßon sur la refactorisation](/ninja-moves/refactoring) dans la section *Techniques de ninja* ü•∑.

<NoticeEnd lang="fr"/>