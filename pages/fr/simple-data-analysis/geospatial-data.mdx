---
title: Comment analyser des donn√©es g√©ospatiales avec la biblioth√®que simple-data-analysis
description: Dans cette le√ßon, nous apprenons √† ouvrir, traiter, joindre et visualiser des donn√©es g√©ospatiales.
---

import { Callout } from 'nextra/components'
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Analyse g√©ospatiale avec la biblioth√®que simple-data-analysis

Dans cette le√ßon, nous allons apprendre √† utiliser la biblioth√®que en code ouvert que j‚Äôai cr√©√©e : [simple-data-analysis](https://github.com/nshiab/simple-data-analysis). Cette biblioth√®que permet de travailler √† la fois avec des donn√©es tabulaires et g√©ospatiales. Ici, nous allons analyser des feux de for√™t au Canada afin de r√©pondre √† la question suivante :

- Quelle superficie les feux de for√™t ont-ils br√ªl√©e dans chaque province canadienne en 2023 ?

Pour cela, nous allons convertir un fichier CSV contenant la latitude et la longitude des feux en g√©om√©tries, ouvrir un fichier GeoJSON contenant les fronti√®res provinciales et effectuer une jointure spatiale pour d√©terminer dans quelle province chaque feu s'est produit.

Si vous avez un moment, n‚Äôh√©sitez pas √† ajouter un ‚≠ê √† la [page GitHub](https://github.com/nshiab/simple-data-analysis) de la biblioth√®que. C‚Äôest toujours agr√©able de savoir que son travail en code ouvert est appr√©ci√©. üòä

Notez que vous devriez d√©j√† avoir compl√©t√© les sections **Premiers pas üßë‚Äçüéì** et **Aller plus loin üöÄ**, ainsi que la le√ßon pr√©c√©dente sur **[Les donn√©es tabulaires](/simple-data-analysis/tabular-data)** de cette section.

<NoticeIntro lang="fr" />

## Configuration

Comme dans la le√ßon pr√©c√©dente, cr√©ez un nouveau dossier sur votre ordinateur, ouvrez-le avec VS Code et ex√©cutez la commande suivante dans le terminal : `deno -A jsr:@nshiab/setup-sda`

Apr√®s avoir ex√©cut√© cette commande, votre terminal affichera une description des fichiers cr√©√©s et des biblioth√®ques install√©es.

Ensuite, ex√©cutez la t√¢che sugg√©r√©e pour lancer et surveiller `sda/main.ts` : `deno task sda`

![Une capture d'√©cran montrant VS Code apr√®s l'ex√©cution de setup-sda.](/assets/simple-data-analysis/geospatial-data/setup.png)

## T√©l√©chargement et mise en cache des donn√©es

### Feux de for√™t

Commen√ßons par r√©cup√©rer les donn√©es des feux de for√™t canadiens de 2023. üî• J‚Äôai t√©l√©vers√© l‚Äôensemble des donn√©es sur [GitHub](https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv). Ce fichier CSV provient de Ressources naturelles Canada.

Tout d‚Äôabord, nous cr√©ons une nouvelle table et utilisons la m√©thode `loadData` pour charger les donn√©es. Ensuite, nous utilisons `logTable` pour les afficher dans le terminal.


```ts showLineNumbers filename="main.ts" {5-9}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.loadData(
  "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
);
await fires.logTable();

await sdb.done();
```
![Une capture d'√©cran montrant les donn√©es des feux de for√™t canadiens de 2023 dans le terminal VS Code.](/assets/simple-data-analysis/geospatial-data/log-fires.png)

Comme nous pouvons le voir, il y a environ 7 000 feux de for√™t. Les valeurs de latitude et de longitude sont stock√©es dans deux colonnes distinctes. Pour les convertir en g√©om√©tries nous permettant d‚Äôutiliser des m√©thodes g√©ospatiales, nous pouvons utiliser la m√©thode `points`.

Cette m√©thode requiert trois arguments : le nom de la colonne contenant la latitude, le nom de la colonne contenant la longitude et le nom de la nouvelle colonne o√π seront stock√©es les g√©om√©tries, que j‚Äôappelle g√©n√©ralement `geom`.


```ts showLineNumbers filename="main.ts" {9}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.loadData(
  "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
);
await fires.points("lat", "lon", "geom");
await fires.logTable();

await sdb.done();
```
![Une capture d'√©cran montrant les feux de for√™t canadiens de 2023 sous forme de g√©om√©tries ponctuelles.](/assets/simple-data-analysis/geospatial-data/log-fires-points.png)

Les donn√©es semblent bonnes. Nous pouvons mettre les donn√©es en cache pour √©viter de les r√©cup√©rer √† chaque ex√©cution. Cela acc√©l√©rera √©galement le tout.

L‚Äôoption `cacheVerbose` permet √† SDA d‚Äôafficher des informations suppl√©mentaires dans le terminal concernant la mise en cache, notamment le temps √©conomis√© gr√¢ce √† son utilisation.

La premi√®re fois que vous ex√©cutez ce code, les donn√©es seront r√©cup√©r√©es et stock√©es dans un nouveau dossier appel√© `.sda-cache` dans votre projet. Lors des ex√©cutions suivantes, SDA utilisera les donn√©es mises en cache au lieu de les r√©cup√©rer √† nouveau, ce qui permet d‚Äô√©conomiser des ressources et d‚Äôacc√©l√©rer l‚Äôacc√®s aux donn√©es !

```ts showLineNumbers filename="main.ts" {6, 11} /{ cacheVerbose: true }/
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

await sdb.done();
```
![A screenshot showing the 2023 Canadian wildfires being cached.](/assets/simple-data-analysis/geospatial-data/fires-cache.png)

### Provinces

Nous allons maintenant nous concentrer sur la r√©cup√©ration des fronti√®res des provinces canadiennes. J‚Äôai t√©l√©vers√© un fichier GeoJSON sur [GitHub](https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json).

GeoJSON est un format largement utilis√© pour les donn√©es g√©ospatiales. Il est pratique car il s'agit simplement d'un fichier JSON (facile √† utiliser en TypeScript) structur√© d‚Äôune mani√®re sp√©cifique. Il consiste g√©n√©ralement en un objet contenant un tableau de `features`. Chaque entit√© poss√®de une g√©om√©trie (qui contient des coordonn√©es en latitude et longitude ou √©quivalentes) et des propri√©t√©s (qui stockent des m√©tadonn√©es).

Par exemple, le fichier GeoJSON des provinces canadiennes est structur√© comme ci-dessous, chaque province √©tant repr√©sent√©e par un objet `feature`. Le champ `geometry` contient les fronti√®res de la province sous forme de `coordinates`, et le champ `properties` inclut des m√©tadonn√©es telles que le nom de la province en fran√ßais et en anglais (puisque le Canada est bilingue üá®üá¶).

Il existe diff√©rents types de g√©om√©tries en GeoJSON, comme `Point`, `Polygon` et `MultiPolygon`, comme on peut le voir dans cet ensemble de donn√©es.

```json
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "MultiPolygon",
        "coordinates": [
          [
            [
              [-55.424, 51.585],
              [-55.909, 51.629],
              ... // More coordinates
            ]
          ]
        ]
      },
      "properties": {
        "nameEnglish": "Newfoundland and Labrador",
        "nameFrench": "Terre-Neuve-et-Labrador"
      }
    },
    ... // More features
  ]
}
```

Heureusement, nous n'avons pas √† manipuler ce genre d'objects avec SDA. La biblioth√®que va convertir tout cela en une table de donn√©es facile √† exploiter ! üòÖ

Pour r√©cup√©rer le fichier CSV des feux de for√™t, nous avons utilis√© `loadData`, mais comme les donn√©es des provinces sont dans un format g√©ospatial, nous allons utiliser `loadGeoData` √† la place. D‚Äôailleurs, cette m√©thode peut charger tous types de formats g√©ospatiaux, pas seulement les GeoJSON. ü§ì

```ts showLineNumbers filename="main.ts" {14-18}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.loadGeoData(
  "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
);
await provinces.logTable();

await sdb.done();
```
![Une capture d'√©cran montrant les donn√©es des provinces canadiennes dans le terminal VS Code.](/assets/simple-data-analysis/geospatial-data/log-provinces.png)

Comme on peut le voir dans la capture d‚Äô√©cran ci-dessus, chaque entit√© GeoJSON a √©t√© transform√©e en une ligne dans la table. Les coordonn√©es des `geometry` sont stock√©es par d√©faut dans la colonne `geom`, et toutes les propri√©t√©s ont √©t√© restructur√©es sous forme de colonnes. Tr√®s pratique !

Les donn√©es n‚Äôont pas besoin d‚Äô√™tre transform√©es, donc mettons-les en cache aussi !


```ts showLineNumbers filename="main.ts" {15, 19}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

await sdb.done();
```

L'utilisation du cache rend le code 11 fois plus rapide sur ma machine ! Et je suis s√ªr que cela acc√©l√®re aussi les choses de votre c√¥t√©. üòÅ

![Une capture d'√©cran montrant le r√©sultat de la mise en cache des limites des provinces canadiennes.](/assets/simple-data-analysis/geospatial-data/provinces-cache.png)

## Jointure spatiale

Maintenant que nous avons nos feux et nos provinces, nous pouvons effectuer une **jointure spatiale**. Nous allons utiliser la m√©thode `joinGeo` pour associer chaque feu √† la province o√π il s'est produit.

Aux lignes 22-24, nous appelons la m√©thode `joinGeo` sur la table `fires`. Nous lui passons les arguments suivants :
- la table `provinces`, afin que chaque feu tente de correspondre √† une province,
- la condition `"inside"` (aussi appel√©e pr√©dicat), pour que chaque feu soit associ√© √† la province dans laquelle il se trouve,
- l‚Äôoption `outputTable`, qui permet de stocker le r√©sultat de la jointure dans une nouvelle table, que nous enregistrons dans la variable `firesInsideProvinces`.

Enfin, nous affichons la nouvelle table `firesInsideProvinces` √† la ligne 25.


```ts showLineNumbers filename="main.ts" {22-25}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.logTable();

await sdb.done();
```
![Une capture d'√©cran montrant le r√©sultat de la jointure entre les feux et les provinces.](/assets/simple-data-analysis/geospatial-data/join.png)

<Callout type="info" emoji="üí°">
    Si la mise en page de la table semble d√©form√©e dans votre terminal, c'est probablement parce que sa largeur d√©passe celle de votre terminal. Faites un clic droit sur le terminal et recherchez l'option `Toggle size with content width`. Il existe aussi un raccourci pratique que j‚Äôutilise tout le temps : `OPTION` + `Z` sur Mac et `ALT` + `Z` sur PC.
</Callout>

Comme vous pouvez le voir, chaque feu est maintenant associ√© √† une province ! Gr√¢ce √† la jointure spatiale, nous savons dans quelle province chaque feu s'est produit.

## Agr√©gation des donn√©es

Nous pouvons maintenant r√©pondre tr√®s facilement √† notre question :

- Quelle superficie les feux de for√™t ont-ils br√ªl√©e dans chaque province canadienne en 2023 ?

Nous utilisons la m√©thode `summarize` sur la table `firesInsideProvinces`.

Nous passons les param√®tres suivants √† la m√©thode :
- La colonne `hectares` en tant que valeurs,
- La colonne `nameEnglish` comme cat√©gorie, afin d‚Äôobtenir des r√©sultats pour chaque province,
- Les fonctions `count` et `sum` pour les valeurs de `hectares`,
- L‚Äôoption `decimals: 0` pour arrondir les valeurs.



```ts showLineNumbers filename="main.ts" {25-30}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.logTable();

await sdb.done();
```
![Une capture d'√©cran montrant le nombre de feux dans chaque province canadienne.](/assets/simple-data-analysis/geospatial-data/summary.png)

Nous avons maintenant le nombre de feux et la superficie totale br√ªl√©e dans chaque province. Bien s√ªr, il s‚Äôagit d‚Äôune approximation‚Äîcertains feux ont peut-√™tre travers√© les fronti√®res provinciales, ce que nous n‚Äôavons pas pris en compte ici.

Si nous avions les p√©rim√®tres des feux sous forme de polygones, nous pourrions r√©aliser une analyse plus pr√©cise en utilisant la m√©thode [`intersection`](https://jsr.io/@nshiab/simple-data-analysis/doc/web/~/SimpleWebTable.prototype.intersection) pour calculer le chevauchement entre chaque feu et chaque province. Peut-√™tre que nous aborderons cela dans une autre le√ßon plus tard !

Pour l‚Äôinstant, rendons nos donn√©es plus lisibles en renommant les colonnes et en triant les lignes.


```ts showLineNumbers filename="main.ts" {31-35}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.renameColumns({
  count: "nbFires",
  sum: "burntArea",
});
await firesInsideProvinces.sort({ burntArea: "desc" });
await firesInsideProvinces.logTable();

await sdb.done();
```
![Une capture d'√©cran montrant les nouveaux noms de colonnes.](/assets/simple-data-analysis/geospatial-data/renamed.png)

## Visualisation des donn√©es

### Dans le terminal

Nous pouvons repr√©senter notre table finale sous forme de diagramme √† barres directement dans le terminal en utilisant la m√©thode `logBarChart`.


```ts showLineNumbers filename="main.ts" {38}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.renameColumns({
  count: "nbFires",
  sum: "burntArea",
});
await firesInsideProvinces.sort({ burntArea: "desc" });
await firesInsideProvinces.logTable();

await firesInsideProvinces.logBarChart("nameEnglish", "burntArea");

await sdb.done();
```
![Une capture d'√©cran montrant un diagramme √† barres dans le terminal.](/assets/simple-data-analysis/geospatial-data/bar-chart.png)

### Enregistrement d'un graphique

Nous pouvons √©galement enregistrer un graphique en utilisant [Plot](https://github.com/observablehq/plot), qui a √©t√© pr√©install√© lors de la configuration avec `setup-sda`.

Ne vous inqui√©tez pas pour la syntaxe pour l‚Äôinstant. Nous aborderons Plot en d√©tail dans une le√ßon future.

```ts showLineNumbers filename="main.ts" {2, 39-55}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { barX, plot } from "@observablehq/plot";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.renameColumns({
  count: "nbFires",
  sum: "burntArea",
});
await firesInsideProvinces.sort({ burntArea: "desc" });
await firesInsideProvinces.logTable();

const chart = (data: unknown[]) =>
  plot({
    marginLeft: 170,
    grid: true,
    x: { tickFormat: (d) => `${d / 1_000_000}M`, label: "Burnt area (ha)" },
    y: { label: null },
    color: { scheme: "Reds" },
    marks: [
      barX(data, {
        x: "burntArea",
        y: "nameEnglish",
        fill: "burntArea",
        sort: { y: "-x" },
      }),
    ],
  });
await firesInsideProvinces.writeChart(chart, "./sda/output/chart.png");

await sdb.done();
```

Vous pouvez cliquer sur la capture d'√©cran ci-dessous pour zoomer.

![Une capture d'√©cran montrant un diagramme √† barres avec Plot.](/assets/simple-data-analysis/geospatial-data/plot-chart.png)

### Enregistrement d'une carte

Puisqu'il s'agit de donn√©es g√©ospatiales, cr√©ons une carte, encore une fois avec Plot.

Le code ci-dessous g√©n√®re une carte affichant les limites des provinces ainsi que les feux de for√™t. La taille des marqueurs de feu d√©pend de la superficie br√ªl√©e, et leur couleur correspond √† leur cause.

Une astuce utile consiste √† regrouper toutes les donn√©es g√©ospatiales que nous souhaitons cartographier dans une seule table, ce qui est fait √† la ligne 42 ci-dessous.

Encore une fois, ne vous inqui√©tez pas pour la syntaxe. Nous l‚Äôexpliquerons en d√©tail dans une le√ßon d√©di√©e √† Plot.


```ts showLineNumbers filename="main.ts" {2, 39-84}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.renameColumns({
  count: "nbFires",
  sum: "burntArea",
});
await firesInsideProvinces.sort({ burntArea: "desc" });
await firesInsideProvinces.logTable();

const provincesAndFires = await provinces.cloneTable({
  outputTable: "firesAndProvinces",
});
await provincesAndFires.insertTables(fires, { unifyColumns: true });
await provincesAndFires.addColumn("isFire", "boolean", `hectares > 0`);
await provincesAndFires.replace("cause", {
  "H": "Human",
  "N": "Natural",
  "U": "Unknown",
});
const makeMap = (geoData: {
  features: {
    properties: { [key: string]: unknown };
  }[];
}) => {
  const fires = geoData.features.filter((d) => d.properties.isFire);
  const provinces = geoData.features.filter((d) => !d.properties.isFire);

  return plot({
    projection: {
      type: "conic-conformal",
      rotate: [100, -60],
      domain: geoData,
    },
    color: {
      legend: true,
    },
    r: { range: [0.5, 25] },
    marks: [
      geo(provinces, {
        stroke: "lightgray",
        fill: "whitesmoke",
      }),
      geo(fires, {
        r: "hectares",
        fill: "cause",
        fillOpacity: 0.25,
        stroke: "cause",
        strokeOpacity: 0.5,
      }),
    ],
  });
};
await provincesAndFires.writeMap(makeMap, "./sda/output/map.png", {
  rewind: true,
});

await sdb.done();
```

Vous pouvez cliquer sur la capture d'√©cran ci-dessous pour zoomer.

![Une capture d'√©cran montrant une carte g√©n√©r√©e avec Plot.](/assets/simple-data-analysis/geospatial-data/make-map.png)

Voici la carte que nous avons cr√©√©e ci-dessus. Plut√¥t magnifique. üòç

![Une carte cr√©√©e avec simple-data-analysis et Plot.](/assets/simple-data-analysis/geospatial-data/fires-map.png)

## Exportation des donn√©es

### Donn√©es tabulaires

Si vous souhaitez enregistrer une table, vous pouvez utiliser la m√©thode `writeData`. Cela vous permet d'exporter les donn√©es au format CSV, JSON ou Parquet.


```ts showLineNumbers filename="main.ts" {38}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.renameColumns({
  count: "nbFires",
  sum: "burntArea",
});
await firesInsideProvinces.sort({ burntArea: "desc" });
await firesInsideProvinces.logTable();

await firesInsideProvinces.writeData("./sda/output/firesInsideProvinces.csv");

await sdb.done();
```
![Une capture d'√©cran montrant un fichier CSV.](/assets/simple-data-analysis/geospatial-data/write.png)

### Donn√©es g√©ospatiales

Si n√©cessaire, nous pouvons √©galement exporter nos tables contenant des g√©om√©tries en utilisant `writeGeoData`. Cela nous permet de les enregistrer au format GeoJSON ou GeoParquet.

```ts showLineNumbers filename="main.ts" {38-39}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB({ cacheVerbose: true });

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/firesCanada2023.csv",
  );
  await fires.points("lat", "lon", "geom");
});
await fires.logTable();

const provinces = sdb.newTable("provinces");
await provinces.cache(async () => {
  await provinces.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
  );
});
await provinces.logTable();

const firesInsideProvinces = await fires.joinGeo(provinces, "inside", {
  outputTable: "firesInsideProvinces",
});
await firesInsideProvinces.summarize({
  values: "hectares",
  categories: "nameEnglish",
  summaries: ["count", "sum"],
  decimals: 0,
});
await firesInsideProvinces.renameColumns({
  count: "nbFires",
  sum: "burntArea",
});
await firesInsideProvinces.sort({ burntArea: "desc" });
await firesInsideProvinces.logTable();

await fires.writeGeoData("./sda/output/fires.geojson");
await provinces.writeGeoData("./sda/output/provinces.geojson");

await sdb.done();
```

Si vous les avez enregistr√©s au format GeoJSON, vous pouvez les visualiser directement dans VS Code apr√®s avoir install√© l'[extension Geo Data Viewer](https://marketplace.visualstudio.com/items?itemName=RandomFractalsInc.geo-data-viewer).

Faites un clic droit sur les fichiers GeoJSON et s√©lectionnez l‚Äôoption `View map`.

![Une capture d'√©cran montrant des fichiers GeoJSON sous forme de cartes interactives dans VS Code.](/assets/simple-data-analysis/geospatial-data/map-viewer.png)

## Conclusion

J'esp√®re que vous avez constat√© √† quel point il est facile de manipuler des donn√©es g√©ospatiales avec SDA. L‚Äôun des objectifs de la biblioth√®que est de simplifier les op√©rations complexes sur les donn√©es et de rendre l‚Äôanalyse g√©ospatiale accessible √† tout le monde. üåç

Que vous travailliez avec des donn√©es tabulaires ou g√©ospatiales, SDA propose des m√©thodes coh√©rentes et intuitives pour vous aider √† accomplir vos t√¢ches efficacement.

Puisque SDA est int√©gr√© avec Plot, vous pouvez √©galement cr√©er d'impressionantes visualisations de donn√©es. Et c‚Äôest justement le sujet de la prochaine le√ßon. √Ä bient√¥t ! üìà

<NoticeEnd lang="fr" />
