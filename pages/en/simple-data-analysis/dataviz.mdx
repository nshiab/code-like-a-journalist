---
title: How to visualize data with TypeScript
description: In this lesson, we learn how to visualize tabular and geospatial data with the simple-data-analysis and Plot libraries.
---

import { Callout } from 'nextra/components'
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Visualizing data with Simple Data Analysis and Plot

Data visualizations help you understand your data and communicate your findings. In this lesson, we'll learn how to visualize SDA tables, from the simple chart in your terminal to the customized data visualization with the amazing Plot library.

I'll assume you already completed the [Tabular data](/simple-data-analysis/tabular-data) and [Geospatial data](/simple-data-analysis/geospatial) lessons.

<NoticeIntro />

## Setup

As we did in the previous lesson, create a new folder on your computer, open it with VS Code, and run the following command in the terminal: `deno -A jsr:@nshiab/setup-sda`

After running this command, your terminal will display a description of the created files and installed libraries.

Next, run the suggested task to start and watch `sda/main.ts`: `deno task sda`

![A screenshot showing VS Code after running setup-sda.](/assets/simple-data-analysis/dataviz/setup.png)

Let's fetch and cache the 2023 Canadian wildfires. The data we are using here is a slightly modified version of the one we used in the previous version. Here, we have dates and only fires with a `hectares` burnt value greater than 0.

```ts showLineNumbers filename="main.ts" {5-11}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});
await fires.logTable();

await sdb.done();
```
![A screenshot showing VS Code with a data table in the terminal.](/assets/simple-data-analysis/dataviz/fetch-fires.png)

Let's say that we would like to visualize how much wildfires have burnt through the year, for each province. We need the cumulative sum of the area burnt.

First, let's sum up our fires per date and province.

```ts showLineNumbers filename="main.ts" {12-17}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.logTable();

await sdb.done();
```
![A screenshot showing VS Code logging data tables.](/assets/simple-data-analysis/dataviz/summary.png)

Now, we can compute the cumulative sum per province with the method `accumulate`. We can also round the values with the `round` method to avoid floating point errors. And let's format the date as labels for easier use later on.

```ts showLineNumbers filename="main.ts" {18-22}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.convert({ startdate: "string" }, { datetimeFormat: "%x" });
await fires.logTable();

await sdb.done();
```
![A screenshot showing a new column cumulativeHectares in a data table.](/assets/simple-data-analysis/dataviz/cumulative.png)

Let's visualize this data now!

## In the terminal

SDA has a some methods to easily log charts in your terminal. It's very nice to quickly have a look at your data.

In the example below, we use the `logDotChart` method with `startdate` column for the x values and the `cumulativeHectares` for the y values. I also added a few options:
- We use the `province` values to create small multiples (one chart per province).
- We make all the charts scales the same, which is conveninent to compare provinces visually
- We format the y labels with the `formatNumber` function from the [journalism](https://github.com/nshiab/journalism) library, which I created and provides general helper functions. It's automatically installed when setuping with `setup-sda`.

```ts showLineNumbers filename="main.ts" {2, 26-33}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { formatNumber } from "@nshiab/journalism/web";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.convert({ startdate: "string" }, { datetimeFormat: "%x" });

await fires.logTable();
await fires.logLineChart(
  "startdate",
  "cumulativeHectares",
  {
    smallMultiples: "province",
    fixedScales: true,
    formatY: (d) => formatNumber(d as number, { decimals: 0, suffix: " ha" }),
});

await sdb.done();
```
![A screenshot showing dot charts in the terminal.](/assets/simple-data-analysis/dataviz/dot-charts.png)

You are not limited to dot charts. You can also use the methods `logLineChart`, `logBarChart` and `logHistogram`.

However, these methods, while very handy, are quite limited.

## With Plot

### Cumulative hectares

[Plot](https://github.com/observablehq/plot) is a fantastic library to create charts. It's based of the very famous [d3](https://github.com/d3/d3) library (and built by the same team, including [Mike Bostock](https://github.com/mbostock) and [Philippe RiviÃ¨re](https://github.com/Fil)). However, it's much easier to use because many things that should be handled manually with d3 (scales, axis, etc.) are done automatically with Plot.

SDA integrates Plot seamlessly and when you set up your project with `setup-sda`, it's automatically installed.

To create a chart and save it to a file (`.jpeg`, `.png`, or `.svg` if you want to rework it in Illustrator), you can use the method `writeChart`.

The `writeChart` method needs to arguments: 
- A function that draws a Plot chart
- A path for the image file that will be saved

Let's create a simple line chart of the area burnet through 2023 per province. Note that I removed the line converting `startdate` to strings, because Plot understands dates and wrangle them.

```ts showLineNumbers filename="main.ts" {2, 25-35}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a line chart saved as png.](/assets/simple-data-analysis/dataviz/draw-chart.png)
<Callout type="info" emoji="ðŸ’¡">
   To open two tabs one on top of the other, do a right click on the tab you want at the bottom and click on `Split down`. In the screenshot above, I toggled the terminal, but even if it's not displayed, it's still running and watching `main.ts`. So anytime I update the chart code, `main.ts` is rerun and the chart updated.
</Callout>

Let me explain what's going on above:
- On line 25-34, I create an arrow function `drawChart`. The function expects an array of `unknown` values, because it doesn't know what's in our table. Actually, our data will be an array of objects, as usual.
- On line 26, I call the function `plot` from Plot. This functions will create a chart. It needs an object with some options.
- On line 27, I add a `marks` key, with an array. It's the most important option. Marks are the shapes you want to show on your chart, based on your data.
- On line 28-32, inside the `marks` array, I call the function `line` to create lines based on our `data`. For the `line` options, I specify the `x` values (`startdate`), the `y` values (`cumulativeHectares`), and the `stroke` color (based on the values in `province`).
- Finally, on line 35, I call the method `writeChart` on the `fires` table. The first argument is our function `drawChart`, which will be automatically fed with the `fires` data. The second argument is where we want the chart to be written, in the `output` folder.

Our chart is quite basic for now and there is some problems, like the y axis. Let's fix it!

```ts showLineNumbers filename="main.ts" {27-33}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    inset: 10,
    y: {
      grid: true,
      label: "Area burned (hectares)",
      ticks: 5,
      tickFormat: (d) => `${d / 1_000_000}M`,
    },
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a chart with a better y axis.](/assets/simple-data-analysis/dataviz/y-axis.png)

This is better! To update the y-axis, you can pass options to a `y` as an object. Here's what we are doing in the code above:
- We add grids, to make the chart more readable.
- We change the label to something more understandable with the unit
- We limit the axis ticks to 5
- We format the ticks labels to show millions hectares instead of just hectares.

I also added an `inset` of `10` to give a little bit more space to the top label.

Now, let's update the `x` label. There is no need for us to update the x tick labels because Plot wrangles dates very well and displays years, months, days and even time depending on the scale values.

We can tweak the colors too by using a different scheme and by adding a legend.

```ts showLineNumbers filename="main.ts" {34-40}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    inset: 10,
    y: {
      grid: true,
      label: "Area burned (hectares)",
      ticks: 5,
      tickFormat: (d) => `${d / 1_000_000}M`,
    },
    x: {
      label: "Date",
    },
    color: {
      legend: true,
      scheme: "Accent",
    },
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a chart with a color legend.](/assets/simple-data-analysis/dataviz/x-colors.png)

Hmmmm... The color legend doesn't work very well with so many categories. We need to change our strategy. Instead of a color legend, maybe we could add a dot and a text label at the end of each line.

Let's remove the color legend and add a first `dot` mark. Since we want to add it at the end of the line, we use the `selectLast` transform. It will select just the last data point.

Note that the order in the `marks` array is important. The marks are drawn in order. So if you want a shape to be on top of another, but it after in the array.

```ts showLineNumbers filename="main.ts" {2, 46-53}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    inset: 10,
    y: {
      grid: true,
      label: "Area burned (hectares)",
      ticks: 5,
      tickFormat: (d) => `${d / 1_000_000}M`,
    },
    x: {
      label: "Date",
    },
    color: {
      scheme: "Accent",
    },
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
      dot(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          fill: "province",
        }),
      ),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a line chart with dots at the end.](/assets/simple-data-analysis/dataviz/dots.png)

And now let's add the text labels. We use `selectLast` again and some more specific options:
- On top of `x` and `y`, we also use `z` to let Plot know that we want a text label for each province.
- We use the values in the `province` column for the text.
- We use a black `fill`, but with a white `stroke` to make the text more readeable when overlapping other chart elements.
- We set the `textAnchor` to start, so the text is aligned with the `dot`, but we shift it by 5 pixels with `dx` so it's not touching the dot.

```ts showLineNumbers filename="main.ts" {2, 54-66}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    inset: 10,
    y: {
      grid: true,
      label: "Area burned (hectares)",
      ticks: 5,
      tickFormat: (d) => `${d / 1_000_000}M`,
    },
    x: {
      label: "Date",
    },
    color: {
      scheme: "Accent",
    },
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
      dot(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          fill: "province",
        }),
      ),
      text(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          z: "province",
          text: "province",
          textAnchor: "start",
          fill: "black",
          stroke: "white",
          dx: 5,
        }),
      ),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a line chart with dots and text labels at the end.](/assets/simple-data-analysis/dataviz/text-labels.png)

This is much better! But our chart need new adjustements now. The margin on the right should be wider. To avoid overlapping labels, we could label only last points that have a `cumulativeHectares` value of 100,000 or more.

```ts showLineNumbers filename="main.ts" {28, 61}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    inset: 10,
    marginRight: 70,
    y: {
      grid: true,
      label: "Area burned (hectares)",
      ticks: 5,
      tickFormat: (d) => `${d / 1_000_000}M`,
    },
    x: {
      label: "Date",
    },
    color: {
      scheme: "Accent",
    },
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
      dot(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          fill: "province",
        }),
      ),
      text(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          z: "province",
          filter: (d) => d.cumulativeHectares > 100_000,
          text: "province",
          textAnchor: "start",
          fill: "black",
          stroke: "white",
          dx: 5,
        }),
      ),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a line chart with a wider margin.](/assets/simple-data-analysis/dataviz/margin-right.png)

We are getting there!

One last thing: it looks like not much is happening before mid-April and after October. We could filter our table to keep only what's in between, and then tweak some options.

```ts showLineNumbers filename="main.ts {23, 29, 40, 62}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

const sdb = new SimpleDB();

const fires = sdb.newTable("fires");
await fires.cache(async () => {
  await fires.loadData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
  );
});

await fires.summarize({
  values: "hectares",
  categories: ["province", "startdate"],
  summaries: "sum",
  decimals: 1,
});
await fires.accumulate("sum", "cumulativeHectares", {
  categories: "province",
});
await fires.round("cumulativeHectares", { decimals: 1 });
await fires.filter(`startDate >= '2023-04-15' && startDate <= '2023-10-01'`);
await fires.logTable();

const drawChart = (data: unknown[]) =>
  plot({
    inset: 10,
    marginRight: 110,
    y: {
      grid: true,
      label: "Area burned (hectares)",
      ticks: 5,
      tickFormat: (d) => `${d / 1_000_000}M`,
    },
    x: {
      label: "Date",
    },
    color: {
      scheme: "tableau10",
    },
    marks: [
      line(data, {
        x: "startdate",
        y: "cumulativeHectares",
        stroke: "province",
      }),
      dot(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          fill: "province",
        }),
      ),
      text(
        data,
        selectLast({
          x: "startdate",
          y: "cumulativeHectares",
          z: "province",
          filter: (d) => d.cumulativeHectares > 400_000,
          text: "province",
          textAnchor: "start",
          fill: "black",
          stroke: "white",
          dx: 5,
        }),
      ),
    ],
  });
await fires.writeChart(drawChart, "./sda/output/chart.png");

await sdb.done();
```
![A screenshot showing a line chart with a focus on April to October.](/assets/simple-data-analysis/dataviz/final-fires-lines.png)

This is very nice!

Of course, it could be improved. For example, one problem is that we summarized the data on the fires start date. So we have some gaps in our dates. This is why we are seeing some dots stopping before the end of the x-axis.

But for this lesson, I think it's good enough! The goal was to show you the different options, step by step. ðŸ˜Š

### Fires beeswarm chart

### Fires map

## Conclusion

<NoticeEnd />
