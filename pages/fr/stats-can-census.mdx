---
title: Exploiter les donn√©es du recensement de Statistique Canada üá®üá¶
description: Apprenez √† traiter et √† visualiser des ensembles de donn√©es massifs de Statistique Canada avec la librairie Simple Data Analysis et TypeScript.
---

import { Callout } from "nextra/components";
import { NoticeIntro, NoticeEnd } from "../../components/Notices.jsx";

# Exploiter les donn√©es du recensement üá®üá¶

Bienvenue dans ce nouveau projet ! Nous allons explorer l'immense quantit√© d'informations provenant du recensement canadien fourni par Statistique Canada ! Pour traiter les donn√©es, nous utiliserons la librairie Simple Data Analysis (SDA), que j'ai cr√©√©e ([donnez-lui une √©toile ‚≠ê](https://github.com/nshiab/simple-data-analysis)).

Pour chaque r√©gion m√©tropolitaine, nous cr√©erons une carte montrant les zones o√π les revenus des m√©nages sont inf√©rieurs ou sup√©rieurs √† la m√©diane. La carte de Montr√©al ci-dessous est un exemple du r√©sultat final que nous allons obtenir ensemble.

![Une carte de Montr√©al.](/assets/stats-can-census/map-Montr√©al.png)

Dans ce projet, je vais vous montrer des techniques avanc√©es pour traiter de grands ensembles de donn√©es avec TypeScript. Les donn√©es du recensement de 2021 p√®sent environ 30 GB, mais vous aurez besoin d'environ 70 GB d'espace libre sur votre disque dur pour ce projet. Il est temps de faire un peu de m√©nage ! üßπ

Si vous √™tes bloqu√© √† un moment donn√©, il peut √™tre utile de revoir les le√ßons pr√©c√©dentes expliquant les bases de SDA :
- [Donn√©es tabulaires](/simple-data-analysis/tabular-data)
- [Donn√©es g√©ospatiales](/simple-data-analysis/geospatial-data)
- [Visualiser des donn√©es](/simple-data-analysis/dataviz)

Nous utiliserons Deno et VS Code. Consultez la le√ßon [Installation](/first-steps/setup) si n√©cessaire.

C'est parti !

<NoticeIntro lang="fr" />

## Quelle est la question ?

Pour ne pas perdre le fil, d√©finissons la question √† laquelle nous essayons de r√©pondre :
- Pour chaque r√©gion m√©tropolitaine canadienne, quelles sont les aires de diffusion dont le revenu des m√©nages est sup√©rieur ou inf√©rieur √† la m√©diane ?

Les r√©gions m√©tropolitaines sont d√©finies ainsi dans le recensement :

> Une r√©gion m√©tropolitaine de recensement (RMR) est form√©e d'une ou de plusieurs municipalit√©s adjacentes centr√©es sur une r√©gion urbaine (appel√©e le noyau). Une RMR doit avoir une population totale d'au moins 100 000 habitants, dont au moins 50 000 vivent dans le noyau.

Voici la d√©finition des aires de diffusion :

> Une aire de diffusion (AD) est une petite unit√© g√©ographique relativement stable avec une population moyenne de 400 √† 700 personnes. C'est la plus petite unit√© g√©ographique pour laquelle toutes les donn√©es de recensement sont diffus√©es. Les AD couvrent tout le territoire canadien.

C'est parti pour le code !

## Configuration

Pour tout configurer, utilisons [setup-sda](https://jsr.io/@nshiab/setup-sda) comme dans les le√ßons pr√©c√©dentes.

Cr√©ez un nouveau dossier, ouvrez-le avec VS Code, et ex√©cutez : `deno -A jsr:@nshiab/setup-sda`

Ensuite, ex√©cutez `deno task sda` pour surveiller `main.ts` et ses d√©pendances.

![Capture d'√©cran de VS Code apr√®s avoir ex√©cut√© setup-sda.](/assets/stats-can-census/setup.png)
<Callout type="info" emoji="üí°">
 Pour que SDA fonctionne correctement, il est recommand√© d'avoir au moins la version 2.1.9 de Deno. Pour v√©rifier votre version, ex√©cutez `deno --version` dans votre terminal. Pour la mettre √† jour, ex√©cutez simplement `deno upgrade`.
</Callout>

## T√©l√©chargement des donn√©es

Pour t√©l√©charger les donn√©es du recensement avec le plus de granularit√© possible, cliquez sur cette [page de Statistique Canada](https://www12.statcan.gc.ca/census-recensement/2021/dp-pd/prof/details/download-telecharger.cfm?Lang=F).

Cliquez sur le premier volet *Fichier de t√©l√©chargement complet* puis sur le bouton *CSV* pour *Canada, provinces, territoires, divisions de recensement (DR), subdivisions de recensement (SDR) et aires de diffusion (AD)*.

Si vous ne le trouvez pas, voici le [lien direct](https://www12.statcan.gc.ca/census-recensement/2021/dp-pd/prof/details/download-telecharger/comp/GetFile.cfm?Lang=F&FILETYPE=CSV&GEONO=006). Cela t√©l√©chargera un fichier zip de 2,25 GB.

![Capture d'√©cran du site de Statistique Canada pour t√©l√©charger les donn√©es du recensement.](/assets/stats-can-census/stats-can-census-download.png)

Parce que nous voulons travailler sur les r√©gions m√©tropolitaines, il serait utile d'avoir les noms des r√©gions pour chaque aire de diffusion.

Le fichier contenant ces informations se trouve [ici](https://www12.statcan.gc.ca/census-recensement/alternative_alternatif.cfm?l=fra&dispext=zip&teng=2021_92-151_X.zip&k=%20%20%20%20%209602&loc=/census-recensement/2021/geo/aip-pia/attribute-attribs/files-fichiers/2021_92-151_X.zip). T√©l√©chargez-le aussi. C'est un autre fichier zip de 9,8 MB.

![Capture d'√©cran du site de Statistique Canada pour t√©l√©charger les noms des r√©gions.](/assets/stats-can-census/stats-can-names-download.png)

Et enfin, comme nous voulons cr√©er une carte, nous avons besoin des fronti√®res g√©ospatiales des aires de diffusion. Vous les trouverez [ici](https://www12.statcan.gc.ca/census-recensement/2021/geo/sip-pis/boundary-limites/index2021-fra.cfm?year=21).

D√©placez tout cela dans le dossier `data` de votre projet et d√©compressez tout sauf les fronti√®res g√©ospatiales dans le fichier `lda_000b21a_e.zip` ! C'est d√©compress√© dans mes captures d'√©cran, mais c'√©tait une erreur ü•≤.

Surprise ! Vous avez maintenant plus de 27 GB de donn√©es √† traiter. üòÖ

![Capture d'√©cran de VS Code avec les donn√©es d√©compress√©es.](/assets/stats-can-census/unzipped.png)

## Les donn√©es du recensement

### Premier essai

En d√©compressant les donn√©es, nous avons obtenu un dossier contenant plusieurs fichiers. Les donn√©es se trouvent dans les fichiers dont le nom contient `_data_`.

Essayons d'ouvrir le premier pour les provinces de l'Atlantique.

```ts showLineNumbers filename="main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const census = sdb.newTable("census");
await census.loadData(
  "sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_Atlantic.csv",
);
await census.logTable()

await sdb.done();
```
Hmmm... Nous avons un probl√®me. Cette erreur signifie que les donn√©es n'utilisent pas l'encodage `UTF-8`, qui est pourtant la norme de nos jours et n√©cessaire pour SDA.

![Capture d'√©cran de VS Code montrant une erreur de codage Unicode invalide.](/assets/stats-can-census/encoding-error.png)

J'ai contact√© Statistique Canada √† ce sujet, et ils m'ont dit qu'ils utilisaient l'encodage [`Windows-1252`](https://fr.wikipedia.org/wiki/Windows-1252). Cela signifie que notre premi√®re √©tape consiste √† r√©encoder les donn√©es...

Et oui, les projets de donn√©es dans la vraie vie sont toujours aussi amusants ! üò¨

### R√©encodage des donn√©es

Comme le r√©encodage de donn√©es est une t√¢che courante, j'ai cr√©√© la fonction [`reencode`](https://jsr.io/@nshiab/journalism/doc/~/reencode) et je l'ai publi√©e dans la librairie *[journalism](https://github.com/nshiab/journalism)*. Lorsque vous configurez votre projet avec `setup-sda`, *journalism* est automatiquement install√©. Cette √©tape sera donc tr√®s facile !

Cr√©ons un nouveau fichier `toUTF8.ts` dans le dossier `helpers` avec le code ci-dessous. Comme nous n'avons besoin de r√©encoder les donn√©es qu'une seule fois, nous n'exportons pas de fonction. C'est simplement un script que nous allons ex√©cuter une seule fois.

En regardant les noms des fichiers, vous remarquerez qu'ils ont tous la m√™me structure, sauf pour la r√©gion. En cr√©ant une liste avec les r√©gions, nous pouvons facilement parcourir tous les fichiers.

La fonction `reencode` n√©cessite quatre arguments :
- le fichier d'entr√©e
- le fichier de sortie, qui ici a le m√™me nom que le fichier original mais avec `_utf8` √† la fin
- l'encodage d'origine
- le nouvel encodage


```ts showLineNumbers filename="toUTF8.ts"
import { reencode } from "@nshiab/journalism";

const regions = [
  "Atlantic",
  "BritishColumbia",
  "Ontario",
  "Prairies",
  "Quebec",
  "Territories",
];

for (const r of regions) {
  console.log(`Processing ${r}`);

  const newFile =
    `sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_${r}_utf8.csv`;
  const originalFile =
    `sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_${r}.csv`;

  await reencode(originalFile, newFile, "windows-1252", "utf-8");

  console.log(`Done with ${r}`);
}
```

Pour ex√©cuter ce script, nous pouvons cr√©er une nouvelle t√¢che `toUTF8` dans notre `deno.json`. Ne vous inqui√©tez pas si vous n'avez pas la m√™me version que moi dans les *imports*. Tout va bien aller ! 

```ts showLineNumbers filename="deno.json" {5}
{
  "tasks": {
    "sda": "deno run --node-modules-dir=auto -A --watch --check sda/main.ts",
    "clean": "rm -rf .sda-cache && rm -rf .tmp",
    "toUTF8": "deno run -A sda/helpers/toUTF8.ts"
  },
  "nodeModulesDir": "auto",
  "imports": {
    "@nshiab/journalism": "jsr:@nshiab/journalism@^1.22.0",
    "@nshiab/simple-data-analysis": "jsr:@nshiab/simple-data-analysis@^4.2.0",
    "@observablehq/plot": "npm:@observablehq/plot@^0.6.17"
  }
}
```

Arr√™tez de surveiller `main.ts` (`CTRL` + `C` dans votre terminal) et ex√©cutons notre nouveau script avec notre nouvelle t√¢che : `deno task toUTF8`

Cela prendra quelques minutes pour r√©encoder tous les fichiers. Voici ce que vous verrez une fois que ce sera termin√©.

![Capture d'√©cran de VS Code montrant les donn√©es r√©encod√©es.](/assets/stats-can-census/re-encoding.png)

De nouveaux fichiers sont apparus avec `_utf8` dans leurs noms ! Et maintenant, votre dossier `data` p√®se... 53 GB. ü§≠

Si vous manquez d'espace de stockage, supprimez les fichiers de donn√©es d'origine. Nous travaillerons d√©sormais avec ceux qui se terminent par `_utf8.csv`. Gardez √©galement les autres fichiers, en particulier `98-401-X2021006_English_meta.txt` !

### R√©essayons

Essayons maintenant de charger et d'afficher le fichier CSV r√©encod√© pour les provinces de l'Atlantique. Mettez √† jour `main.ts` et ex√©cutez `deno task sda` dans votre terminal.


```ts showLineNumbers filename="main.ts" {7}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const census = sdb.newTable("census");
await census.loadData(
  "sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_Atlantic_utf8.csv",
);
await census.logTable();

await sdb.done();
```
![Capture d'√©cran de VS Code montrant les donn√©es des provinces de l'Atlantique.](/assets/stats-can-census/atlantic-data.png)
<Callout type="info" emoji="üí°">
    Si la disposition du tableau s'affiche de mani√®re √©trange dans votre terminal, c'est parce que la largeur du tableau est sup√©rieure √† celle de votre terminal. Faites un clic droit sur le terminal et cherchez `Toggle size with content width`. Il y a aussi un raccourci pratique que j'utilise tout le temps pour cela : `OPTION` + `Z` sur Mac et `ALT` + `Z` sur PC.
</Callout>

√áa fonctionne ! ü•≥

Essayons un autre fichier : celui des Prairies, qui couvre les provinces de l'Alberta, de la Saskatchewan et du Manitoba.

```ts showLineNumbers filename="main.ts" {7}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const census = sdb.newTable("census");
await census.loadData(
  "sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_Prairies_utf8.csv",
);
await census.logTable();

await sdb.done();
```
![Capture d'√©cran de VS Code montrant une erreur due √† un CSV mal format√©.](/assets/stats-can-census/prairies-error.png)

Oh non ! Encore une erreur... Il semble que ce fichier CSV soit mal format√©...

Nous pouvons ajuster les options pour rendre le chargement du CSV moins stricte et voir si cela fonctionne.

```ts showLineNumbers filename="main.ts" {8}
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const census = sdb.newTable("census");
await census.loadData(
  "sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_Prairies_utf8.csv",
  { strict: false },
);
await census.logTable();

await sdb.done();
```
![Capture d'√©cran de VS Code montrant les donn√©es des Prairies.](/assets/stats-can-census/prairies-working.png)

Magnifique ! Tout fonctionne maintenant !

### Charger toutes les donn√©es

Jusqu'√† pr√©sent, nous avons charg√© les donn√©es un fichier √† la fois. Mais vous pouvez √©galement charger tous les fichiers CSV dans une seule table facilement.

Cr√©ons un nouveau fichier `crunchData.ts` pour cela. Cette fonction `async` aura un param√®tre `sdb` et retournera une table `census`.

Lorsque vous avez des fichiers dont les noms suivent le m√™me mod√®le, vous pouvez utiliser des jokers `*`. Dans notre cas, nous voulons charger tous les fichiers CSV se terminant par `_utf8.csv`, donc nous les chargeons tous en utilisant `*_utf8.csv`, comme montr√© √† la ligne 6 ci-dessous.


```ts showLineNumbers filename="crunchData.ts" {6}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv",
  {
    strict: false,
  });

  return census;
}
```

Mettons √† jour `main.ts` pour utiliser cette nouvelle fonction. Nous r√©glons √©galement `cacheVerbose` sur `true` lors de la cr√©ation de notre `SimpleDB`. Cela enregistrera la dur√©e totale et sera utile par la suite lorsque nous utiliserons le cache.

```ts showLineNumbers filename="main.ts" {4-7}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import crunchData from "./helpers/crunchData.ts";

const sdb = new SimpleDB({ cacheVerbose: true });

const census = await crunchData(sdb);
await census.logTable();

await sdb.done();
```

En fonction de la m√©moire RAM disponible sur votre ordinateur, vous pourriez voir un dossier `.tmp` appara√Ætre. Si les donn√©es sont plus volumineuses que votre RAM, ce dossier sera utilis√© pour traiter toutes les donn√©es en y stockant des morceaux pr√©trait√©s.

Ce dossier `.tmp` peut devenir assez volumineux. Sur ma machine, apr√®s la premi√®re ex√©cution, il p√®se environ 16 GB.

<Callout type="info" emoji="üí°">
    Si vous souhaitez nettoyer votre cache, ex√©cutez `deno task clean`. Cela supprimera `.tmp` et `.sda-cache` (nous en reparlerons plus tard). Vous pouvez √©galement les supprimer manuellement, mais n'oubliez pas de vider votre corbeille.
</Callout>

Nous pouvons enfin jeter un ≈ìil aux donn√©es. Avec 166 millions de lignes et 23 colonnes, nous avons environ 3,8 milliards de points de donn√©es. üôÉ

Et charger tout cela a pris moins d'une minute sur mon ordinateur. Pas mal !

![Capture d'√©cran de VS Code montrant toutes les donn√©es charg√©es.](/assets/stats-can-census/loading-all.png)

### Limite et cache

Pour commencer √† travailler sur les donn√©es, nous n'avons pas besoin de tout charger. Nous pouvons utiliser l'option `limit` pour ne charger que le premier million de lignes.

Maintenant, le chargement des donn√©es prend environ une seconde.

```ts showLineNumbers filename="crunchData.ts" {8}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
    strict: false,
    limit: 1_000_000,
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant le premier million de lignes charg√©es.](/assets/stats-can-census/limit.png)

Nous pouvons √©galement utiliser la m√©thode `cache`. Tout ce qui est envelopp√© par cette m√©thode sera ex√©cut√© une seule fois et le r√©sultat sera stock√© dans le dossier `.sda-cache`. Si le code ne change pas dans la m√©thode `cache`, les donn√©es seront charg√©es depuis le cache au lieu de relancer les calculs.

Lors de la premi√®re ex√©cution, cela prend un peu plus de temps car les donn√©es sont √©crites dans le cache.

```ts showLineNumbers filename="crunchData.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant l'√©criture dans le cache.](/assets/stats-can-census/first-run-cache.png)

Mais lors des ex√©cutions suivantes, les donn√©es sont charg√©es depuis le cache, ce qui est beaucoup plus rapide. Sur mon MacBook Pro, c'est 10 fois plus rapide ! üò±

![Capture d'√©cran de VS Code montrant le cache utilis√©.](/assets/stats-can-census/using-cache.png)

### Filtrage

L'une des premi√®res choses √† faire lorsque l'on travaille avec de grands ensembles de donn√©es est de les filtrer pour ne conserver que les informations qui nous int√©ressent.

Notre question est :
- Pour chaque r√©gion m√©tropolitaine canadienne, quelles sont les aires de diffusion dont le revenu des m√©nages est sup√©rieur ou inf√©rieur √† la m√©diane ?

Pour trouver le revenu total des m√©nages, vous pouvez consulter le fichier `98-401-X2021006_English_meta.txt`. Il contient la liste de toutes les variables du recensement.

Le `CHARACTERISTIC_ID` pour le `Median total income of household in 2020 ($)` est `243`.

![Capture d'√©cran de VS Code montrant le code pour la variable du revenu total.](/assets/stats-can-census/income-code.png)

De plus, les fichiers de donn√©es du recensement que nous avons t√©l√©charg√©s contiennent diff√©rents niveaux g√©ographiques, mais nous avons seulement besoin des aires de diffusion.

Enfin, nous n'avons besoin que de trois colonnes :
- `DGUID`, qui contient l'ID g√©ospatial unique des aires de diffusion. Nous l'utiliserons pour trouver les bonnes fronti√®res pour cr√©er une carte.
- `GEO_NAME`, qui contient l'ID de nommage unique des aires de diffusion. Nous l'utiliserons pour r√©cup√©rer les noms des r√©gions m√©tropolitaines. 
- `C1_COUNT_TOTAL`, qui contient les valeurs de la variable. Dans notre cas, il s'agit du revenu total m√©dian dans chaque aire de diffusion. Nous pouvons renommer cette colonne pour avoir quelque chose de plus lisible.

Mettons √† jour `crunchData` pour ne conserver que ce dont nous avons besoin.


```ts showLineNumbers filename="crunchData.ts" {11-20}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant les donn√©es filtr√©es.](/assets/stats-can-census/cleaning-filtering.png)

C'est beaucoup mieux ! Nous pouvons maintenant nous concentrer sur l'ajout des noms des r√©gions m√©tropolitaines.

## Les r√©gions m√©tropolitaines

### Premier essai

Essayons de charger les noms qui se trouvent dans le fichier `2021_92-151_X.csv`. Nous pouvons mettre √† jour `crunchData.ts`. Nous continuons de travailler dans la m√©thode `cache`.


```ts showLineNumbers filename="crunchData.ts" {22-24}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X.csv");
    await names.logTable();
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant un probl√®me d'encodage pour le fichier contenant les noms.](/assets/stats-can-census/names-error.png)

Nous connaissons cette erreur ! C'est encore un probl√®me d'encodage !

### R√©encodage √† nouveau

Mettons √† jour `toUTF8.ts` pour convertir √©galement ce fichier CSV. Nous commentons le code pr√©c√©dent car nous n'avons pas besoin de reconvertir les fichiers du recensement.

```ts showLineNumbers filename="toUTF8.ts" {25-32}
import { reencode } from "@nshiab/journalism";

// const regions = [
//   "Atlantic",
//   "BritishColumbia",
//   "Ontario",
//   "Prairies",
//   "Quebec",
//   "Territories",
// ];

// for (const r of regions) {
//   console.log(`Processing ${r}`);

//   const newFile =
//     `sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_${r}_utf8.csv`;
//   const originalFile =
//     `sda/data/98-401-X2021006_eng_CSV/98-401-X2021006_English_CSV_data_${r}.csv`;

//   await reencode(originalFile, newFile, "windows-1252", "utf-8");

//   console.log(`Done with ${r}`);
// }

console.log(`Processing names data`);
await reencode(
  "sda/data/2021_92-151_X.csv",
  "sda/data/2021_92-151_X_utf8.csv",
  "windows-1252",
  "utf-8",
);
console.log("Done with names data");
```

Arr√™tez de surveiller `main.ts` dans votre terminal (`CTRL` + `C`) et ex√©cutez `deno task toUTF8`.

Maintenant, chargeons notre nouveau fichier `sda/data/2021_92-151_X_utf8.csv` dans `crunchData.ts`.


```ts showLineNumbers filename="crunchData.ts" {23}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv");
    await names.logTable();
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant un probl√®me d'encodage pour le fichier contenant les noms.](/assets/stats-can-census/names-strict.png)

Encore une erreur... Nous devons √† nouveau d√©finir l'option `strict` sur `false`.

```ts showLineNumbers filename="crunchData.ts" {23}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.logTable();
  });

  return census;
}
```

Et maintenant, √ßa fonctionne ! Mais ce fichier contient un impressionnant total de 63 colonnes. üò≥

### Filtrage

Si vous lisez [la documentation](https://www150.statcan.gc.ca/n1/pub/92-151-g/2021001/tbl/tbl4_1-fra.htm) (et que vous connaissez bien votre recensement ü•∏), vous r√©aliserez que vous n'avez besoin que de deux colonnes, apr√®s avoir filtr√© `CMATYPE_RMRGENRE` pour le type `B` afin de ne conserver que les r√©gions m√©tropolitaines.

Comme le fichier contient des donn√©es pour diff√©rents niveaux g√©ographiques, nous supprimons les doublons cr√©√©s en s√©lectionnant seulement deux colonnes. Et puisque le but est d'ajouter les noms des r√©gions m√©tropolitaines √† notre table `census`, nous renommons la colonne `DADGUID_ADIDUGD` en `DGUID` pour joindre facilement les deux tables. Nous renommons √©galement `CMANAME_RMRNOM` en `CMA` par souci de commodit√©.

Voici une version mise √† jour de `crunchData.ts`.


```ts showLineNumbers filename="crunchData.ts" {24-33}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant la table du recensement avec les noms des CMA.](/assets/stats-can-census/names-joined.png)

Victoire ! Nous avons maintenant le nom de la r√©gion m√©tropolitaine pour chaque aire de diffusion ! ü•≥

## Les fronti√®res des aires de diffusion

### Simplification

Comme nous voulons cr√©er une carte, nous avons besoin des fronti√®res des aires de diffusion. Nous les avons t√©l√©charg√©es pr√©c√©demment sous forme de fichier compress√© `lda_000b21a_e.zip` (et je vous avais dit de ne pas le d√©compresser üò¨).

Statistique Canada fournit des donn√©es g√©ospatiales tr√®s d√©taill√©es. Mais comme nous voulons seulement dessiner des cartes, nous n'avons pas besoin d'un niveau de d√©tail aussi √©lev√©. Une version simplifi√©e suffira et rendra notre code plus rapide.

Un de mes outils pr√©f√©r√©s pour simplifier les donn√©es g√©ospatiales est [mapshaper.org](https://mapshaper.org/). Allez leur donner une ‚≠ê sur [GitHub](https://github.com/mbloch/mapshaper) si vous avez un compte !

Allez sur le site et faites glisser `lda_000b21a_e.zip` sur la page. Notez que vous ne pouvez pas faire glisser le fichier depuis VS Code. Faites-le depuis votre dossier √† l'aide du Finder ou de l'Explorateur de fichiers de votre ordinateur.

Apr√®s quelques secondes, vous verrez toutes les aires de diffusion.

![Capture d'√©cran de mapshaper montrant les aires de diffusion.](/assets/stats-can-census/mapshaper.png)

Vous pouvez maintenant cliquer sur `Simplify` en haut √† droite et s√©lectionner les options suivantes :
- `prevent shape removal`
- `Visvalingam / weighted area`

Cliquez sur `Apply` !

![Capture d'√©cran de mapshaper montrant les aires de diffusion.](/assets/stats-can-census/mapshaper-simplify.png)

Pour l'√©tape suivante, je zoome g√©n√©ralement sur une zone √† haute densit√©, comme Montr√©al. Ensuite, √† l'aide du curseur en haut, je vise un seuil de simplification qui ne modifie pas les formes globales.

Ici, 10% fonctionne plut√¥t bien. Notez que vous pouvez √©galement saisir directement le pourcentage souhait√©.

![Capture d'√©cran de mapshaper montrant les options de simplification.](/assets/stats-can-census/mapshaper-threshold.png)

L'√©tape suivante consiste √† exporter les donn√©es simplifi√©es !

Cliquez sur le bouton `Export` en haut √† droite, conservez le format de fichier original `Shapefile`, puis cliquez sur `Export`.

![Capture d'√©cran de mapshaper montrant comment exporter des calques simplifi√©s.](/assets/stats-can-census/mapshaper-export.png)

Vous pouvez maintenant renommer ce fichier en `lda_000b21a_e_simplified.shp.zip` (remarquez que j'ai ajout√© `.shp.zip` √† l'extension pour aider SDA √† comprendre qu'il s'agit d'un shapefile) et le d√©placer dans votre dossier `data`.

Au lieu de 197 MB, nos donn√©es g√©ospatiales ne p√®sent plus que 27 MB, ce qui acc√©l√©rera nos calculs et le dessin des cartes !

### Chargement des g√©om√©tries

Pour charger les g√©om√©tries, nous pouvons utiliser la m√©thode `loadGeoData`. N'oubliez pas de modifier l'extension du fichier Shapefile simplifi√© en `.shp.zip`. Le `shp` est important pour SDA. Sans cela, SDA ne reconna√Æt pas le fichier en tant que Shapefile et ne peut pas le charger correctement.

Lorsque vous chargez de nouvelles donn√©es g√©ospatiales, il est toujours important de v√©rifier la projection. Ci-dessous, nous utilisons la m√©thode `logProjections` pour cela.


```ts showLineNumbers filename="crunchData.ts" {35-40}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);

    const disseminationAreas = sdb.newTable("disseminationAreas");
    await disseminationAreas.loadGeoData(
      "sda/data/lda_000b21a_e_simplified.shp.zip",
    );
    await disseminationAreas.logProjections()
    await disseminationAreas.logTable();
  });

  return census;
}
```
![Capture d'√©cran de VS Code chargant des donn√©es g√©ospatiales.](/assets/stats-can-census/loadGeoData.png)

Nous n'avons aucun probl√®me √† charger les donn√©es g√©ospatiales. Nous pouvons voir les 57 932 aires de diffusion sous forme de lignes avec leurs propri√©t√©s et leurs g√©om√©tries.

Mais la projection `proj=lcc` avec ses `units=m` pose probl√®me. Statistique Canada utilise la projection conforme conique de Lambert avec des coordonn√©es en m√®tres. Pour que de nombreuses m√©thodes de SDA fonctionnent correctement, nous avons besoin des coordonn√©es avec la projection WGS84 utilisant la latitude et la longitude.

Mais ne vous inqui√©tez pas, SDA g√®re cela pour vous. Il vous suffit de passer l'option `{ toWGS84: true }` pour convertir vos donn√©es g√©ospatiales au bon format.

Pendant qu'on y est, s√©lectionnons uniquement les colonnes qui nous int√©ressent :
- `DGUID`, qui est l'ID unique pour les aires de diffusion. Nous l'utiliserons pour joindre les g√©om√©tries aux donn√©es du recensement.
- `geom`, qui contient les g√©om√©tries.

Et joignons la table `disseminationAreas` √† la table `census` ! Comme nous avons un `DGUID` dans chaque table, SDA l'utilisera pour faire correspondre les donn√©es du recensement des aires de diffusion avec les bonnes fronti√®res.


```ts showLineNumbers filename="crunchData.ts" {38, 40-41}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
      limit: 1_000_000,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);

    const disseminationAreas = sdb.newTable("disseminationAreas");
    await disseminationAreas.loadGeoData(
      "sda/data/lda_000b21a_e_simplified.shp.zip",
      { toWGS84: true },
    );
    await disseminationAreas.selectColumns(["DGUID", "geom"]);
    await census.join(disseminationAreas);
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant les donn√©es compl√®tes des aires de diffusion.](/assets/stats-can-census/all-data.png)

Nos donn√©es sont enfin compl√®tes ! Nous avons nos aires de diffusion avec leur revenu total m√©dian des m√©nages, le nom de leur r√©gion m√©tropolitaine et leurs fronti√®res !

Nous pouvons supprimer l'option `limit` √† la ligne 9 et s√©lectionner uniquement les trois colonnes que nous utiliserons par la suite. Nous pouvons √©galement supprimer les lignes avec des valeurs manquantes.

Traitons toutes les donn√©es maintenant !

```ts showLineNumbers filename="crunchData.ts" {41-42}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);

    const disseminationAreas = sdb.newTable("disseminationAreas");
    await disseminationAreas.loadGeoData(
      "sda/data/lda_000b21a_e_simplified.shp.zip",
      { toWGS84: true },
    );
    await disseminationAreas.selectColumns(["DGUID", "geom"]);
    await census.join(disseminationAreas);
    await census.selectColumns(["medianIncome", "CMA", "geom"]);
    await census.removeMissing();
  });

  return census;
}
```
![Capture d'√©cran de VS Code montrant les donn√©es compl√®tes des aires de diffusion.](/assets/stats-can-census/run-all-cleaning.png)

Nous avons maintenant nos donn√©es pour environ 37 000 aires de diffusion situ√©es dans des r√©gions m√©tropolitaines.

Et comme tout ce code est dans la m√©thode `cache`, il ne s'ex√©cutera qu'une seule fois, ce qui nous permettra de travailler rapidement sur les prochaines √©tapes ! Comme indiqu√© ci-dessus, lors de la premi√®re ex√©cution, le code a mis 1 min 31 s √† s'ex√©cuter sur mon ordinateur. Mais lors de la seconde, il n'a fallu que 97 ms. üòè

![Capture d'√©cran de VS Code montrant les donn√©es compl√®tes charg√©es depuis le cache.](/assets/stats-can-census/run-all-cleaning-cache.png)

La structuration, le formatage, le filtrage et le nettoyage des donn√©es sont souvent les √©tapes les plus longues dans l'analyse et la visualisation de donn√©es. ü´† Mais il est √©galement extr√™mement important de bien les faire pour √©viter les erreurs dans votre analyse et vos visualisations.

Prenez toujours le temps de lire la documentation des donn√©es. Cela peut sembler une perte de temps au d√©but, mais cela vous fera en r√©alit√© gagner beaucoup de temps par la suite. J'ai d√©j√† v√©cu √ßa. Faites-moi confiance. ü´£

## R√©pondre √† la question

### Variation par rapport √† la m√©diane

La question √† laquelle nous voulons r√©pondre est :
- Pour chaque r√©gion m√©tropolitaine canadienne, quelles sont les aires de diffusion dont le revenu des m√©nages est sup√©rieur ou inf√©rieur √† la m√©diane ?

Nous devons donc trouver le revenu total m√©dian des m√©nages pour chaque r√©gion m√©tropolitaine. C'est facile √† faire avec la m√©thode `summarize`.

Notez que nous pouvons maintenant travailler en dehors de la m√©thode `cache`. Les donn√©es √©tant nettoy√©es et filtr√©es, cela devient beaucoup plus l√©ger √† traiter.


```ts showLineNumbers filename="crunchData.ts" {45-51}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);

    const disseminationAreas = sdb.newTable("disseminationAreas");
    await disseminationAreas.loadGeoData(
      "sda/data/lda_000b21a_e_simplified.shp.zip",
      { toWGS84: true },
    );
    await disseminationAreas.selectColumns(["DGUID", "geom"]);
    await census.join(disseminationAreas);
    await census.selectColumns(["medianIncome", "CMA", "geom"]);
    await census.removeMissing();
  });

  const medians = await census.summarize({
    values: "medianIncome",
    categories: "CMA",
    summaries: "median",
    outputTable: "medians",
  });
  await medians.logTable();

  return census;
}
```
![Capture d'√©cran de VS Code montrant le revenu total m√©dian des m√©nages.](/assets/stats-can-census/summarize.png)

Maintenant que nous avons la m√©diane pour chaque CMA dans la table `medians`, nous pouvons joindre la table `medians` √† la table `census`. Comme les deux tables ont la colonne `CMA`, SDA pourra facilement faire correspondre les lignes. Par commodit√©, nous pouvons supprimer la colonne `value` de `medians` avant de faire la jointure.

Nous pouvons maintenant ajouter une nouvelle colonne `varPerc` avec la variation en pourcentage par rapport √† la m√©diane pour chaque aire de diffusion. Nous pouvons √©galement arrondir les valeurs. C'est ce que nous utiliserons pour colorer nos cartes.

```ts showLineNumbers filename="crunchData.ts" {51-59}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);

    const disseminationAreas = sdb.newTable("disseminationAreas");
    await disseminationAreas.loadGeoData(
      "sda/data/lda_000b21a_e_simplified.shp.zip",
      { toWGS84: true },
    );
    await disseminationAreas.selectColumns(["DGUID", "geom"]);
    await census.join(disseminationAreas);
    await census.selectColumns(["medianIncome", "CMA", "geom"]);
    await census.removeMissing();
  });

  const medians = await census.summarize({
    values: "medianIncome",
    categories: "CMA",
    summaries: "median",
    outputTable: "medians",
  });
  await medians.removeColumns("value");

  await census.join(medians);
  await census.addColumn(
    "varPerc",
    "number",
    `(medianIncome - median) / median * 100`,
  );
  await census.round("varPerc");

  return census;
}
```
![Capture d'√©cran de VS Code montrant la variation par rapport au revenu m√©dian dans chaque r√©gion m√©tropolitaine.](/assets/stats-can-census/variation.png)

Nous avons maintenant la r√©ponse √† notre question : la variation par rapport √† la m√©diane dans chaque aire de diffusion pour toutes les r√©gions m√©tropolitaines.

Il est temps de visualiser tout √ßa !

### Cr√©ation des cartes

Pour garder notre code organis√© et pour rester sain d'esprit, cr√©ons un nouveau fichier `visualizeData.ts` dans le dossier `helpers`.

La nouvelle fonction aura besoin de la table `census` et, pour l'instant, elle se contentera de l'afficher dans la console.


```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function visualizeData(census: SimpleTable) {
  await census.logTable();
}
```

Et mettons √† jour `main.ts` pour appeler cette nouvelle fonction.

```ts showLineNumbers filename="main.ts" {8}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import crunchData from "./helpers/crunchData.ts";
import visualizeData from "./helpers/visualizeData.ts";

const sdb = new SimpleDB({ cacheVerbose: true });

const census = await crunchData(sdb);
await visualizeData(census);

await sdb.done();
```

Nous voulons dessiner une carte pour chaque r√©gion m√©tropolitaine, alors commen√ßons par r√©cup√©rer toutes les r√©gions m√©tropolitaines uniques dans nos donn√©es.

Ensuite, nous pouvons les parcourir dans une boucle, cloner la table `census` et ne garder que les lignes correspondant √† la bonne `CMA`.

Comme vous pouvez le voir dans la capture d'√©cran ci-dessous, lorsque vous ne sp√©cifiez pas de nom pour les tables, SDA les nomme automatiquement `table0`, `table1`, etc. Ici, nous voyons que la derni√®re table est `table42`, ce qui signifie que nous parcourons 43 r√©gions m√©tropolitaines.

Pour conna√Ætre le nombre de r√©gions m√©tropolitaines, vous pouvez √©galement v√©rifier la propri√©t√© `.length` de `allCMAs`, puisque `getUniques` renvoie toutes les valeurs uniques d'une colonne sous forme de liste.


```ts showLineNumbers filename="visualizeData.ts" {4-10}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function visualizeData(census: SimpleTable) {
  const allCMAs = await census.getUniques("CMA");

  for (const CMA of allCMAs) {
    const tableCMA = await census.cloneTable();
    await tableCMA.keep({ CMA });
    await tableCMA.logTable();
  }
}
```
![Capture d'√©cran de VS Code apr√®s avoir ex√©cut√© setup-sda.](/assets/stats-can-census/clone.png)
<Callout type="info" emoji="üí°">
 Comme la table `census` poss√®de une colonne `CMA` et que la boucle utilise √©galement la variable `CMA`, nous pouvons √©crire `{ CMA }` comme raccourci pour `{ CMA: CMA }`.
</Callout>

Nous pouvons maintenant cr√©er une fonction pour dessiner nos cartes. Lorsque nous avons tout configur√© avec `setup-sda`, nous avons automatiquement install√© [Plot](https://github.com/observablehq/plot). Cette puissante librairie de visualisation de donn√©es fonctionne tr√®s bien avec SDA et c'est ce que nous allons utiliser pour dessiner nos cartes.

Comme c'est la m√™me fonction pour dessiner toutes les cartes, nous pouvons la cr√©er en dehors de la boucle. Cette fonction attendra les donn√©es au format GeoJSON, avec une liste de *features* contenant des propri√©t√©s. Pour commencer, dessinons les polygones des aires de diffusion avec le marqueur `geo` et colorons le `fill` et le `stroke` avec les valeurs calcul√©es dans la colonne `varPerc`.

Dans la boucle, nous pouvons passer cette fonction √† la m√©thode `writeMap`, qui lui transmettra les donn√©es de la table au format GeoJSON. Nous devons √©galement sp√©cifier l'emplacement o√π nous voulons enregistrer la carte, et nous utilisons le nom de la r√©gion m√©tropolitaine pour cr√©er des fichiers uniques dans le dossier `output`.

Comme nous sommes encore en phase d'exploration pour la cr√©ation des cartes, limitons la boucle pour ne travailler que sur la premi√®re r√©gion m√©tropolitaine pour l'instant. Cela nous permettra d'it√©rer plus rapidement et d'am√©liorer notre visualisation des donn√©es.


```ts showLineNumbers filename="visualizeData.ts" {2, 7-15, 20-21} 
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(census: SimpleTable) {
  const allCMAs = await census.getUniques("CMA");

  function drawMap(
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) {
    return plot({
      marks: [
        geo(data, { fill: "varPerc", stroke: "varPearc" }),
      ],
    });
  }

  for (const CMA of allCMAs) {
    const tableCMA = await census.cloneTable();
    await tableCMA.keep({ CMA });
    await tableCMA.writeMap(drawMap, `./sda/output/${CMA}.png`);
    break;
  }
}
```
![Capture d'√©cran de VS Code montrant une premi√®re it√©ration de la carte.](/assets/stats-can-census/first-map.png)

C'est moche, mais √ßa fonctionne !

Nous pouvons maintenant ajouter un titre, un sous-titre et une l√©gende. Nous pouvons √©galement utiliser une √©chelle divergente pour les couleurs et restreindre le domaine de -100 % √† +100 %. Nous pouvons aussi ajuster la projection. Si vous voulez en savoir plus sur ces personnalisations, consultez la le√ßon [Visualiser des donn√©es](/simple-data-analysis/dataviz).

Une chose que vous vous demandez peut-√™tre est pourquoi nous utilisons `data.features[0].properties.CMA` pour le titre.

Lorsque cette fonction sera ex√©cut√©e, elle ne conna√Ætra pas la variable `CMA`. Nous devons donc r√©cup√©rer le nom de la r√©gion m√©tropolitaine directement √† partir des donn√©es. Comme nous utilisons `writeMap`, SDA transmet les donn√©es sous forme de GeoJSON √† cette fonction. Dans les *features* GeoJSON, les donn√©es sont stock√©es dans l'objet `properties`. Nous r√©cup√©rons donc le nom de la r√©gion m√©tropolitaine en prenant le premier *feature* et en trouvant le nom `CMA` dans ses propri√©t√©s.

```ts showLineNumbers filename="visualizeData.ts" {11-32}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(census: SimpleTable) {
  const allCMAs = await census.getUniques("CMA");

  function drawMap(
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) {
    return plot({
      title: data.features[0].properties.CMA,
      subtitle:
        "Variation from the median household total income at the dissemination area level.",
      caption: "2021 Census, Statistics Canada",
      inset: 10,
      projection: {
        type: "mercator",
        domain: data,
      },
      color: {
        legend: true,
        type: "diverging",
        domain: [-100, 100],
        label: null,
        tickFormat: (d) => {
          if (d > 0) {
            return `+${d}%`;
          } else {
            return `${d}%`;
          }
        },
      },
      marks: [
        geo(data, { fill: "varPerc", stroke: "varPerc" }),
      ],
    });
  }

  for (const CMA of allCMAs) {
    const tableCMA = await census.cloneTable();
    await tableCMA.keep({ CMA });
    await tableCMA.writeMap(drawMap, `./sda/output/${CMA}.png`);
    break;
  }
}
```
![Capture d'√©cran de VS Code montrant une carte stylis√©e.](/assets/stats-can-census/styled-map.png)

√áa a bien meilleure allure.

Une derni√®re chose que j'aime faire sur mes cartes est d'ajouter un contour.

Dans la boucle, nous pouvons cloner la `tableCMA` et fusionner toutes les g√©om√©tries des aires de diffusion en utilisant la m√©thode `aggregateGeo`. Comme cela peut √™tre assez co√ªteux en termes de calcul lorsqu'il y a beaucoup d'aires de diffusion, nous mettons le r√©sultat en cache.

Nous pouvons ensuite ins√©rer cette g√©om√©trie nouvellement cr√©√©e dans la `tableCMA`.

Dans la fonction `drawMap`, nous pouvons ajouter un nouveau marqueur `geo` pour dessiner le contour. Mais nous devons filtrer sur le `varPerc` pour nous assurer de ne dessiner que le contour et non toutes les aires de diffusion √† nouveau.


```ts showLineNumbers filename="visualizeData.ts" {35, 38-41, 50-54}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(census: SimpleTable) {
  const allCMAs = await census.getUniques("CMA");

  function drawMap(
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) {
    return plot({
      title: data.features[0].properties.CMA,
      subtitle:
        "Variation from the median household total income at the dissemination area level.",
      caption: "2021 Census, Statistics Canada",
      inset: 10,
      projection: {
        type: "mercator",
        domain: data,
      },
      color: {
        legend: true,
        type: "diverging",
        domain: [-100, 100],
        label: null,
        tickFormat: (d) => {
          if (d > 0) {
            return `+${d}%`;
          } else {
            return `${d}%`;
          }
        },
      },
      marks: [
        geo(
          data.features.filter((d) => typeof d.properties.varPerc === "number"),
          { fill: "varPerc", stroke: "varPerc" },
        ),
        geo(data.features.filter((d) => d.properties.varPerc === null), {
          stroke: "black",
          opacity: 0.5,
        }),
      ],
    });
  }

  for (const CMA of allCMAs) {
    const tableCMA = await census.cloneTable();
    await tableCMA.keep({ CMA });

    const outline = await tableCMA.cloneTable();
    await outline.cache(async () => {
      await outline.aggregateGeo("union");
    });
    await tableCMA.insertTables(outline);

    await tableCMA.writeMap(drawMap, `./sda/output/${CMA}.png`);
    break;
  }
}
```
![Capture d'√©cran de VS Code montrant une carte stylis√©e avec un contour.](/assets/stats-can-census/outline.png)

La diff√©rence est subtile, mais il est important de voir les trous dans la g√©om√©trie de la r√©gion m√©tropolitaine.

Maintenant que nous sommes satisfaits de l'apparence de notre carte, il est temps de supprimer l'instruction `break` √† la ligne 57 ! Cr√©ons 43 cartes ! Ex√©cutez tout le code !

Si vous examinez les cartes apr√®s avoir ex√©cut√© votre code, vous remarquerez quelques probl√®mes.

![Capture d'√©cran montrant des cartes probl√©matiques.](/assets/stats-can-census/maps-problems.png)

Tout d'abord, vous pouvez voir que certains dossiers ont √©t√© cr√©√©s pour certaines r√©gions m√©tropolitaines dans le dossier `output`. C'est parce que certains noms contiennent le caract√®re `/` ! Nous devons remplacer ce caract√®re par autre chose avant de le transmettre √† `writeMap`.

Nous pouvons mettre √† jour `visualizeData.ts` pour corriger cela.

```ts showLineNumbers filename="visualizeData.ts" {58}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(census: SimpleTable) {
  const allCMAs = await census.getUniques("CMA");

  function drawMap(
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) {
    return plot({
      title: data.features[0].properties.CMA,
      subtitle:
        "Variation from the median household total income at the dissemination area level.",
      caption: "2021 Census, Statistics Canada",
      inset: 10,
      projection: {
        type: "mercator",
        domain: data,
      },
      color: {
        legend: true,
        type: "diverging",
        domain: [-100, 100],
        label: null,
        tickFormat: (d) => {
          if (d > 0) {
            return `+${d}%`;
          } else {
            return `${d}%`;
          }
        },
      },
      marks: [
        geo(
          data.features.filter((d) => typeof d.properties.varPerc === "number"),
          { fill: "varPerc", stroke: "varPerc" },
        ),
        geo(data.features.filter((d) => d.properties.varPerc === null), {
          stroke: "black",
          opacity: 0.5,
        }),
      ],
    });
  }

  for (const CMA of allCMAs) {
    const tableCMA = await census.cloneTable();
    await tableCMA.keep({ CMA });

    const outline = await tableCMA.cloneTable();
    await outline.cache(async () => {
      await outline.aggregateGeo("union");
    });
    await tableCMA.insertTables(outline);

    await tableCMA.writeMap(
      drawMap,
      `./sda/output/${(CMA as string).replaceAll("/", "-")}.png`,
    );
  }
}
```

Nous pouvons √©galement constater que le contour de certaines villes n'est pas correct et que la carte de Montr√©al n'est qu'un √©norme polygone. Cela se produit g√©n√©ralement lorsque certaines g√©om√©tries sont invalides. La simplification cr√©e souvent des g√©om√©tries invalides. Heureusement, nous pouvons utiliser la m√©thode `fixGeo` pour r√©soudre ce probl√®me !

Nous pouvons mettre √† jour `crunchData.ts`, dans la m√©thode `cache`, pour corriger les g√©om√©tries apr√®s le chargement des donn√©es g√©ospatiales.


```ts showLineNumbers filename="crunchData.ts" {39}
import { SimpleDB } from "@nshiab/simple-data-analysis";

export default async function crunchData(sdb: SimpleDB) {
  const census = sdb.newTable("census");

  await census.cache(async () => {
    await census.loadData("sda/data/98-401-X2021006_eng_CSV/*_utf8.csv", {
      strict: false,
    });
    await census.keep({
      GEO_LEVEL: "Dissemination area",
      CHARACTERISTIC_ID: [243], // Median total income of household in 2020 ($)
    });
    await census.selectColumns([
      "DGUID",
      "GEO_NAME",
      "C1_COUNT_TOTAL",
    ]);
    await census.renameColumns({ C1_COUNT_TOTAL: "medianIncome" });

    const names = sdb.newTable("names");
    await names.loadData("sda/data/2021_92-151_X_utf8.csv", { strict: false });
    await names.keep({
      CMATYPE_RMRGENRE: "B",
    });
    await names.selectColumns(["DADGUID_ADIDUGD", "CMANAME_RMRNOM"]);
    await names.removeDuplicates();
    await names.renameColumns({
      DADGUID_ADIDUGD: "DGUID",
      CMANAME_RMRNOM: "CMA",
    });
    await census.join(names);

    const disseminationAreas = sdb.newTable("disseminationAreas");
    await disseminationAreas.loadGeoData(
      "sda/data/lda_000b21a_e_simplified.shp.zip",
      { toWGS84: true },
    );
    await disseminationAreas.fixGeo();
    await disseminationAreas.selectColumns(["DGUID", "geom"]);
    await census.join(disseminationAreas);
    await census.selectColumns(["medianIncome", "CMA", "geom"]);
    await census.removeMissing();
  });

  const medians = await census.summarize({
    values: "medianIncome",
    categories: "CMA",
    summaries: "median",
    outputTable: "medians",
  });
  await medians.removeColumns("value");

  await census.join(medians);
  await census.addColumn(
    "varPerc",
    "number",
    `(medianIncome - median) / median * 100`,
  );
  await census.round("varPerc");

  return census;
}
```

Arr√™tez de surveiller `main.ts` (`CTRL` + `C` dans votre terminal) et supprimez `.temp` et `.sda-cache` manuellement ou en ex√©cutant `deno task clean`. Supprimez √©galement tout le contenu du dossier `output`.

Et relan√ßons tout depuis le d√©but !

![Capture d'√©cran montrant les cartes corrig√©es.](/assets/stats-can-census/last-run.png)

Tout fonctionne parfaitement et tous nos probl√®mes ont disparu. üòÅ

Sur mon ordinateur, notre code a pu traiter toutes les donn√©es et dessiner toutes les cartes en 2 minutes et 46 secondes. Mais gr√¢ce √† notre syst√®me de mise en cache astucieux, si je veux ajuster l'apparence des cartes, cela prend seulement 32 secondes pour r√©√©crire les 43 cartes.

Au fait, ici, nous enregistrons nos cartes sous forme d'images, mais si vous voulez des vecteurs pour les modifier dans Illustrator ou d'autres outils de conception, il vous suffit de remplacer `.png` par `.svg` dans `writeMap`.

## Conclusion

Que de chemin parcouru ! Traiter de grands ensembles de donn√©es avec plusieurs tables stockant des donn√©es tabulaires et g√©ospatiales n'est pas une t√¢che facile.

Mais j'esp√®re que cet exemple concret vous a montr√© comment vous pouvez couper au travers de gigaoctets de donn√©es comme dans du beurre avec SDA. üßà

Amusez-vous bien avec votre prochain projet de donn√©es et n'h√©sitez pas √† [me contacter](/contact) si vous souhaitez partager ce que vous cr√©ez avec SDA ou si vous avez des questions ! üòä

<NoticeEnd lang="fr"/>
