---
title: Publier une librairie TypeScript
description: Dans cette leÃ§on, vous apprendrez Ã  publier une librairie TypeScript avec Deno et JSR
---

import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Publier une librairie TypeScript

Avez-vous des morceaux de code que vous copiez-collez dâ€™un projet Ã  un autreâ€¯? Si câ€™est le cas, cela signifie probablement que vous devriez crÃ©er une librairie.

Dans cette leÃ§on, je vais vous montrer comment crÃ©er une librairie en code ouvert avec [Deno](https://deno.com/) et [JSR](https://jsr.io/). Câ€™est incroyablement simple, car Deno et JSR peuvent tester, compiler et publier Ã  la fois votre code et votre documentation.

Je pars du principe que vous avez suivi les leÃ§ons prÃ©cÃ©dentes, en particulier celles-ci :
- [Utiliser des librairies](/pushing-further/libraries)
- [Comprendre les versions de librairies](/ninja-moves/semver)
- [Utiliser des tests dans vos projets](/ninja-moves/tests)

<NoticeIntro lang="fr" />

## CrÃ©er un compte et un package JSR

JSR est le registre TypeScript sur lequel nous allons publier notre librairie. Câ€™est une plateforme [en code ouvert](https://github.com/jsr-io/jsr) et gratuite. Elle est maintenue par la mÃªme Ã©quipe que Deno.

Commencez par [crÃ©er un compte sur la plateforme](https://jsr.io/). Vous pouvez y associer votre compte GitHub.

![Page dâ€™accueil de JSR.](/assets/ninja-moves/publishing-library/jsr.png)

Ensuite, cliquez sur `Publish a package`.

![Bouton publier un package sur JSR.](/assets/ninja-moves/publishing-library/publish-button.png)

Vous pouvez ensuite choisir un `scope` (par dÃ©faut, il sâ€™agit de votre nom dâ€™utilisateur GitHub) et un nom pour votre librairie. Ici, jâ€™ai Ã©crit `my-first-library`.

Cliquez sur `Create`.

![Nom de la librairie sur JSR.](/assets/ninja-moves/publishing-library/scope.png)

Gardez la page suivante ouverte pour lâ€™instant.

![Configuration de la librairie sur JSR.](/assets/ninja-moves/publishing-library/config.png)

## Coder la librairie

Il est temps dâ€™Ã©crire un peu de codeâ€¯! Dans ce projet, nous allons rÃ©utiliser une partie du code de la leÃ§on prÃ©cÃ©dente [Utiliser des tests dans vos projets](/ninja-moves/tests).

CrÃ©ez un nouveau dossier et ouvrez-le dans VS Code.

Ensuite, crÃ©ez un dossier `functions` et un fichier `getPercentage.ts` avec le code et la documentation ci-dessous.

```ts showLineNumbers filename="functions/getPercentage.ts"
/**
 * Calculates a percentage and returns it as a string formatted with a percentage sign ("%").
 *
 * @example
 * Basic usage
 * ```ts
 * getPercentage(50, 200); // "25%"
 * getPercentage(0, 0);    // "0%"
 * ```
 *
 * @param current - The current value to calculate the percentage for.
 * @param total - The total value to calculate the percentage against.
 * @returns A string representing the percentage. If `total` is 0, returns "0%".
 */
export default function getPercentage(
    current: number,
    total: number,
): string {
    if (total === 0) {
        return "0%";
    } else {
        const percentage = (current / total) * 100;
        return `${percentage}%`;
    }
}
```

CrÃ©ez Ã©galement un fichier `index.ts`. Ce sera le point dâ€™entrÃ©e de votre librairie. Lorsquâ€™une personne souhaitera utiliser votre librairie, câ€™est ce fichier quâ€™elle appellera.

Dans ce fichier, nous allons simplement importer notre fonction `getPercentage` et la rÃ©exporter. Câ€™est pratique, car si vous avez plusieurs classes, fonctions ou autres Ã©lÃ©ments Ã  publier dans votre librairie, vous pouvez tous les centraliser et les exporter Ã  partir dâ€™ici.

Par exemple, voici toutes les fonctions exportÃ©es dans ma [librairie journalism](https://github.com/nshiab/journalism/blob/main/src/index.ts).


```ts showLineNumbers filename="index.ts"
import getPercentage from "./functions/getPercentage.ts";

export { getPercentage };
```

Il est essentiel de tester votre code avant de le publier. Reprenons le test de la leÃ§on [Utiliser des tests dans vos projets](/ninja-moves/tests).

CrÃ©ez un dossier `tests` et ajoutez-y un fichier `getPercentage.test.ts`.


```ts showLineNumbers filename="tests/getPercentage.test.ts"
import { assertEquals } from "jsr:@std/assert";
import getPercentage from "../functions/getPercentage.ts";

Deno.test("should return 50%", () => {
    assertEquals(getPercentage(50, 100), "50%");
});
Deno.test("should return 33%", () => {
    assertEquals(getPercentage(33.333, 100), "33%");
});
Deno.test("should return 0%", () => {
    assertEquals(getPercentage(0, 100), "0%");
});
Deno.test("should return 0%", () => {
    assertEquals(getPercentage(1, 0), "0%");
});
```

Enfin, installez la librairie standard [@std/assert](https://jsr.io/@std/assert) avec la commande suivante : `deno add jsr:@std/assert`.

Maintenant, si vous exÃ©cutez `deno test`, tout devrait se dÃ©rouler sans problÃ¨me.

![ExÃ©cution des tests en local.](/assets/ninja-moves/publishing-library/running-tests.png)

Nâ€™oublions pas dâ€™ajouter les champs recommandÃ©s par JSR dans notre fichier `deno.json`. Je les ai copiÃ©s depuis la page web que je vous ai conseillÃ© de garder ouverte plus tÃ´t.

Voici ce que nous allons ajouter :
- Le nom de la librairie
- Le numÃ©ro de version (consultez la leÃ§on [Comprendre les versions de librairies](/ninja-moves/semver) pour en savoir plus)
- La licence, qui est ici la licence [MIT](https://opensource.org/license/mit). Câ€™est une licence courante pour les librairies en code ouvert, mais vous pouvez la modifier si vous le souhaitez.
- Ce que la librairie doit exporter. Comme notre point dâ€™entrÃ©e est `./index.ts`, jâ€™ai simplement remplacÃ© `./mod.ts` par celui-ci.


```json showLineNumbers filename="deno.json" {2-5}
{
  "name": "@nshiab/my-first-library",
  "version": "0.1.0",
  "license": "MIT",
  "exports": "./index.ts",
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.12"
  }
}
```

Comme cette leÃ§on est centrÃ©e sur la publication de la librairie, je ne vais pas pousser ce code sur GitHub. Mais pour vos futures libraries, **je vous encourage fortement Ã  sauvegarder votre code quelque part dans le cloud**â€¯! Nâ€™hÃ©sitez pas Ã  consulter la [leÃ§on sur GitHub](/git-and-github/github-basics) pour en savoir plus.

## Publier la librairie

Lancez maintenant simplement la commande `deno publish`â€¯!

Une page web devrait sâ€™ouvrir automatiquement dans votre navigateur. Si ce nâ€™est pas le cas, cliquez sur le lien affichÃ© dans le terminal.

![Publication de la librairie.](/assets/ninja-moves/publishing-library/deno-publish.png)

JSR vous demandera dâ€™autoriser la publication de la librairie. Câ€™est aussi lâ€™occasion de vÃ©rifier que la version est correcte.

![Autorisation de publication de la librairie.](/assets/ninja-moves/publishing-library/authorization.png)

AprÃ¨s quelques secondes, vous serez redirigÃ© vers... la page de votre librairieâ€¯! Elle est maintenant en ligneâ€¯!

Si vous cliquez sur lâ€™onglet `Docs`, vous verrez apparaÃ®tre votre fonction `getPercentage`.

![Documentation de la librairie.](/assets/ninja-moves/publishing-library/docs.png)

Si vous cliquez sur la fonction, vous serez redirigÃ© vers sa page, avec la JSDoc que nous avons Ã©crite dans son fichierâ€¯! DÃ©sormais, nâ€™importe qui peut utiliser votre code. Et JSR publie automatiquement le code ainsi que la documentation pour que le monde entier puisse les consulter. Nâ€™est-ce pas incroyableâ€¯? ğŸ¤©

![Documentation de la fonction getPercentage.](/assets/ninja-moves/publishing-library/getPercentage.png)

## Importer et utiliser la librairie

Maintenant que la librairie est publiÃ©e, nous pouvons lâ€™installer dans nâ€™importe quel projet, comme nous lâ€™avons fait avec dâ€™autres dans les leÃ§ons prÃ©cÃ©dentes.

CrÃ©ez un autre dossier et ouvrez-le dans VS Code.

Ensuite, exÃ©cutez une commande similaire Ã  `deno add jsr:@nshiab/my-first-library`, en remplaÃ§ant bien sÃ»r par votre nom dâ€™utilisateur et le nom de votre librairie, comme indiquÃ© sur JSR. Vous verrez votre librairie apparaÃ®tre dans le fichier `deno.json`.

CrÃ©ez un nouveau fichier `main.ts` avec le code ci-dessous. LÃ  encore, remplacez `@nshiab/my-first-library` par le vÃ´tre.

Comme votre librairie exporte `getPercentage` dans son point dâ€™entrÃ©e, elle peut Ãªtre importÃ©e directementâ€¯!


```ts showLineNumbers filename="main.ts"
import { getPercentage } from "@nshiab/my-first-library";

const percentage = getPercentage(20, 100);
console.log(percentage);
```

Et maintenant, si vous exÃ©cutez `deno run main.ts`, vous verrez votre fonction Ãªtre appelÃ©e et retourner le bon rÃ©sultatâ€¯!

Ne supprimez pas le dossier de ce projet pour lâ€™instant. Nous y reviendrons plus tard.

![Importation et utilisation de la librairie.](/assets/ninja-moves/publishing-library/importing.png)

## Tester avant de publier

Ce que nous avons accompli est dÃ©jÃ  impressionnantâ€¯: nous avons crÃ©Ã© du code rÃ©utilisable et documentÃ©.

Mais il est trÃ¨s important dâ€™exÃ©cuter vos tests **avant** de publier. Croyez-moi : il faut rÃ©sister Ã  lâ€™envie de publier trop viteâ€¯! Il mâ€™est arrivÃ© trop souvent de me dire : Â«â€¯Câ€™est juste un petit changement, je peux publier directementâ€¯Â», pour ensuite me retrouver avec une version cassÃ©e de la librairie en ligne.

Nous avons dÃ©jÃ  mis en place des tests. CrÃ©ons une tÃ¢che `test-publish` dans le fichier `deno.json` pour les exÃ©cuter avant la publication. Si vous ne savez pas ce que sont les tÃ¢ches, consultez la leÃ§on [ExÃ©cuter des tÃ¢ches](/pushing-further/tasks).

Tant quâ€™Ã  faire, nous pouvons aussi enchaÃ®ner quelques commandes pour nous assurer que notre code est bien formatÃ© (`deno fmt`) et que les types sont corrects (`deno check`).

DÃ©sormais, au lieu dâ€™exÃ©cuter directement `deno publish`, nous exÃ©cuterons `deno task test-publish`. Si un problÃ¨me est dÃ©tectÃ© dans les types ou les tests, Deno sâ€™arrÃªtera et nâ€™autorisera pas la publication de la librairie.


```json showLineNumbers filename="deno.json" {2-4}
{
  "tasks": {
    "test-publish": "deno fmt && deno check index.ts && deno test && deno publish"
  },
  "name": "@nshiab/my-first-library",
  "version": "0.1.0",
  "license": "MIT",
  "exports": "./index.ts",
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.12"
  }
}
```

## Publier une nouvelle version

Mettons Ã  jour notre projet et publions une nouvelle version.

Pour lâ€™instant, il nâ€™y a rien sur la page principale de la librairie sur JSR. Il nous manque un fichier `README.md`. Câ€™est simplement un texte pour expliquer Ã  tout le monde Ã  quoi sert la librairie.

CrÃ©ez un nouveau fichier `README.md` dans votre projet et ajoutez-y le texte suivant.


```md showLineNumbers filename="README.md"
This is my first library published on JSR, created as part of the
[Code Like a Journalist](https://www.code-like-a-journalist.com/en) course.

If youâ€™d like to learn how to publish your own TypeScript library, check out the lesson:
[Publishing a TypeScript Library](https://www.code-like-a-journalist.com/en/ninja-moves/publishing-library).
```

Dans notre fichier `deno.json`, mettons Ã  jour la version. Comme il sâ€™agit dâ€™un petit changement, je vous suggÃ¨re de passer Ã  la version `0.1.1`.

```json showLineNumbers filename="deno.json" /"0.1.1"/
{
  "tasks": {
    "test-publish": "deno fmt && deno check index.ts && deno test && deno publish"
  },
  "name": "@nshiab/my-first-library",
  "version": "0.1.1",
  "license": "MIT",
  "exports": "./index.ts",
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.12"
  }
}
```

Et maintenant, utilisons notre nouvelle tÃ¢che `test-publish` pour republier notre librairie : `deno task test-publish`.

Vous pouvez constater que les vÃ©rifications et les tests sont dÃ©sormais effectuÃ©s avant la publicationâ€¯! ğŸ¥³

![Test et publication dâ€™une nouvelle version.](/assets/ninja-moves/publishing-library/test-publish.png)

Approuvez la publication comme prÃ©cÃ©demment, et aprÃ¨s quelques secondes, vous verrez la page de votre librairie mise Ã  jour avec le contenu de votre `README`â€¯!

Vous pouvez Ã©galement voir que la derniÃ¨re version est maintenant la `0.1.1`.

![Nouvelle version publiÃ©e.](/assets/ninja-moves/publishing-library/new-version.png)

## Mettre Ã  jour vers une nouvelle version dans un projet

Une nouvelle version de notre librairie a Ã©tÃ© publiÃ©eâ€¯! Il est temps de mettre Ã  jour le projet qui lâ€™utilise.

Pour Ãªtre tout Ã  fait honnÃªte, cette mise Ã  jour n'est pas trÃ¨s intÃ©ressanteâ€¦ seul le README a Ã©tÃ© ajoutÃ©â€¯! Mais je souhaite vous montrer comment mettre Ã  jour vos dÃ©pendances facilement. ğŸ¤“

Dans le projet qui utilise la librairie, exÃ©cutez la commande `deno outdated`. Deno vÃ©rifiera toutes les versions des librairies JSR et NPM utilisÃ©es dans votre projet et vous indiquera si vous Ãªtes en retard sur lâ€™une dâ€™elles.

Voici la signification des colonnes :
- `Current` correspond Ã  la version actuellement installÃ©e dans votre projet
- `Update` est la version que Deno vous propose dâ€™installer. Ce nâ€™est pas forcÃ©ment la plus rÃ©cente si vous avez utilisÃ© `^` ou `~` pour dÃ©finir la plage de versions acceptables dans votre `deno.json`. Consultez la leÃ§on [Comprendre les versions de librairies](/ninja-moves/semver) pour en savoir plus.
- `Latest` est la version la plus rÃ©cente disponible.

![Librairie obsolÃ¨te.](/assets/ninja-moves/publishing-library/outdated.png)

Si vous souhaitez mettre Ã  jour votre librairie, vous pouvez le faire manuellement avec `deno add jsr:@nshiab/my-first-library@0.1.1`.

Mais si vous avez beaucoup de librairies Ã  mettre Ã  jour, vous pouvez exÃ©cuter la commande Deno suggÃ©rÃ©e pour toutes les mettre Ã  jour en une fois : `deno outdated --update`.

Et voilÃ â€¯! Nous venons de mettre Ã  jour et utilisons dÃ©sormais la nouvelle versionâ€¯!

![Librairie mise Ã  jour.](/assets/ninja-moves/publishing-library/deno-update.png)


## Configuration avancÃ©e

Nous avons utilisÃ© les paramÃ¨tres par dÃ©faut de JSR pour notre librairie, mais plusieurs options supplÃ©mentaires sont disponibles si vous cliquez sur lâ€™onglet `Settings`.

Dans les paramÃ¨tres, vous pouvez ajouter davantage dâ€™informations sur votre librairie, comme une brÃ¨ve description utile pour les personnes qui utilisent le moteur de recherche de JSR. Notez que vous pouvez Ã©galement rendre la librairie non rÃ©pertoriÃ©e, afin quâ€™elle ne soit pas accessible via la recherche. Vous pouvez aussi indiquer sur quel environnement dâ€™exÃ©cution vous avez testÃ© votre librairie (Deno, Node.js, Bun, etc.).

Si votre librairie est obsolÃ¨te, cassÃ©e ou si vous ne souhaitez plus la maintenir, vous pouvez lâ€™archiver.

![ParamÃ¨tres de la librairie.](/assets/ninja-moves/publishing-library/settings.png)

Il est Ã©galement possible de lier votre librairie Ã  un dÃ©pÃ´t GitHub. Cela permet dâ€™activer la publication automatique de votre librairie avec GitHub Actions.

Cela demande un peu plus de configuration, mais cela peut Ãªtre intÃ©ressant si vous prÃ©voyez de mettre Ã  jour souvent votre librairie et que vous souhaitez automatiser ce processus.

Si vous souhaitez explorer cette voie, les leÃ§ons suivantes vous seront utiles :
- [Comment utiliser GitHub ?](/git-and-github/github-basics)
- [Comment utiliser GitHub Actions ?](/git-and-github/github-actions)

Voici par exemple mon processus pour publier une nouvelle version de la librairie [Simple-Data-Analysis](https://github.com/nshiab/simple-data-analysis) :

1. Je crÃ©e une [nouvelle issue](https://github.com/nshiab/simple-data-analysis/issues) lorsquâ€™il y a un bug Ã  corriger ou une fonctionnalitÃ© Ã  ajouter.

2. Ã€ partir de cette issue, je crÃ©e une branche et je travaille dessus. Je mâ€™assure dâ€™ajouter de nouveaux [tests](https://github.com/nshiab/simple-data-analysis/tree/main/test/unit/methods) pour couvrir la correction ou la nouvelle fonctionnalitÃ©.

3. Je crÃ©e une pull request pour fusionner la branche dans `main`. Jâ€™ai un [workflow GitHub Actions](https://github.com/nshiab/simple-data-analysis/blob/main/.github/workflows/all-tests.yml) qui exÃ©cute les tests. Si toutes les vÃ©rifications et les tests passent, la pull request est acceptÃ©e et fusionnÃ©e.

4. Lorsque je suis prÃªt Ã  publier une nouvelle version (souvent aprÃ¨s plusieurs pull requests), jâ€™exÃ©cute localement lâ€™une des tÃ¢ches `patch`, `minor` ou `major`, dÃ©finies dans le fichier [`deno.json`](https://github.com/nshiab/simple-data-analysis/blob/d3eb64f34fdc93c6cbbe0c65914f31ac8be1f36f/deno.json#L11-L13) du dÃ©pÃ´t.

5. Ces tÃ¢ches lancent un script appelÃ© [`incrementVersion.ts`](https://github.com/nshiab/simple-data-analysis/blob/main/src/incrementVersion.ts), qui met Ã  jour la version dans `deno.json`, crÃ©e un [tag Git](https://git-scm.com/book/en/v2/Git-Basics-Tagging) et le pousse sur GitHub.

6. Lorsquâ€™un nouveau tag est poussÃ© sur GitHub, deux workflows sont dÃ©clenchÃ©s : [un pour publier](https://github.com/nshiab/simple-data-analysis/blob/main/.github/workflows/publish.yml) la librairie sur JSR, et un autre pour [crÃ©er une release](https://github.com/nshiab/simple-data-analysis/blob/main/.github/workflows/release.yml) sur GitHub avec un rÃ©sumÃ© de tous les changements issus des pull requests approuvÃ©es.

Jâ€™aime ce flux de travail car il garde tout synchronisÃ©, mâ€™Ã©pargne beaucoup de saisies manuelles et de clics, et gÃ©nÃ¨re des releases claires et utiles. Voici par exemple la plus rÃ©cente au moment oÃ¹ jâ€™Ã©cris ces lignes :

![Exemple de release GitHub.](/assets/ninja-moves/publishing-library/release.png)

Publier sur JSR directement depuis GitHub permet Ã©galement de certifier la provenance de la librairie, ce qui amÃ©liore son score.

Pour Ãªtre honnÃªte, ce score nâ€™est pas si important â€” il sert surtout Ã  encourager les bonnes pratiques. Si vous Ãªtes la seule personne Ã  utiliser votre librairie, ne vous en souciez pas trop. Une publication manuelle suffit probablementâ€¯!

![Score de la librairie.](/assets/ninja-moves/publishing-library/score.png)

## Librairie de composants Svelte

Il est aussi possible de crÃ©er votre propre librairie de composants Svelte, comme expliquÃ© dans la [documentation de SvelteKit](https://svelte.dev/docs/kit/packaging). Leurs exemples sont basÃ©s sur l'utilisation de Node.js et la publication sur NPM, mais il est trÃ¨s probable quâ€™on puisse faire la mÃªme chose avec Deno et JSR. Je nâ€™ai pas encore essayÃ©, mais ce serait un excellent sujet pour une prochaine leÃ§on ! ğŸ”®

## Registres privÃ©s

Parfois, vous ne voulez pas rendre tout votre code public, mÃªme si je dirais que dans la grande majoritÃ© des cas, vous devriez. Mais dans un contexte dâ€™entreprise, crÃ©er une librairie privÃ©e peut Ãªtre trÃ¨s pratique pour partager du code entre collÃ¨gues et rÃ©utiliser des classes, fonctions et mÃ©thodes testÃ©es dans plusieurs projets en mÃªme temps.

Avec NPM, [vous pouvez payer pour utiliser des registres privÃ©s](https://docs.npmjs.com/creating-and-publishing-private-packages).

Avec JSR, vous pouvez [retirer votre librairie de lâ€™index](https://jsr.io/docs/private-registries), ce qui la rend introuvable via la recherche, mÃªme si elle reste accessible publiquement. Les librairies vraiment privÃ©s ne sont pas encore disponibles sur JSR, mais lâ€™Ã©quipe y travaille activement.

## Conclusion

Publier une librairie TypeScript nâ€™a jamais Ã©tÃ© aussi simple. Avant de migrer toutes mes librairies vers JSR, je les publiais sur NPM.

NPM est vraiment une plateforme incroyable, avec des millions de librairies en code ouvert accessibles Ã  tous. Elle joue un rÃ´le majeur dans le succÃ¨s de JavaScript et TypeScript en tant que langages de programmation. Mais publier sur NPM est plus compliquÃ© et alambiquÃ©.

Avec Deno et JSR, vous pouvez Ã©crire, tester, documenter et publier des librairies grÃ¢ce Ã  une configuration minimale mais trÃ¨s efficace. Alors, arrÃªtez de copier-coller du code et publiez votre propre librairieâ€¯! ğŸ˜

<NoticeEnd lang="fr" />
