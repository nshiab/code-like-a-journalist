---
title: Comment visualiser des donn√©es avec TypeScript
description: Dans cette le√ßon, nous apprenons √† visualiser des donn√©es tabulaires et g√©ospatiales avec Simple Data Analysis et Plot.
---

import { Callout } from 'nextra/components'
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Visualiser des donn√©es avec Simple Data Analysis et Plot

Les visualisations de donn√©es vous aident √† mieux comprendre vos donn√©es et √† communiquer vos conclusions. Dans cette le√ßon, nous allons apprendre √† visualiser des tables SDA, que ce soit avec des graphiques simples dans le terminal ou des visualisations plus pouss√©es avec la librairie Plot.

Nous utiliserons des donn√©es sur les feux de for√™t au Canada en 2023 et explorerons diff√©rentes techniques de visualisation, y compris des graphiques en ligne, des diagrammes en essaim et des cartes ! üåé

Cette le√ßon suppose que vous avez d√©j√† compl√©t√© les le√ßons sur les [Donn√©es tabulaires](/simple-data-analysis/tabular-data) et les [Donn√©es g√©ospatiales](/simple-data-analysis/geospatial).

<NoticeIntro lang="fr" />

## Configuration

Comme dans la le√ßon pr√©c√©dente, cr√©ez un nouveau dossier sur votre ordinateur, ouvrez-le avec VS Code et ex√©cutez la commande suivante dans le terminal : `deno -A jsr:@nshiab/setup-sda`

Apr√®s l'ex√©cution de cette commande, votre terminal affichera une description des fichiers cr√©√©s et des librairies install√©es.

Ensuite, ex√©cutez la t√¢che sugg√©r√©e pour d√©marrer et surveiller `sda/main.ts` : `deno task sda`

![Une capture d'√©cran montrant VS Code apr√®s l'ex√©cution de setup-sda.](/assets/simple-data-analysis/dataviz/setup.png)

Pour organiser notre code de mani√®re claire, nous allons cr√©er deux fonctions :
- `crunchData`, o√π nous allons r√©cup√©rer et nettoyer les donn√©es sur les feux de for√™t.
- `visualizeData`, o√π nous allons g√©n√©rer nos graphiques et nos cartes.

Commen√ßons par `crunchData`. Cr√©ez un fichier `crunchData.ts` dans `./sda/helpers/`. Cette fonction `async` attend un param√®tre `fires` de type `SimpleTable`, qui est une table SDA. La fonction n'a pas besoin de renvoyer de valeur.

√Ä l'int√©rieur, nous allons r√©cup√©rer et mettre en cache les donn√©es sur les feux de for√™t. Cet ensemble de donn√©es est une version l√©g√®rement modifi√©e de celui utilis√© dans la le√ßon pr√©c√©dente. Il inclut des dates et uniquement les feux ayant une superficie br√ªl√©e (`hectares`) sup√©rieure √† z√©ro.

```ts showLineNumbers filename="crunchData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });
}
````

Nous pouvons maintenant nous occuper de `visualizeData`. Cr√©ez un fichier `visualizeData.ts` dans `./sda/helpers/`. C'est √©galement une fonction `async` qui prend un param√®tre `fires` de type `SimpleTable`. Pour l'instant, contentons-nous d'afficher la table dans la console.

```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
}
```

Mettons √† jour `main.ts` pour cr√©er la table `fires` et la passer √† nos nouvelles fonctions.

```ts  showLineNumbers filename="main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";
import crunchData from "./helpers/crunchData.ts";
import visualizeData from "./helpers/visualizeData.ts";

const sdb = new SimpleDB();
const fires = sdb.newTable("fires");

await crunchData(fires);
await visualizeData(fires);

await sdb.done();
```
![Une capture d'√©cran montrant VS Code apr√®s l'ex√©cution des fonctions d'aide.](/assets/simple-data-analysis/dataviz/helpers.png)

## Pr√©paration des donn√©es

Nous avons environ 5 000 feux de for√™t. Disons que nous aimerions visualiser la superficie br√ªl√©e au fil de l'ann√©e pour chaque province. Nous devons calculer la somme cumulative de la superficie br√ªl√©e.

Dans `crunchData.ts`, additionnons les superficies br√ªl√©es par date et par province.

```ts showLineNumbers filename="crunchData.ts" {10-15}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });

  await fires.summarize({
    values: "hectares",
    categories: ["province", "startdate"],
    summaries: "sum",
    decimals: 1,
  });
}
```
![Une capture d'√©cran montrant VS Code affichant des tables de donn√©es.](/assets/simple-data-analysis/dataviz/summary.png)

Nous pouvons maintenant calculer la somme cumulative par province avec la m√©thode `accumulate`. Nous pouvons √©galement arrondir les valeurs avec la m√©thode `round` pour √©viter les erreurs d'arrondi li√©es aux nombres √† virgule flottante.

```ts showLineNumbers filename="crunchData.ts" {16-19}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });

  await fires.summarize({
    values: "hectares",
    categories: ["province", "startdate"],
    summaries: "sum",
    decimals: 1,
  });
  await fires.accumulate("sum", "cumulativeHectares", {
    categories: "province",
  });
  await fires.round("cumulativeHectares", { decimals: 1 });
}
```
![Une capture d'√©cran montrant une nouvelle colonne cumulativeHectares dans une table de donn√©es.](/assets/simple-data-analysis/dataviz/cumulative.png)

Visualisons maintenant ces donn√©es !

## Dans le terminal

SDA propose des m√©thodes pour afficher facilement des graphiques dans votre terminal. C'est un excellent moyen d'inspecter rapidement vos donn√©es. Travaillons dans `visualizeData.ts`.

Dans l'exemple ci-dessous, nous utilisons la m√©thode `logDotChart` avec :
- La colonne `startdate` pour les valeurs en abscisse (x).
- La colonne `cumulativeHectares` pour les valeurs en ordonn√©e (y).

J'ai √©galement ajout√© quelques options :
- Nous utilisons la valeur `province` pour cr√©er des graphiques multiples (un graphique par province).
- Nous appliquons la m√™me √©chelle √† tous les graphiques, ce qui facilite la comparaison entre les provinces.
- Nous formatons les libell√©s de l'axe des y avec la fonction `formatNumber` de la librairie [journalism](https://github.com/nshiab/journalism). J'ai cr√©√© cette librairie pour fournir des fonctions utilitaires g√©n√©rales. Elle est automatiquement install√©e avec `setup-sda`.

```ts showLineNumbers filename="visualizeData.ts" {6-14}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { formatNumber } from "@nshiab/journalism/web";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  await fires.logDotChart(
    "startdate",
    "cumulativeHectares",
    {
      smallMultiples: "province",
      fixedScales: true,
      formatY: (d) => formatNumber(d as number, { decimals: 0, suffix: " ha" }),
    },
  );
}
```
![Une capture d'√©cran montrant des graphiques en points dans le terminal.](/assets/simple-data-analysis/dataviz/dot-charts.png)

Vous n'√™tes pas limit√© aux graphiques en points. Vous pouvez √©galement utiliser les m√©thodes `logLineChart`, `logBarChart` et `logHistogram`.

Cependant, bien que ces m√©thodes soient tr√®s pratiques, elles restent assez limit√©es.

## Avec Plot

### Hectares br√ªl√©s cumul√©s par province

[Plot](https://github.com/observablehq/plot) est une librairie fantastique pour cr√©er des graphiques. Elle est bas√©e sur la c√©l√®bre librairie [d3](https://github.com/d3/d3) (d√©velopp√©e par la m√™me √©quipe, dont [Mike Bostock](https://github.com/mbostock) et [Philippe Rivi√®re](https://github.com/Fil)). Cependant, elle est bien plus facile √† utiliser, car de nombreux √©l√©ments qui doivent √™tre g√©r√©s manuellement avec d3 (√©chelles, axes, etc.) sont pris en charge automatiquement par Plot.

SDA int√®gre Plot de mani√®re transparente et l'installe automatiquement lorsque vous configurez votre projet avec `setup-sda`.

Pour cr√©er un graphique et l'enregistrer sous forme de fichier (`.jpeg`, `.png` ou `.svg` si vous souhaitez le retravailler dans Illustrator), vous pouvez utiliser la m√©thode `writeChart`.

La m√©thode `writeChart` n√©cessite deux arguments :
- Une fonction qui g√©n√®re un graphique Plot.
- Un chemin d'acc√®s pour enregistrer le fichier image.

Dans `visualizeData.ts`, cr√©ons un graphique en ligne simple repr√©sentant la superficie br√ªl√©e au fil de l'ann√©e 2023 pour chaque province.


```ts showLineNumbers filename="visualizeData.ts" {2, 6-16}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique en ligne enregistr√© au format png.](/assets/simple-data-analysis/dataviz/draw-chart.png)

<Callout type="info" emoji="üí°">
   Pour ouvrir deux onglets l'un au-dessus de l'autre, faites un clic droit sur l'onglet que vous souhaitez placer en bas et cliquez sur `Split down`. Dans la capture d'√©cran ci-dessus, j'ai masqu√© le terminal, mais m√™me s'il n'est pas affich√©, il continue de s'ex√©cuter et surveille `main.ts`. Ainsi, √† chaque mise √† jour du code du graphique, `main.ts` est relanc√© et le graphique est mis √† jour.
</Callout>

Laissez-moi vous expliquer le code ci-dessus: 
- Aux lignes 6-15, je cr√©e une fonction `drawChart`. Cette fonction attend une liste de valeurs `unknown`, car elle ne sait pas √† l'avance ce que contient notre table. En r√©alit√©, nos donn√©es seront sous forme d'une liste d'objets, comme d'habitude.
- √Ä la ligne 7, j'appelle la fonction `plot` de Plot. Cette fonction cr√©e un graphique et n√©cessite un objet avec certaines options.
- √Ä la ligne 8, j'ajoute une cl√© `marks` contenant une liste. C'est l'option la plus importante. `marks` d√©finit les formes qui repr√©sentent nos donn√©es.
- Aux lignes 9-13, √† l'int√©rieur de la liste `marks`, j'appelle la fonction `line` pour tracer des lignes bas√©es sur nos `data`. Pour les options de `line`, je sp√©cifie les valeurs `x` (`startdate`), les valeurs `y` (`cumulativeHectares`), et la couleur de `stroke` (bas√©e sur les valeurs de `province`).
- Enfin, √† la ligne 16, j'appelle la m√©thode `writeChart` sur la table `fires`. Le premier argument est notre fonction `drawChart`, qui recevra automatiquement les donn√©es `fires`. Le deuxi√®me argument sp√©cifie l'emplacement o√π enregistrer le graphique, dans le dossier `output`.

Notre graphique est encore assez basique, et il y a quelques probl√®mes, comme l'axe des y. Corrigeons cela !

```ts showLineNumbers filename="visualizeData.ts" {8-14}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique avec un meilleur axe des y.](/assets/simple-data-analysis/dataviz/y-axis.png)

C'est mieux ! Pour mettre √† jour l'axe des y, vous pouvez passer des options √† `y` sous forme d'objet. Voici ce que nous faisons dans le code ci-dessus :
- Nous ajoutons des grilles pour rendre le graphique plus lisible.
- Nous formatons le libell√© de l'axe sup√©rieur pour le rendre plus compr√©hensible avec l'unit√©.
- Nous limitons le nombre de graduations de l'axe √† 5.
- Nous formatons les libell√©s des graduations pour afficher des millions d'hectares au lieu d'hectares simples.

J'ai √©galement ajout√© un `inset` de `10` pour laisser un peu plus d'espace au libell√© du haut.

Passons maintenant au libell√© de l'axe des x. Il n'est pas n√©cessaire de modifier les libell√©s des graduations pour l'axe des x, car Plot g√®re tr√®s bien les dates et affiche automatiquement les ann√©es, mois, jours, voire l'heure, en fonction des valeurs de l'√©chelle et de la largeur de l'axe.

Les couleurs sont actuellement attribu√©es automatiquement. Nous pourrions choisir un autre jeu de couleurs et peut-√™tre ajouter une l√©gende.

```ts showLineNumbers filename="visualizeData.ts" {15-21}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { line, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        legend: true,
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique avec une l√©gende de couleurs.](/assets/simple-data-analysis/dataviz/x-colors.png)

Hmmmm... La l√©gende des couleurs ne fonctionne pas tr√®s bien avec autant de cat√©gories. Il faut changer de strat√©gie. Plut√¥t qu'une l√©gende, nous pourrions ajouter un point et un libell√© √† la fin de chaque ligne.

Supprimons la l√©gende des couleurs et ajoutons une `mark` `dot`. Comme nous voulons placer les points √† la fin de chaque ligne, nous utilisons la transformation `selectLast`, qui s√©lectionnera uniquement le dernier point de donn√©es.

Notez que l'ordre des √©l√©ments dans la liste `marks` est important. Les `marks` sont dessin√©es dans l'ordre d'ajout. Si vous souhaitez qu'une forme apparaisse au-dessus d'une autre, ajoutez-la plus tard dans la liste.


```ts showLineNumbers filename="visualizeData.ts" {2, 27-34}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
        dot(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            fill: "province",
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique en ligne avec des points √† la fin.](/assets/simple-data-analysis/dataviz/dots.png)

Ajoutons maintenant les libell√©s. Nous utilisons √† nouveau `selectLast` avec quelques options suppl√©mentaires :
- En plus de `x` et `y`, nous utilisons `z` pour indiquer √† Plot que nous voulons un texte pour chaque province. Si nous avions utilis√© `fill` ou `stroke` avec les valeurs de `province`, cela aurait √©t√© automatique, car le texte aurait pris la m√™me couleur que les lignes. Cependant, je pr√©f√®re un texte noir pour plus de lisibilit√©.
- Nous utilisons les valeurs de la colonne `province` pour le `text`.
- Nous appliquons un `fill` noir avec un `stroke` blanc afin d'am√©liorer la lisibilit√©, garantissant que le texte reste visible m√™me lorsqu'il chevauche d'autres √©l√©ments du graphique.
- Nous d√©finissons `textAnchor` sur `start` afin que le texte s'aligne avec le `dot`, mais nous le d√©calons de 5 pixels avec `dx` pour √©viter qu'il ne touche le point.

```ts showLineNumbers filename="visualizeData.ts" {2, 35-47}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
        dot(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            fill: "province",
          }),
        ),
        text(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            z: "province",
            text: "province",
            fill: "black",
            stroke: "white",
            textAnchor: "start",
            dx: 5,
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Une capture d'√©cran montrant un graphique en ligne avec des points et des √©tiquettes de texte √† la fin.](/assets/simple-data-analysis/dataviz/text-labels.png)

C'est bien mieux ! Mais notre graphique n√©cessite encore quelques ajustements √©vidents.

Par exemple, les points et les libell√©s √† la fin des lignes ne sont pas align√©s... Comme nous avons agr√©g√© les donn√©es en fonction de la date de d√©but des feux (`startDate`), certaines provinces ont des trous dans leurs dates.

Nous constatons √©galement qu'il ne se passe pas grand-chose avant la mi-avril et apr√®s le 1er octobre.

Revenons √† `crunchData.ts` pour corriger cela :
- √Ä la ligne 10, nous filtrons les feux pour ne conserver que ceux ayant un `startDate` entre le 15 avril 2023 et le 1er octobre 2023.
- Aux lignes 21-30, nous r√©cup√©rons la valeur maximale de `cumulativeHectares` pour chaque province et stockons les r√©sultats dans une nouvelle table, `maxValuesPerProvince`. Ensuite, nous supprimons et renommons certaines colonnes pour correspondre √† celles de la table `fires`. Nous ajoutons √©galement une nouvelle colonne avec la date finale de nos donn√©es (1er octobre 2023). Enfin, nous ins√©rons les lignes de cette nouvelle table dans `fires`.


```ts showLineNumbers filename="crunchData.ts" {10, 21-30}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });

  await fires.filter(`startdate >= '2023-04-15' && startdate <= '2023-10-01'`);
  await fires.summarize({
    values: "hectares",
    categories: ["province", "startdate"],
    summaries: "sum",
    decimals: 1,
  });
  await fires.accumulate("sum", "cumulativeHectares", {
    categories: "province",
  });
  await fires.round("cumulativeHectares", { decimals: 1 });
  const maxValuesPerProvince = await fires.summarize({
    values: "cumulativeHectares",
    categories: "province",
    summaries: "max",
    outputTable: "maxValuesPerProvince",
  });
  await maxValuesPerProvince.removeColumns("value");
  await maxValuesPerProvince.renameColumns({ max: "cumulativeHectares" });
  await maxValuesPerProvince.addColumn("startdate", "date", `'2023-10-01'`);
  await fires.insertTables(maxValuesPerProvince);
}
```
![Une capture d'√©cran montrant un graphique en ligne avec des √©tiquettes align√©es.](/assets/simple-data-analysis/dataviz/labels-aligned.png)

Et maintenant, nos libell√©s sont correctement align√©s !

Retournons dans `visualizeData.ts` pour corriger la marge de droite. Nous pouvons √©galement filtrer certaines √©tiquettes afin d'√©viter le chevauchement du texte.

```ts showLineNumbers filename="visualizeData.ts" {8, 46}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, line, plot, selectLast, text } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  const drawChart = (data: unknown[]) =>
    plot({
      inset: 10,
      marginRight: 110,
      y: {
        grid: true,
        label: "Area burned (hectares)",
        ticks: 5,
        tickFormat: (d) => `${d / 1_000_000}M`,
      },
      x: {
        label: "Date",
      },
      color: {
        scheme: "tableau10",
      },
      marks: [
        line(data, {
          x: "startdate",
          y: "cumulativeHectares",
          stroke: "province",
        }),
        dot(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            fill: "province",
          }),
        ),
        text(
          data,
          selectLast({
            x: "startdate",
            y: "cumulativeHectares",
            z: "province",
            text: "province",
            fill: "black",
            stroke: "white",
            textAnchor: "start",
            dx: 5,
            filter: (d) => d.cumulativeHectares >= 400_000,
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```

Et voici notre graphique ! Plut√¥t sympa, non ? üòä

![Le graphique final en ligne.](/assets/simple-data-analysis/dataviz/line-chart-final.png)

Bien s√ªr, vous pouvez faire bien plus avec Plot. N'h√©sitez pas √† consulter la [documentation](https://observablehq.com/plot/getting-started) et les [exemples](https://observablehq.com/@observablehq/plot-gallery).

Et si vous souhaitez cr√©er des graphiques modifiables dans des logiciels comme Illustrator, enregistrez-les simplement au format `.svg` au lieu de `.png`.

### Diagramme en essaim des feux de for√™t

Notre graphique pr√©c√©dent √©tait assez classique, mais vous pouvez √©galement cr√©er des visualisations plus originales.

Par exemple, cr√©ons un diagramme en essaim des feux de for√™t.

Nous pouvons mettre √† jour `crunchData.ts` pour revenir √† nos donn√©es brutes. Cependant, limitons-nous aux feux de plus de 1 hectare. Cela nous laisse environ 2 400 feux, ce qui est d√©j√† assez cons√©quent puisque nous voulons les visualiser individuellement !

```ts showLineNumbers filename="crunchData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(fires: SimpleTable) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
  });
  await fires.filter(`hectares > 1`);
}
```

Commen√ßons par dessiner nos feux sous forme de points simples sur un axe des y.

```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      marks: [
        dot(data, { y: "hectares" }),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Les feux repr√©sent√©s sous forme de points simples.](/assets/simple-data-analysis/dataviz/fires-dots.png)

Pour le moment, nos feux se chevauchent. L'objectif d'un diagramme en essaim est d'empiler les points de donn√©es de mani√®re √† ce que chacun reste visible.

Pour cr√©er un diagramme en essaim, nous pouvons utiliser la transformation `dodge` avec l'option `middle`. Mettons √† jour notre code.

Le rendu de ce graphique peut prendre quelques secondes en fonction de la puissance de votre ordinateur.

```ts showLineNumbers filename="visualizeData.ts" {2, 9}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      marks: [
        dot(data, dodgeX("middle", { y: "hectares" })),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Notre premier diagramme en essaim.](/assets/simple-data-analysis/dataviz/fires-dodge.png)

On dirait que nous avons √©noooorm√©ment de petits feux de for√™t et quelques tr√®s gros.

Une √©chelle logarithmique pourrait nous aider √† mieux visualiser cela ! Changeons le `type` de l'√©chelle `y` en `log`.

```ts showLineNumbers filename="visualizeData.ts" {8-10}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      y: {
        type: "log",
      },
      marks: [
        dot(data, dodgeX("middle", { y: "hectares" })),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Le diagramme en essaim avec une √©chelle logarithmique.](/assets/simple-data-analysis/dataviz/log-scale.png)

C'est d√©j√† bien mieux. Une autre am√©lioration consisterait √† ajuster le rayon des points en fonction de la taille des feux.

Nous pouvons mettre √† jour les options de la fonction `dot` et ajuster l'√©chelle `r` pour garantir un rayon minimum de 1 pixel et un maximum de 20 pixels.

```ts showLineNumbers filename="visualizeData.ts" {11-13, 15}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      y: {
        type: "log",
      },
      r: {
        range: [1, 20],
      },
      marks: [
        dot(data, dodgeX("middle", { y: "hectares", r: "hectares" })),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Le diagramme en essaim avec le rayon des points en fonction des hectares br√ªl√©s.](/assets/simple-data-analysis/dataviz/radiuses.png)

On y arrive.

Colorons maintenant les cercles en fonction de la cause des feux et ajoutons une l√©gende.

```ts showLineNumbers filename="visualizeData.ts" {14-16, 20}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      y: {
        type: "log",
      },
      r: {
        range: [1, 20],
      },
      color: {
        legend: true,
      },
      marks: [
        dot(
          data,
          dodgeX("middle", { y: "hectares", r: "hectares", fill: "cause" }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Le diagramme en essaim avec des couleurs selon la cause des feux.](/assets/simple-data-analysis/dataviz/fires-color.png)

Pour faciliter la comparaison des causes, nous pourrions utiliser des facettes. Faisons cela pour cr√©er trois petits graphiques au lieu d'un grand.

Pour ce faire, nous utilisons l'option `fx` pour cr√©er des facettes horizontales. Augmentons √©galement la largeur du graphique pour une meilleure lisibilit√©.

```ts showLineNumbers filename="visualizeData.ts" {8, 25}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      width: 800,
      y: {
        type: "log",
      },
      r: {
        range: [1, 20],
      },
      color: {
        legend: true,
      },
      marks: [
        dot(
          data,
          dodgeX("middle", {
            y: "hectares",
            r: "hectares",
            fill: "cause",
            fx: "cause",
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```
![Le diagramme en essaim avec des facettes selon la cause des feux.](/assets/simple-data-analysis/dataviz/facets.png)

√áa commence √† avoir fi√®re allure. Nous n'avons probablement plus besoin de la l√©gende des couleurs.

Ajustons les libell√©s et les axes. Et voil√†!

```ts showLineNumbers filename="visualizeData.ts" {8-9, 12-14, 19-21}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { dodgeX, dot, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawChart = (data: unknown[]) =>
    plot({
      width: 800,
      marginTop: 40,
      y: {
        type: "log",
        label: "Hectares",
        ticks: 5,
        grid: true,
      },
      r: {
        range: [1, 20],
      },
      fx: {
        label: null,
      },
      marks: [
        dot(
          data,
          dodgeX("middle", {
            y: "hectares",
            r: "hectares",
            fill: "cause",
            fx: "cause",
          }),
        ),
      ],
    });
  await fires.writeChart(drawChart, "./sda/output/chart.png");
}
```

C'est plut√¥t sympa, non ? En jouant avec les `marks` et les `transforms`, vous pouvez cr√©er des visualisations de donn√©es √©poustouflantes avec SDA et Plot.

Encore une fois, je vous encourage √† consulter la [documentation](https://observablehq.com/plot/getting-started) de Plot ainsi que les [exemples](https://observablehq.com/@observablehq/plot-gallery). Vous allez vous amuser avec cette librairie ! üíÉüï∫

![Le diagramme en essaim.](/assets/simple-data-analysis/dataviz/beeswarm.png)

### Carte des feux de for√™t

Avec SDA, vous pouvez travailler √† la fois avec des donn√©es tabulaires et des donn√©es g√©ospatiales. Et lorsque vous manipulez des donn√©es g√©ospatiales, vous souhaitez souvent cr√©er des cartes !

Cartographions nos feux en y ajoutant les limites des provinces canadiennes.

Tout d'abord, nous devons stocker les g√©om√©tries des feux dans la m√™me table que les limites des provinces.

R√©utilisons ce que nous avons fait dans la le√ßon pr√©c√©dente et mettons √† jour `crunchData.ts`. Nous allons le modifier pour qu'il prenne un deuxi√®me param√®tre, `provinces`. Nous r√©cup√©rons et mettons en cache les limites des provinces, puis nous les ins√©rons dans la table `fires`. Avant de les ins√©rer, nous ajoutons une colonne `isFire` √† la table `fires` pour pouvoir les diff√©rencier facilement par la suite.

```ts showLineNumbers filename="crunchData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(
  fires: SimpleTable,
  provinces: SimpleTable,
) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
    await fires.points("lat", "lon", "geom");
    await fires.addColumn("isFire", "boolean", `TRUE`);
  });

  await provinces.cache(async () => {
    await provinces.loadGeoData(
      "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
    );
  });

  await fires.insertTables(provinces, { unifyColumns: true });
}
```

Retirons tout sauf le `logTable` dans `visualizeData.ts` pour le moment.

```ts showLineNumbers filename="visualizeData.ts"
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
}
```

Mettons √† jour `main.ts` pour cr√©er une nouvelle table `provinces` et la passer √† `crunchData`.

```ts showLineNumbers filename="main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";
import crunchData from "./helpers/crunchData.ts";
import visualizeData from "./helpers/visualizeData.ts";

const sdb = new SimpleDB();
const fires = sdb.newTable("fires");
const provinces = sdb.newTable("provinces");

await crunchData(fires, provinces);
await visualizeData(fires);

await sdb.done();
```

Voici ce que vous devriez voir pour partir du bon pied.

![VS Code en cours d'ex√©cution et surveillant main.ts.](/assets/simple-data-analysis/dataviz/map-start.png)

Passons maintenant √† notre carte dans `visualizeData`. Au lieu d'utiliser `writeChart`, nous devons utiliser `writeMap`.

√âtant donn√© que nous travaillons avec des donn√©es g√©ospatiales, `writeMap` passe les donn√©es au format GeoJSON √† la fonction qui dessine la carte. C'est pourquoi `drawMap` attend des donn√©es avec le type `{ features: { properties: { [key: string]: unknown } }[] }`. Cela signifie essentiellement que nos donn√©es de table sont maintenant stock√©es dans les `properties` de chaque `feature`.

Pour travailler facilement avec les feux et les provinces, nous les isolons d'abord aux lignes 9-14. Ensuite, dans la fonction `plot`, nous utilisons la `mark` `geo`, qui g√®re automatiquement les coordonn√©es g√©ospatiales des `features`.

```ts showLineNumbers filename="visualizeData.ts" {2, 6-23}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      marks: [
        geo(provincesPolygons),
        geo(firesPoints),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code affichant une carte de base.](/assets/simple-data-analysis/dataviz/basic-map.png)

Comme vous pouvez le voir sur la capture d'√©cran ci-dessus, la marque `geo` a automatiquement d√©tect√© les coordonn√©es sous forme de points de nos feux et les coordonn√©es des polygones repr√©sentant les fronti√®res des provinces canadiennes. Plut√¥t malin, non ? ü§ì

Actuellement, la projection est en Mercator. Heureusement, Plot prend en charge des projections plus adapt√©es. Mettons √† jour l'option `projection` :
- D√©finissez le `type` sur `conic-conformal`.
- Utilisez l'option `rotate` pour s'assurer que la carte n'est pas inclin√©e avec cette projection.
- Utilisez l'option `domain` pour aider Plot √† faire en sorte que nos donn√©es g√©ospatiales occupent le plus d'espace possible sur la carte.

```ts showLineNumbers filename="visualizeData.ts" {17-21}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      marks: [
        geo(provincesPolygons),
        geo(firesPoints),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code affichant une projection conique conforme.](/assets/simple-data-analysis/dataviz/projection.png)

C'est mieux. Stylisons les fronti√®res des provinces pour cr√©er un joli fond.

```ts showLineNumbers filename="visualizeData.ts" {23-26}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        geo(firesPoints),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code affichant les fronti√®res des provinces en gris clair.](/assets/simple-data-analysis/dataviz/boundaries.png)

Passons maintenant aux feux. √âtant donn√© que ce sont des points g√©ospatiaux, Plot les affiche automatiquement sous forme de points en utilisant la marque `geo`.

Mais rien ne nous emp√™che d'utiliser une autre marque ! Cr√©ons plut√¥t une carte en `spike`.

Comme les feux sont une collection de `features` GeoJSON, nous devons utiliser des fonctions pour indiquer √† Plot o√π trouver les bonnes valeurs pour les options de `spike`.

```ts showLineNumbers filename="visualizeData.ts" {2, 22-24, 30-34}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot, spike } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      length: {
        range: [1, 100],
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        spike(firesPoints, {
          x: (d) => d.properties.lon,
          y: (d) => d.properties.lat,
          length: (d) => d.properties.hectares,
        }),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code affichant une carte en spikes basique.](/assets/simple-data-analysis/dataviz/basic-spike-map.png)

C'est assez int√©ressant ! Maintenant, ajoutons un code couleur aux pics en fonction de la cause des feux de for√™t.

```ts showLineNumbers filename="visualizeData.ts" {25-27, 37}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot, spike } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      length: {
        range: [1, 100],
      },
      color: {
        legend: true,
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        spike(firesPoints, {
          x: (d) => d.properties.lon,
          y: (d) => d.properties.lat,
          length: (d) => d.properties.hectares,
          stroke: (d) => d.properties.cause,
        }),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
![VS Code affichant une carte en spikes color√©e.](/assets/simple-data-analysis/dataviz/spikes-color.png)

Nous avons beaucoup de pics qui se chevauchent. Par d√©faut, Plot dessine les pics dans l'ordre dans lequel ils apparaissent dans les donn√©es.

Mettons √† jour `crunchData` pour trier les feux par ordre croissant de `hectares`, afin que les feux les plus importants soient dessin√©s en dernier et apparaissent au-dessus des autres.

```ts showLineNumbers filename="crunchData.ts" {13}
import { SimpleTable } from "@nshiab/simple-data-analysis";

export default async function crunchData(
  fires: SimpleTable,
  provinces: SimpleTable,
) {
  await fires.cache(async () => {
    await fires.loadData(
      "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/reported_fires_2023.csv",
    );
    await fires.points("lat", "lon", "geom");
    await fires.addColumn("isFire", "boolean", `TRUE`);
    await fires.sort({ hectares: "asc" });
  });

  await provinces.cache(async () => {
    await provinces.loadGeoData(
      "https://raw.githubusercontent.com/nshiab/simple-data-analysis/main/test/geodata/files/CanadianProvincesAndTerritories.json",
    );
  });

  await fires.insertTables(provinces, { unifyColumns: true });
}
```

De plus, par d√©faut, Plot attribue une opacit√© de 0.3 √† la couleur de remplissage des pics. Nous pouvons plut√¥t utiliser des couleurs plus claires qui correspondent √† la l√©gende des couleurs. En supprimant la transparence, nous r√©duirons la confusion visuelle sur la carte.

En outre, nous pouvons augmenter la hauteur maximale des pics pour une meilleure visibilit√©.

```ts showLineNumbers filename="visualizeData.ts" {23, 38-47}
import { SimpleTable } from "@nshiab/simple-data-analysis";
import { geo, plot, spike } from "@observablehq/plot";

export default async function visualizeData(fires: SimpleTable) {
  await fires.logTable();
  const drawMap = (
    data: { features: { properties: { [key: string]: unknown } }[] },
  ) => {
    const firesPoints = data.features.filter(
      (feature) => feature.properties.isFire,
    );
    const provincesPolygons = data.features.filter(
      (feature) => !feature.properties.isFire,
    );

    return plot({
      projection: {
        type: "conic-conformal",
        rotate: [100, -60],
        domain: data,
      },
      length: {
        range: [1, 200],
      },
      color: {
        legend: true,
      },
      marks: [
        geo(provincesPolygons, {
          stroke: "lightgray",
          fill: "whitesmoke",
        }),
        spike(firesPoints, {
          x: (d) => d.properties.lon,
          y: (d) => d.properties.lat,
          length: (d) => d.properties.hectares,
          stroke: (d) => d.properties.cause,
          fillOpacity: 1,
          fill: (d) => {
            if (d.properties.cause === "Human") {
              return "#b5caff";
            } else if (d.properties.cause === "Natural") {
              return "#ffe6a8";
            } else {
              return "#ffb9ad";
            }
          },
        }),
      ],
    });
  };
  await fires.writeMap(drawMap, "./sda/output/map.png");
}
```
<Callout type="info" emoji="üí°">
   Il existe de nombreuses fa√ßons de repr√©senter les couleurs. Ici, j'utilise des valeurs de couleur en HEX. Consultez [cet article](https://www.w3schools.com/html/html_colors_hex.asp) pour en savoir plus.
</Callout>

√áa a fi√®re allure ! Pour en savoir plus sur les cartes, consultez la [documentation de la marque `geo`](https://observablehq.com/plot/marks/geo) ainsi que la [documentation sur les projections](https://observablehq.com/plot/features/projections).

![Notre carte finale en spikes.](/assets/simple-data-analysis/dataviz/final-spike-map.png)

## Conclusion

F√©licitations ! Vous savez maintenant comment cr√©er des visualisations de donn√©es avec SDA et Plot !

J'esp√®re que les exemples √©tape par √©tape vous ont aid√© √† comprendre comment construire des graphiques simples tout comme des visualisations plus pouss√©es, en utilisant √† la fois des donn√©es tabulaires et g√©ospatiales.

Bien s√ªr, ces visualisations sont statiques. Il n'y a pas d'interaction utilisateur possible puisqu'elles sont enregistr√©es sous forme d'images. Il n'y a pas d'animations non plus.

Mais ne vous inqui√©tez pas ! Nous r√©utiliserons tout ce que nous avons appris ici pour cr√©er des visualisations de donn√©es interactives et anim√©es sur le web dans une prochaine le√ßon ! üòÅ

√Ä bient√¥t !

<NoticeEnd lang="fr"/>
