---
title: Publishing a TypeScript library
description: In this lesson, we learn how to publish a TypeScript library with Deno and JSR
---

import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"

# Publishing a TypeScript library

Do you have some bits of code that you keep copying and pasting from one project to another? If so, it probably means you should create a library!

In this lesson, I'll show you how to create an open-source library with [Deno](https://deno.com/) and [JSR](https://jsr.io/). It's incredibly easy since Deno and JSR can test, build, and publish both your code and documentation.

Note that I am assuming you've completed the previous lessons, especially these:
- [Using libraries](/pushing-further/libraries)
- [Understanding library versions](/ninja-moves/semver)
- [Using tests in your projects](/ninja-moves/tests)

<NoticeIntro />

## Creating a JSR account and package

JSR is the TypeScript registry where we will publish our library. It's [open source](https://github.com/jsr-io/jsr) and free to use. It's maintained by the same team as Deno.

First, [create an account on the platform](https://jsr.io/). You can link your GitHub account to it for convenience.

![JSR homepage.](/assets/ninja-moves/publishing-library/jsr.png)

Next, click on `Publish a package`.

![JSR publish button.](/assets/ninja-moves/publishing-library/publish-button.png)

You can then choose a `scope` (by default it's your GitHub username) and a name for your library. Here I wrote `my-first-library`.

Hit `Create`.

![JSR library name.](/assets/ninja-moves/publishing-library/scope.png)

Keep the next page open for now.

![JSR library config.](/assets/ninja-moves/publishing-library/config.png)

## Coding the library

It's time to write some code! In this project, we are going to reuse some of the code from the previous lesson `Using tests in your projects`.

Create a new folder and open it in VS Code.

Then create a folder `functions` and a `getPercentage.ts` file with the code and documentation below.

```ts showLineNumbers filename="helpers/getPercentage.ts"
/**
 * Calculates a percentage and returns it as a string formatted with a percentage sign ("%").
 *
 * @example
 * Basic usage
 * ```ts
 * getPercentage(50, 200); // "25%"
 * getPercentage(0, 0);    // "0%"
 * ```
 *
 * @param current - The current value to calculate the percentage for.
 * @param total - The total value to calculate the percentage against.
 * @returns A string representing the percentage. If `total` is 0, returns "0%".
 */
export default function getPercentage(
    current: number,
    total: number,
): string {
    if (total === 0) {
        return "0%";
    } else {
        const percentage = (current / total) * 100;
        return `${percentage}%`;
    }
}
```

Create also a `index.ts` file that will be our library entry point. When someone will want to use the library, this is the file they'll have access to.

In this file, we are just going to import our `getPercentage` function and re-export it. This is convenient because if you have a lot of classes, functions, or other things to publish in your library, you can put them all together here.

For example, here are all the functions exported in my [journalism library](https://github.com/nshiab/journalism/blob/main/src/index.ts).


```ts showLineNumbers filename="index.ts"
import getPercentage from "./functions/getPercentage.ts";

export { getPercentage };
```

Testing your code is critical before publishing it. Let's reuse the test in the [Using tests in your projects](/ninja-moves/tests) lesson. Create the `tests` folder and add `getPercentage.test.ts` in it.

```ts showLineNumbers filename="tests/getPercentage.test.ts"
import { assertEquals } from "jsr:@std/assert";
import getPercentage from "../functions/getPercentage.ts";

Deno.test("should return 50%", () => {
    assertEquals(getPercentage(50, 100), "50%");
});
Deno.test("should return 33%", () => {
    assertEquals(getPercentage(33.333, 100), "33%");
});
Deno.test("should return 0%", () => {
    assertEquals(getPercentage(0, 100), "0%");
});
Deno.test("should return 0%", () => {
    assertEquals(getPercentage(1, 0), "0%");
});
```

Finally, install the [@std/assert](https://jsr.io/@std/assert) standard library with: `deno add jsr:@std/assert`.

Now, if you run `deno test`, everything should run smoothly.

![Running tests locally.](/assets/ninja-moves/publishing-library/running-tests.png)

We musn't forget to add the fields recommended by JSR to our `deno.json`. I copied and pasted from the web page I told you to keep open earlier.

Here's what we are adding:
- The name of the library
- The version number (check the lesson [Understanding library versions](/ninja-moves/semver) for more)
- The license, which is [MIT](https://opensource.org/license/mit) here. It's a quite common license for open-source libraries but you can change it if you want.
- What the library should export. Since our entry point is `./index.ts`, I just replaced `./mod.ts` with it.
.

```json showLineNumbers filename="deno.json" {2-5}
{
  "name": "@nshiab/my-first-library",
  "version": "0.1.0",
  "license": "MIT",
  "exports": "./index.ts",
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.12"
  }
}
```

Since this lesson is focused on publishing the library, I won't push this code to GitHub. But in a real life scenario, **I strongly encourage you to save your code somewhere in the cloud**! Feel free to check the [GitHub lesson](/git-and-github/github-basics) for more.

## Publishing the library

Now just run `deno publish`!

A webpage should automatically open in a web browser. If not, click on the link in the terminal.

![Publishing the library.](/assets/ninja-moves/publishing-library/deno-publish.png)

JSR will ask to authorize the publication of the library. It's also an opportunity to ensure the version is the right one.

![Authorizing the library.](/assets/ninja-moves/publishing-library/authorization.png)

After a few seconds, you'll be redirected to... your library's page! It's now live!

If you click on the `Docs` tab, you'll your function `getPercentage`.

![The library's docs.](/assets/ninja-moves/publishing-library/docs.png)

If you click on the function, you'll be redirected to its page, with the JSDOC we wrote in its file! Now, anyone can use your code and JSR automatically published the code and the documentation for the whole world to see! Isn't that amazing? ðŸ¤©

![The getPercentage documentation.](/assets/ninja-moves/publishing-library/getPercentage.png)

## Importing and using the library

With the library now published, we can install it in any project we want, just like any others we used in previous lessons!

Let's create another folder and open it with VS Code.

Then run something similar to `deno add jsr:@nshiab/my-first-library`, but with your username and library name, as suggested on JSR. You'll see your library imported in a `deno.json`.

Create a new `main.ts` with the code below. Again, replace `@nshiab/my-first-library` with yours.

Since your library exports `getPercentage` in its entrypoint, it's available to be imported!

```ts showLineNumbers filename="main.ts"
import { getPercentage } from "@nshiab/my-first-library";

const percentage = getPercentage(20, 100);
console.log(percentage);
```

And now if you run `deno main.ts`, you'll see your function being called and returning the right output!

Don't delete this projects folder for now. We'll come back to it.

![Importing and using the library.](/assets/ninja-moves/publishing-library/importing.png)

## Testing before publishing

What we did is already amazing: we created reusable and documented code.

But it would be very important to run our tests **before** publishing. Trust me: you need to resist the urge of publishing too quickly! Too often I told myself "This is just a tiny change, I can publish directly", just to find myself with a broken version of the library live.

We already have tests in place. Let's create a task `test-publish` to run them before publishing `deno.json`. If you don't know what tasks are, check the [Running tasks](/pushing-further/tasks) lesson.

While at it, we can also chain a few commands to also make sure our code is well formatted (`deno fmt`) and check our types (`deno check`).

So now, it's of running `deno publish` directly, we would run `deno task test-publish`. If there is a problem with our types or tests, Deno will stop and won't publish the library.

```json showLineNumbers filename="deno.json" {2-4}
{
  "tasks": {
    "test-publish": "deno fmt && deno check index.ts && deno test && deno publish"
  },
  "name": "@nshiab/my-first-library",
  "version": "0.1.0",
  "license": "MIT",
  "exports": "./index.ts",
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.12"
  }
}
```

## Publishing a new version

Let's update our project and publish a new version.

Right now, there is nothing on the library main page on JSR. We are missing a `README.md`. This is just some text to tell everyone what the library is about.

Create a new `README.md` file in your project with the following text in it.

```md showLineNumbers filename="README.md"
This is my first library published on JSR, created as part of the
[Code Like a Journalist](https://www.code-like-a-journalist.com/en) course.

If youâ€™d like to learn how to publish your own TypeScript library, check out the
lesson:
[Publishing a TypeScript Library](https://www.code-like-a-journalist.com/en/ninja-moves/publishing-library).
```

In our `deno.json`, let's update the version. Since this is a tiny change, I would suggest updating to `0.1.1`.

```json showLineNumbers filename="deno.json" /"0.1.1"/
{
  "tasks": {
    "test-publish": "deno fmt && deno check index.ts && deno test && deno publish"
  },
  "name": "@nshiab/my-first-library",
  "version": "0.1.1",
  "license": "MIT",
  "exports": "./index.ts",
  "imports": {
    "@std/assert": "jsr:@std/assert@^1.0.12"
  }
}
```

And now we use our new task `test-publish` to republish our library:
`deno task test-publish`.

You can see that the checks and tests are run before publishing now! ðŸ¥³

![Testing and publishing a new version.](/assets/ninja-moves/publishing-library/test-publish.png)

Approve the publication like before and after a few seconds, you'll your library page updated with the content of your `README`!

You can also see that the latest version is now `0.1.1`.

![New version published.](/assets/ninja-moves/publishing-library/new-version.png)

## Updating to a new version in a project

A new version of our library has been published! It's time to update the project using it.

To be totally honest, we wouldn't need to REALLY update in a real case scenario... It's just the README that has been added! But I want to show you how to easily update dependencies. ðŸ¤“

In the project using the library, run `deno outdated`. Deno will check all JSR and NPM library versions used in your project and let you know if you are behind any.

Here's a description of the columns:
- `Current` is the version installed in your project
- `Update` is the version Deno suggests to install. It might not be the latest if you used `^` or `~` for the range of acceptable versions in your `deno.json`. Check the [Understanding library versions](/ninja-moves/semver) lesson for more.
- `Latest` is the latest available version.

![Outdated library.](/assets/ninja-moves/publishing-library/outdated.png)

If you want to update your library, you could do it manually with `deno add jsr:@nshiab/my-first-library@0.1.1`.

But when you have a lot of libraries to update, you can run the suggested deno commands to do all of them at once: `deno outdated --update`.

And done! We just updated and we are now using our new version!

![Updated library.](/assets/ninja-moves/publishing-library/deno-update.png)

## Advanced configuration

We used the default JSR settings for our library, but there are some options available if you click on the `Settings` tab.

In the settings, you can add more information about your library, like a short description for anyone using JSR search engine. Note that can also make it unlisted, so it won't be discoverable with the search engine. You can also select on which runtime you have tested your library (Deno, Node.js, Bun, etc.).

If your library is outdated, broken, and you don't want to maintain it anymore, you can archive it.

![Library settings.](/assets/ninja-moves/publishing-library/settings.png)

There is also an option to link the library to a GitHub repository. Doing so enables the possibility of automatically publishing your library with GitHub Actions.

It involves a bit more configuration, but it could be interesting if you plan on updating your library a lot and want to automate things.

If you would like to go down that route, doing these lessons first will be helpful:
- [How to use GitHub?](/git-and-github/github-basics)
- [How to use GitHub actions?](/git-and-github/github-actions)

For example, here's my workflow to publish a new version of the [Simple-Data-Analysis](https://github.com/nshiab/simple-data-analysis) library:
1. I create a [new issue](https://github.com/nshiab/simple-data-analysis/issues) when there is a bug to fix or when I want to add a new feature.
2. From the issue, I create a branch and work on the branch. I make sure to add new [tests](https://github.com/nshiab/simple-data-analysis/tree/main/test/unit/methods) to cover the bug fix or the new features.
3. I create a pull request to merge the branch with main. I have a [GitHub Actions workflow](https://github.com/nshiab/simple-data-analysis/blob/main/.github/workflows/all-tests.yml) to run the tests. If all the checks and tests pass, the pull request is accepted and brings the new code to main.
4. When ready, I run one of the `patch`, `minor` or `major` tasks I created in the [`deno.json`](https://github.com/nshiab/simple-data-analysis/blob/d3eb64f34fdc93c6cbbe0c65914f31ac8be1f36f/deno.json#L11-L13).
5. These tasks run a script called [`incrementVersion.ts`](https://github.com/nshiab/simple-data-analysis/blob/main/src/incrementVersion.ts) that updates automatically the version number in the `deno.json` and creates a [Git tag](https://git-scm.com/book/en/v2/Git-Basics-Tagging) with the version.
6. When a new tag is pushed to GitHub, two workflows get triggered: [one to publish](https://github.com/nshiab/simple-data-analysis/blob/main/.github/workflows/publish.yml) the new version of the library on JSR and another to [create a release](https://github.com/nshiab/simple-data-analysis/blob/main/.github/workflows/release.yml) on GitHub with a list of all the changes pulled directly from the approved pull requests.

I like this workflow because it keeps everything in sync, saves me from a lot of typing and create easy to read and useful releases. Here's the most recent, for example, at the time of writing.

![Release.](/assets/ninja-moves/publishing-library/release.png)

Publishing to JSR directly from GitHub also certifies the provenance of the library, which will increase the score of the library.

To be honest, the score is not that important. It's just to enforce best practices. If you plan to be the only user of your library, don't worry too much about it. And maybe just manually publishing is enough for you!

![The library score.](/assets/ninja-moves/publishing-library/score.png)

## Conclusion

Publishing a TypeScript library has never been easier. Before moving all my libraries to JSR, I had them published on NPM.

NPM is truly amazing, with millions upon millions of open-source libraries available to anyone. It's a big factor behind the success of JavaScript and TypeScript as programming languages. But publishing on is more difficult and convoluted.

With Deno and JSR, you can write, test, document and publish libraries with a minimal and very efficient setup. So stop copying and pasting code and publish your library! ðŸ˜Ž

<NoticeEnd />
