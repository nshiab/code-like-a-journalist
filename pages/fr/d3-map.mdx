---
title: Cartes anim√©es avec D3.js üó∫Ô∏è
description: Dans ce projet, nous utilisons des donn√©es sismiques pour cr√©er une carte anim√©e avec D3.js
---

import { Callout } from "nextra/components";
import { NoticeIntro, NoticeEnd } from "../../components/Notices.jsx";

# Cartes anim√©es avec D3.js üó∫Ô∏è

Comme nous l‚Äôavons vu dans la [le√ßon pr√©c√©dente](/d3-chart), [D3.js](https://d3js.org/) est une librairie formidable pour cr√©er des graphiques. Mais elle excelle aussi dans la cr√©ation de cartes.

Dans ce projet, nous allons utiliser des donn√©es sismiques pour cr√©er une carte anim√©e avec D3 et Svelte, comme illustr√© ci-dessous. Je vous recommande fortement de compl√©ter les sections pr√©c√©dentes du cours avant de vous lancer, en particulier [Graphiques anim√©s avec D3.js üßë‚Äçüé®](/d3-chart).

![Animation de d√©monstration d‚Äôun tremblement de terre anim√© sur une carte cr√©√©e avec D3 et Svelte.](/assets/d3-map/demo-earthquakes.gif)

<NoticeIntro lang="fr" />

## Configuration

Nous allons utiliser [setup-sda](https://github.com/nshiab/setup-sda) pour configurer et installer tout ce dont nous avons besoin.

Ouvrez un nouveau dossier avec VS Code et lancez `deno -A jsr:@nshiab/setup-sda --svelte`.

![Capture d‚Äô√©cran de VS Code apr√®s l‚Äôex√©cution de la librairie setup-sda.](/assets/d3-map/setup.png)

## Donn√©es sismiques et fronti√®res des pays

Pour r√©cup√©rer les donn√©es sismiques, j‚Äôai utilis√© le [catalogue des tremblements de terre de l‚ÄôUSGS](https://earthquake.usgs.gov/earthquakes/search/). Comme l‚Äôann√©e 2021 s‚Äôest r√©v√©l√©e tr√®s active, j‚Äôai t√©l√©charg√© deux fichiers CSV pour cette ann√©e et les ai t√©l√©vers√©s sur GitHub. Ce sont les m√™mes donn√©es que dans le [projet D3 pr√©c√©dent](/d3-chart).

Pour les fronti√®res des pays, je les ai t√©l√©charg√©es depuis [Natural Earth](https://www.naturalearthdata.com/) sous forme de shapefile compress√©.

En utilisant la librairie Simple Data Analysis dans le dossier `sda`, nous pouvons facilement les r√©cup√©rer et les mettre en cache. Mettez √† jour `sda/main.ts`, puis ex√©cutez `deno task sda` pour lancer et surveiller le script.

Pour les tremblements de terre :
- Nous gardons uniquement les lignes dont le `type` est `earthquake` et le `status` est `reviewed`.
- Nous filtrons les s√©ismes de magnitude inf√©rieure √† 5.
- Comme nous allons dessiner des cercles sur notre carte, il est plus int√©ressant d‚Äôutiliser l‚Äôamplitude, que l‚Äôon peut facilement calculer √† partir de la magnitude.
- Nous renommons `latitude` et `longitude` avec des noms plus courts.
- Nous conservons uniquement les colonnes utiles : `time`, `ampl`, `lat` et `lon`.
- Nous arrondissons les valeurs num√©riques √† trois d√©cimales.
- Sur notre carte, nous voulons que les tremblements de terre les plus puissants apparaissent au-dessus des plus faibles. Nous trions donc les donn√©es par `ampl` de fa√ßon croissante, car D3 dessine les √©l√©ments dans l‚Äôordre o√π ils apparaissent dans les donn√©es.
- Apr√®s avoir affich√© un aper√ßu de la table pour v√©rifier que tout est en ordre, nous √©crivons les donn√©es dans un fichier JSON dans le dossier `src` (et non `sda`) pour les utiliser dans notre projet Svelte. Comme ce sont juste des points, il est plus simple de garder ces donn√©es sous forme tabulaire. Nous avons plus de 2 000 tremblements de terre √† dessiner et animer sur la carte.

Pour les pays :
- Lors du chargement avec `loadDataGeo`, nous nous assurons de reprojeter les donn√©es au format `WGS84`.
- Nous s√©lectionnons uniquement la colonne `geom`, car nous n‚Äôavons besoin que des fronti√®res.
- Apr√®s avoir v√©rifi√© les donn√©es dans la console, nous √©crivons un fichier GeoJSON dans le dossier `src` (et non `sda`) √† utiliser dans notre projet Svelte. Ici, nous utilisons `writeGeoData` √† la place de `writeData`, en passant l‚Äôoption `rewind` pour que les coordonn√©es soient dans le bon ordre et que D3 puisse dessiner correctement les polygones. Nous avons 127 entit√©s g√©ographiques que nous allons ajouter √† notre carte.

```ts showLineNumbers filename="sda/main.ts"
import { SimpleDB } from "@nshiab/simple-data-analysis";

const sdb = new SimpleDB();

const earthquakes = sdb.newTable("earthquakes");
await earthquakes.cache(async () => {
  await earthquakes.loadData([
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-1.csv",
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-2.csv",
  ]);
});

await earthquakes.keep({
  "type": "earthquake",
  "status": "reviewed",
});
await earthquakes.filter(`mag >= 5`);
await earthquakes.addColumn("ampl", "number", `POW(10, mag)`);
await earthquakes.renameColumns({ latitude: "lat", longitude: "lon" });
await earthquakes.selectColumns([
  "time",
  "ampl",
  "lat",
  "lon",
]);
await earthquakes.round(["ampl", "lat", "lon"], { decimals: 3 });
await earthquakes.removeDuplicates();
await earthquakes.sort({ ampl: "asc" });
await earthquakes.logTable();
await earthquakes.writeData("src/data/earthquakes.json");

const countries = sdb.newTable("countries");
await countries.cache(async () => {
  await countries.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/ne_110m_land.shp.zip",
    { toWGS84: true },
  );
});
await countries.selectColumns("geom");
await countries.logTable();
await countries.writeGeoData("src/data/countries.json", { rewind: true });

await sdb.done();
```
![Capture d‚Äô√©cran de VS Code avec des tables de donn√©es affich√©es dans le terminal.](/assets/d3-map/data.png)

## Dataviz exploratoire

Avant de plonger dans le code D3, j‚Äôutilise toujours SDA et [Plot](https://observablehq.com/plot/) pour tracer rapidement une premi√®re dataviz. Cela aide √† mieux comprendre les donn√©es que l‚Äôon a en main.

Comme nous avons des donn√©es pour le monde entier, nous pouvons essayer la projection [`equal-earth`](https://www.researchgate.net/publication/326879978_The_Equal_Earth_map_projection), qui est √©galement disponible dans D3. (Plus de d√©tails sur les projections un peu plus bas.)

Voici une explication pas √† pas du nouveau code ci-dessous :
- Nous clonons la table des tremblements de terre.
- Nous cr√©ons des g√©om√©tries de points √† partir des colonnes `lat` et `lon`, dans une nouvelle colonne `geom`.
- Nous ins√©rons la table des pays, qui contient d√©j√† une colonne `geom`.
- Nous utilisons la m√©thode `writeMap` avec Plot pour exporter une carte au format PNG.
- Nous ajoutons `sphere()` et `graticule()` pour rendre la carte plus lisible avec la projection `equal-earth`.
- Nous dessinons d‚Äôabord les pays.
- Puis nous dessinons les tremblements de terre, en utilisant leurs valeurs `ampl`.


```ts showLineNumbers filename="sda/main.ts" {2, 44-65}
import { SimpleDB } from "@nshiab/simple-data-analysis";
import { geo, graticule, plot, sphere } from "@observablehq/plot";

const sdb = new SimpleDB();

const earthquakes = sdb.newTable("earthquakes");
await earthquakes.cache(async () => {
  await earthquakes.loadData([
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-1.csv",
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/earthquakes-2021-2.csv",
  ]);
});

await earthquakes.keep({
  "type": "earthquake",
  "status": "reviewed",
});
await earthquakes.filter(`mag >= 5`);
await earthquakes.addColumn("ampl", "number", `POW(10, mag)`);
await earthquakes.renameColumns({ latitude: "lat", longitude: "lon" });
await earthquakes.selectColumns([
  "time",
  "ampl",
  "lat",
  "lon",
]);
await earthquakes.round(["ampl", "lat", "lon"], { decimals: 3 });
await earthquakes.removeDuplicates();
await earthquakes.sort({ ampl: "asc" });
await earthquakes.logTable();
await earthquakes.writeData("src/data/earthquakes.json");

const countries = sdb.newTable("countries");
await countries.cache(async () => {
  await countries.loadGeoData(
    "https://raw.githubusercontent.com/nshiab/data-fetch-lesson/refs/heads/main/ne_110m_land.shp.zip",
    { toWGS84: true },
  );
});
await countries.selectColumns("geom");
await countries.logTable();
await countries.writeGeoData("src/data/countries.json", { rewind: true });

const earthquakesAndCountries = await earthquakes.cloneTable({
  outputTable: "earthquakesAndCountries",
});
await earthquakesAndCountries.points("lat", "lon", "geom");
await earthquakesAndCountries.insertTables(countries);
await earthquakesAndCountries.writeMap((geodata) =>
  plot({
    projection: "equal-earth",
    marks: [
      sphere(),
      graticule(),
      geo(geodata.features.filter((d) => !d.properties.ampl)),
      geo(
        geodata.features.filter((d) => typeof d.properties.ampl === "number"),
        {
          r: "ampl",
          fill: "red",
          opacity: 0.5,
        },
      ),
    ],
  }), "sda/output/earthquakesAndCountries.png");

await sdb.done();
```
![Capture d‚Äô√©cran de VS Code avec une carte affich√©e.](/assets/d3-map/plot-map.png)

Tout semble bien se passer ! Nous pouvons maintenant plonger dans notre projet Svelte.

## Composant Svelte

Cr√©ons un nouveau composant Svelte avec une fonction utilitaire pour notre carte.

Mais avant cela, il est toujours utile de d√©finir quelques types que nous utiliserons √† plusieurs reprises. Dans `src/lib/index.ts`, nous pouvons placer des types et des variables qui seront facilement accessibles dans l‚Äôensemble de notre projet Svelte.


```ts showLineNumbers filename="src/lib/index.ts"
type earthquake = {
  time: Date;
  lat: number;
  lon: number;
  ampl: number;
};

export type { earthquake };
```

Cr√©ons maintenant la fonction utilitaire `drawMap.ts` dans le dossier `src/helpers` (et non dans `sda`, encore une fois). C‚Äôest ici que notre code D3 va vivre. Cette fonction aura besoin de quelques √©l√©ments :
- Un `id`, qui correspondra √† l‚Äô`id` de l‚Äô√©l√©ment `svg` dans lequel nous dessinerons la carte.
- Les donn√©es des `earthquakes` (tremblements de terre).
- La `width` et la `height` (largeur et hauteur) de la carte.

Pour l‚Äôinstant, contentons-nous d'afficher les param√®tres dans la console.

√Ä noter que comme nous avons utilis√© `src/lib/index.ts`, nous pouvons facilement importer nos types (et tout autre √©l√©ment que nous y aurons plac√©) avec `from $lib`. C‚Äôest un raccourci bien pratique !

```ts showLineNumbers filename="src/helpers/drawMap.ts"
import type { earthquake } from "$lib";

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
) {
  console.log({ id, earthquakes, width, height });
}
```

Nous pouvons maintenant cr√©er un nouveau composant `Map.svelte` qui :

- Importe les donn√©es de `earthquakes.json` sous le nom `earthquakesRaw` (ligne 2), puis les parcourt pour convertir les valeurs de `time` en objets `Date` (lignes 7‚Äì10).
- R√©cup√®re l‚Äô`id` depuis les `props` (ligne 5).
- Cr√©e des √©tats `width` et `height` (lignes 12‚Äì13) et les lie aux propri√©t√©s `clientWidth` et `clientHeight` de l‚Äô√©l√©ment `svg` dans lequel nous allons dessiner notre carte (ligne 21). Nous parlerons plus en d√©tail des √©l√©ments `svg` un peu plus tard.
- Utilise la [rune `$effect`](https://svelte.dev/docs/svelte/$effect) pour appeler `drawMap` avec toutes les props et √©tats. Cela signifie que Svelte rappellera `drawMap` √† chaque fois qu‚Äôun des arguments change, y compris `width` et `height`, rendant la carte responsive.
- Pour conserver un ratio constant pour notre carte, nous encapsulons le `svg` dans une `div` et utilisons des balises `style` pour fixer la largeur de la `div` √† `100%` et le ratio du `svg` √† `16/9`.

```svelte showLineNumbers filename="src/components/Map.svelte"
<script lang="ts">
    import earthquakesRaw from "../data/earthquakes.json";
    import drawMap from "../helpers/drawMap";

    const { id }: { id: string } = $props();

    const earthquakes = earthquakesRaw.map((d) => ({
        ...d,
        time: new Date(d.time),
    }));

    let width = $state(0);
    let height = $state(0);

    $effect(() => {
        drawMap(id, earthquakes, width, height);
    });
</script>

<div>
    <svg {id} bind:clientWidth={width} bind:clientHeight={height}></svg>
</div>

<style>
    div {
        width: 100%;
    }
    svg {
        aspect-ratio: 16/9;
    }
</style>
```

Et enfin, nous pouvons importer notre nouveau composant `<Map />` dans notre page, situ√©e dans `src/routes/+page.svelte`. Nous lui attribuons un `id` appropri√©. Tant qu‚Äô√† faire, nous pouvons aussi mettre √† jour le texte de la page.

Si vous √©tiez encore en train de surveiller `sda/main.ts` dans votre terminal, vous pouvez arr√™ter le processus (`CTRL + C`) et lancer √† la place `deno task dev` pour d√©marrer un serveur local. Ouvrez ensuite l‚ÄôURL affich√©e dans votre terminal dans votre navigateur pr√©f√©r√©.

Dans la console de votre navigateur, vous devriez voir le message provenant de `drawMap.ts`. On est pr√™t √† coder notre carte !

```svelte showLineNumbers filename="src/routes/+page.svelte"
<script lang="ts">
    import Map from "../components/Map.svelte";
</script>

<h1>Earthquakes</h1>
<p>
    The data used below includes only earthquakes with a magnitude of 5 or more
    that occurred in 2021.
</p>
<Map id="earthquakes" />
```

![VS Code avec un projet Svelte en cours d‚Äôex√©cution localement.](/assets/d3-map/map-component.png)

## Dessiner une carte avec D3

Passons maintenant √† D3 !

Arr√™tez votre serveur local (`CTRL + C`) et installez D3 avec la commande `deno add npm:d3`. Ensuite, relancez le serveur local avec `deno task dev`.

Dans la le√ßon pr√©c√©dente, nous avons appris que les `scales` de D3 permettent de convertir des valeurs de donn√©es en valeurs de pixels, en couleurs, etc.

Quand on travaille avec des cartes, il faut faire la m√™me chose pour les coordonn√©es g√©ographiques (latitude et longitude) : les convertir en pixels. Mais‚Ä¶ il y a un hic. La Terre est ronde, alors que nos √©crans (et les cartes papier) sont plats !

C‚Äôest pour cette raison que les cartographes ont invent√© les **projections**, qui sont un peu comme des `scales`, mais pour les cartes. Chaque projection, avec ses calculs math√©matiques, a ses avantages et ses inconv√©nients. Par exemple, la [projection de Mercator](https://fr.wikipedia.org/wiki/Projection_de_Mercator) ‚Äî probablement la plus connue ‚Äî est id√©ale pour la navigation car elle pr√©serve les directions, mais elle d√©forme les distances et les surfaces dans les r√©gions proches des p√¥les.

Une des raisons pour lesquelles D3 est excellent pour les cartes, c‚Äôest qu‚Äôil donne acc√®s tr√®s facilement √† [√©norm√©ment de projections](https://observablehq.com/@fil/d3-projections). Dans ce projet, nous allons utiliser la projection `geoEqualEarth()`, comme nous l‚Äôavons fait avec Plot au d√©but.

Mettons √† jour `drawMap.ts` pour l‚Äôutiliser. Voici ce que fait le nouveau code, √©tape par √©tape :
- Nous s√©lectionnons l‚Äô√©l√©ment `svg` dans lequel nous allons dessiner la carte, et nous supprimons tout contenu existant pour √©viter d‚Äôempiler les √©l√©ments √† chaque rendu (lignes 10‚Äì11).
- Nous cr√©ons une `sphere` qui repr√©sentera l‚Äôensemble de la carte (lignes 13‚Äì15). Elle n‚Äôa pas de coordonn√©es, et ce n‚Äôest pas un probl√®me ‚Äî D3 sait la g√©rer. Nous fournirons les coordonn√©es pour les autres √©l√©ments de la carte.
- Nous appelons la projection `geoEqualEarth` et utilisons la m√©thode `fitSize` pour adapter la carte √† la `width` et la `height` du `svg`. Nous lui passons aussi la `sphere` pour assurer un bon positionnement. Si nous voulions zoomer sur un pays, nous pourrions passer ce pays au lieu de la `sphere`. La projection est stock√©e dans la variable `projection`.
- Nous appelons `geoPath` et lui passons notre `projection`. Le r√©sultat, stock√© dans la variable `geoGenerator`, est une fonction capable de dessiner des formes √† partir des latitudes et longitudes.
- Nous ajoutons un √©l√©ment `path` au `svg`, qui repr√©sentera une forme.
- Dans la le√ßon pr√©c√©dente, nous avions utilis√© `.data()` pour lier un tableau d‚Äôobjets. Mais ici, comme nous n‚Äôavons qu‚Äôun seul √©l√©ment (`sphere`), nous utilisons `.datum()` √† la place.
- Nous d√©finissons l‚Äôattribut `d` (qui d√©crit la forme du `path`) √† l‚Äôaide de la fonction `geoGenerator`. Elle lit les donn√©es li√©es et les traduit en coordonn√©es ‚Äî ici, elle sert √† remplir l‚Äôarri√®re-plan de la carte.
- Enfin, nous d√©finissons d‚Äôautres attributs, comme la couleur de remplissage (`fill`).



```ts showLineNumbers filename="src/helpers/drawMap.ts" {10-25}
import type { earthquake } from "$lib";
import { geoEqualEarth, geoPath, select } from "d3";

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");
}
```

Si vous faites un clic droit sur la zone noire et que vous l‚Äôinspectez dans votre navigateur, vous verrez votre √©l√©ment `svg` contenant un `path`. Cet √©l√©ment `path` poss√®de un attribut `d` qui contient des coordonn√©es SVG g√©n√©r√©es par notre code !

![Une sph√®re cr√©√©e avec D3.](/assets/d3-map/sphere.png)

Pour rendre notre carte plus lisible, nous pouvons √©galement ajouter des [graticules](https://en.wikipedia.org/wiki/Graticule_(cartography)). La fonction `geoGraticule()` g√©n√®re un objet GeoJSON contenant les coordonn√©es des graticules.

Nous les pla√ßons apr√®s la sph√®re dans le code pour nous assurer qu‚Äôils seront dessin√©s au-dessus. Pour leur donner une apparence gris clair, nous les dessinons en blanc avec une opacit√© r√©duite.


```ts showLineNumbers filename="src/helpers/drawMap.ts" {2, 27-33}
import type { earthquake } from "$lib";
import { geoEqualEarth, geoGraticule, geoPath, select } from "d3";

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");

  svg
    .append("path")
    .datum(geoGraticule())
    .attr("d", geoGenerator)
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("opacity", 0.3);
}
```
![Graticules cr√©√©s avec D3.](/assets/d3-map/graticules.png)

C‚Äôest le bon moment pour ajouter les pays √† notre carte. Comme nous ne cherchons pas √† afficher les fronti√®res exactes, nous pouvons simplement les remplir en gris, sans contour.

Il y en a plus de 100, donc nous utilisons la syntaxe `.data(countries.features)` et `.join("path")` pour lier les donn√©es √† de nouveaux √©l√©ments `path`. Pour √©viter de s√©lectionner accidentellement des √©l√©ments pr√©c√©dents, nous utilisons `selectAll` avec la classe `.countries`, que nous d√©finissons comme attribut.

Nous utilisons `.features` dans `.data(countries.features)` parce que le fichier est √©crit au format GeoJSON, o√π toutes les entit√©s sont stock√©es dans une liste sous la cl√© `features`.


```ts showLineNumbers filename="src/helpers/drawMap.ts" {3, 36-41}
import type { earthquake } from "$lib";
import { geoEqualEarth, geoGraticule, geoPath, select } from "d3";
import countries from "../data/countries.json" with { type: "json" };

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");

  svg
    .append("path")
    .datum(geoGraticule())
    .attr("d", geoGenerator)
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("opacity", 0.3);

  svg.selectAll(".countries")
    .data(countries.features)
    .join("path")
    .attr("class", "countries")
    .attr("d", geoGenerator)
    .attr("fill", "grey");
}
```
![Pays sur une carte cr√©√©e avec D3.](/assets/d3-map/countries.png)

Il ne reste plus que les tremblements de terre √† ajouter !

Il y a quelques √©l√©ments √† prendre en compte pour bien les afficher :
- Nous utilisons la fonction `extent` pour r√©cup√©rer les valeurs minimale et maximale de `ampl` (lignes 51‚Äì54). Cette fonction retourne une liste du type `[min, max]`.
- Nous cr√©ons une √©chelle pour l‚Äôattribut `r` (lignes 56‚Äì58). Nous utilisons une √©chelle racine carr√©e (`scaleSqrt`) car nous voulons que *l'aire* du cercle soit proportionnelle aux donn√©es. Nous d√©finissons son domaine avec l‚Äôintervalle de `ampl`, et son intervalle de sortie entre 2 et 20 pixels de rayon.
- Nous cr√©ons une √©chelle de couleur, √©galement bas√©e sur l‚Äô√©tendue de `ampl`, allant du jaune au rouge (lignes 60‚Äì61).

Une fois les √©chelles en place et la projection d√©finie, nous pouvons cr√©er les cercles repr√©sentant les tremblements de terre. Pour `cx` et `cy`, nous passons `lon` et `lat` (dans cet ordre) √† la `projection`. Elle retourne les coordonn√©es en pixels sous forme de `[x, y]`, que nous utilisons pour positionner les cercles sur la carte.


```ts showLineNumbers filename="src/helpers/drawMap.ts" {3, 7, 8, 51-69}
import type { earthquake } from "$lib";
import {
  extent,
  geoEqualEarth,
  geoGraticule,
  geoPath,
  scaleLinear,
  scaleSqrt,
  select,
} from "d3";
import countries from "../data/countries.json" with { type: "json" };

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");

  svg
    .append("path")
    .datum(geoGraticule())
    .attr("d", geoGenerator)
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("opacity", 0.3);

  svg.selectAll(".countries")
    .data(countries.features)
    .join("path")
    .attr("class", "countries")
    .attr("d", geoGenerator)
    .attr("fill", "grey");

  const amplExtent = extent(
    earthquakes,
    (d: earthquake) => d.ampl,
  );

  const rScale = scaleSqrt()
    .domain(amplExtent)
    .range([2, 20]);

  const colorScale = scaleLinear().domain(amplExtent)
    .range(["yellow", "red"]);

  svg.selectAll("circle")
    .data(earthquakes)
    .join("circle")
    .attr("cx", (d: earthquake) => projection([d.lon, d.lat])[0])
    .attr("cy", (d: earthquake) => projection([d.lon, d.lat])[1])
    .attr("r", (d: earthquake) => rScale(d.ampl))
    .attr("fill", (d: earthquake) => colorScale(d.ampl));
}
```
![Tremblements de terre sur une carte cr√©√©e avec D3.](/assets/d3-map/earthquakes.png)

Regardez-moi √ßa ! N‚Äôest-ce pas magnifique ? Nous avons affich√© plus de 2 000 tremblements de terre sur une carte, avec les continents et les graticules, en utilisant une projection √©l√©gante ! ü•≥

## Animer une carte

Maintenant, comment peut-on animer cette carte ? Ce serait g√©nial de faire appara√Ætre les tremblements de terre au fil du temps.

Commen√ßons par cr√©er un `button` avec un √©tat appel√© `animate`. Lorsqu‚Äôon clique sur le bouton, on veut que cet √©tat bascule entre `true` et `false`. Et bien s√ªr, on transmet ce nouvel √©tat √† notre fonction `drawMap`.

La fonction `drawMap` aura √©galement besoin de deux constantes : `animationDuration` (10 secondes pour l‚Äôinstant) et `transitionDuration` (500 ms). Le premier d√©finit la dur√©e totale de l‚Äôanimation, tandis que le second contr√¥le la dur√©e de l‚Äôanimation de chaque cercle. Comme ces valeurs ne sont pas cens√©es changer, on peut simplement les d√©finir comme constantes.

On peut aussi d√©j√† pr√©voir un nouveau paragraphe qui affichera la date actuelle de l‚Äôanimation. On lui appliquera une propri√©t√© CSS `display: inline` pour qu‚Äôil apparaisse sur la m√™me ligne que le bouton.



```svelte showLineNumbers filename="src/components/Map.svelte" {15-17, 25-27, 32-37, 49-51}
<script lang="ts">
    import earthquakesRaw from "../data/earthquakes.json";
    import drawMap from "../helpers/drawMap";

    const { id }: { id: string } = $props();

    const earthquakes = earthquakesRaw.map((d) => ({
        ...d,
        time: new Date(d.time),
    }));

    let width = $state(0);
    let height = $state(0);

    let animate = $state(false);
    const animationDuration = 10000;
    const transitionDuration = 500;

    $effect(() => {
        drawMap(
            id,
            earthquakes,
            width,
            height,
            animate,
            animationDuration,
            transitionDuration,
        );
    });
</script>

<button
    onclick={() => {
        animate = !animate;
    }}>{animate ? "Stop ‚èπ" : "Play ‚èµ"}</button
>
<p id={`${id}-date`}></p>
<div>
    <svg {id} bind:clientWidth={width} bind:clientHeight={height}></svg>
</div>

<style>
    div {
        width: 100%;
    }
    svg {
        aspect-ratio: 16/9;
    }
    p {
        display: inline;
    }
</style>
```

Nous pouvons maintenant travailler sur notre fonction `drawMap`. R√©cup√©rons le nouveau param√®tre `animate` et utilisons-le. Si `animate` est √† `true`, on dessine les tremblements de terre. Sinon, on ne les affiche pas.

Nous utiliserons `animationDuration` et `transitionDuration` un peu plus tard.


```ts showLineNumbers filename="src/helpers/drawMap.ts" {18-20, 54, 74}
import type { earthquake } from "$lib";
import {
  extent,
  geoEqualEarth,
  geoGraticule,
  geoPath,
  scaleLinear,
  scaleSqrt,
  select,
} from "d3";
import countries from "../data/countries.json" with { type: "json" };

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
  animate: boolean,
  animationDuration: number,
  transitionDuration: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");

  svg
    .append("path")
    .datum(geoGraticule())
    .attr("d", geoGenerator)
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("opacity", 0.3);

  svg.selectAll(".countries")
    .data(countries.features)
    .join("path")
    .attr("class", "countries")
    .attr("d", geoGenerator)
    .attr("fill", "grey");

  if (animate) {
    const amplExtent = extent(
      earthquakes,
      (d: earthquake) => d.ampl,
    );

    const rScale = scaleSqrt()
      .domain(amplExtent)
      .range([2, 20]);

    const colorScale = scaleLinear().domain(amplExtent)
      .range(["yellow", "red"]);

    svg.selectAll("circle")
      .data(earthquakes)
      .join("circle")
      .attr("cx", (d: earthquake) => projection([d.lon, d.lat])[0])
      .attr("cy", (d: earthquake) => projection([d.lon, d.lat])[1])
      .attr("r", (d: earthquake) => rScale(d.ampl))
      .attr("fill", (d: earthquake) => colorScale(d.ampl));
  }
}
```

C‚Äô√©tait facile ‚Äî et on est sur la bonne voie ! On peut maintenant se concentrer sur la cr√©ation d‚Äôune animation avec D3.

![Activation/d√©sactivation des tremblements de terre sur une carte cr√©√©e avec D3.](/assets/d3-map/start-stop.gif)

Une fa√ßon de faire appara√Ætre des √©l√©ments les uns apr√®s les autres avec D3, c‚Äôest d‚Äôutiliser `.transition()` avec `.delay()`. On pourrait commencer par dessiner les cercles avec un `r` de `0`, puis leur appliquer un d√©lai bas√© sur leur valeur `time`. Une fois le d√©lai √©coul√©, on utiliserait √† nouveau `.transition()` pour augmenter leur `r` √† la taille voulue.

Si vous voulez en savoir plus sur les transitions D3, pensez √† consulter la le√ßon pr√©c√©dente : [Graphiques anim√©s avec D3.js üßë‚Äçüé®](/d3-chart)

Et comment calculer le bon d√©lai pour chaque cercle ? Gr√¢ce √† une √©chelle, bien s√ªr !

Passons au code !


```ts showLineNumbers filename="src/helpers/drawMap.ts" {67-72, 80-84}
import type { earthquake } from "$lib";
import {
  extent,
  geoEqualEarth,
  geoGraticule,
  geoPath,
  scaleLinear,
  scaleSqrt,
  select,
} from "d3";
import countries from "../data/countries.json" with { type: "json" };

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
  animate: boolean,
  animationDuration: number,
  transitionDuration: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");

  svg
    .append("path")
    .datum(geoGraticule())
    .attr("d", geoGenerator)
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("opacity", 0.3);

  svg.selectAll(".countries")
    .data(countries.features)
    .join("path")
    .attr("class", "countries")
    .attr("d", geoGenerator)
    .attr("fill", "grey");

  if (animate) {
    const amplExtent = extent(
      earthquakes,
      (d: earthquake) => d.ampl,
    );

    const rScale = scaleSqrt()
      .domain(amplExtent)
      .range([2, 20]);

    const colorScale = scaleLinear().domain(amplExtent)
      .range(["yellow", "red"]);

    const timeExtent = extent(
      earthquakes,
      (d: earthquake) => d.time,
    );
    const delayScale = scaleLinear().domain(timeExtent)
      .range([0, animationDuration]);

    svg.selectAll("circle")
      .data(earthquakes)
      .join("circle")
      .attr("cx", (d: earthquake) => projection([d.lon, d.lat])[0])
      .attr("cy", (d: earthquake) => projection([d.lon, d.lat])[1])
      .attr("fill", (d: earthquake) => colorScale(d.ampl))
      .attr("r", 0)
      .transition()
      .duration(transitionDuration)
      .delay((d: earthquake) => delayScale(d.time))
      .attr("r", (d: earthquake) => rScale(d.ampl));
  }
}
```

Et voil√† ! Nous avons anim√© nos tremblements de terre ! Mais ce serait encore mieux s‚Äôils grossissaient puis disparaissaient.

![Tremblements de terre anim√©s sur une carte cr√©√©e avec D3.](/assets/d3-map/first-play.gif)

Ajoutons donc une autre transition : apr√®s avoir grossi, les cercles reviendront √† un `r` de `0`.

On peut √©galement mettre √† jour le paragraphe que nous avions cr√©√© plus t√¥t pour y afficher la date actuelle de l‚Äôanimation. Pour cela, on utilise la fonction globale `setInterval`, qui ex√©cute une fonction √† intervalle r√©gulier. Ici, toutes les 100‚ÄØms, on utilise la m√©thode `.invert()` de notre `delayScale` pour obtenir une valeur de temps correspondante. On formate ensuite cette valeur avec la fonction `formatDate` de la [librairie journalism](https://jsr.io/@nshiab/journalism), que je maintiens. Enfin, on ins√®re cette date format√©e dans le paragraphe.

Pour √©viter que le `setInterval` ne tourne ind√©finiment, on stocke son `intervalId`. Une fois que l‚Äôanimation a dur√© plus longtemps que sa dur√©e totale, on l‚Äôarr√™te avec `clearInterval(intervalId)`. On retourne aussi le `intervalId` pour pouvoir l‚Äôutiliser dans notre composant `<Map />`. On y reviendra dans un instant.



```ts showLineNumbers filename="src/helpers/drawMap.ts" {86-88, 90-108}
import type { earthquake } from "$lib";
import {
  extent,
  geoEqualEarth,
  geoGraticule,
  geoPath,
  scaleLinear,
  scaleSqrt,
  select,
} from "d3";
import { formatDate } from "@nshiab/journalism/web";
import countries from "../data/countries.json" with { type: "json" };

export default function drawMap(
  id: string,
  earthquakes: earthquake[],
  width: number,
  height: number,
  animate: boolean,
  animationDuration: number,
  transitionDuration: number,
) {
  const svg = select(`#${id}`);
  svg.selectAll("*").remove();

  const sphere = {
    type: "Sphere",
  };
  const projection = geoEqualEarth()
    .fitSize([width, height], sphere);

  const geoGenerator = geoPath().projection(projection);

  svg
    .append("path")
    .datum(sphere)
    .attr("d", geoGenerator)
    .attr("fill", "black");

  svg
    .append("path")
    .datum(geoGraticule())
    .attr("d", geoGenerator)
    .attr("fill", "none")
    .attr("stroke", "white")
    .attr("opacity", 0.3);

  svg.selectAll(".countries")
    .data(countries.features)
    .join("path")
    .attr("class", "countries")
    .attr("d", geoGenerator)
    .attr("fill", "grey");

  if (animate) {
    const amplExtent = extent(
      earthquakes,
      (d: earthquake) => d.ampl,
    );

    const rScale = scaleSqrt()
      .domain(amplExtent)
      .range([2, 20]);

    const colorScale = scaleLinear().domain(amplExtent)
      .range(["yellow", "red"]);

    const timeExtent = extent(
      earthquakes,
      (d: earthquake) => d.time,
    );
    const delayScale = scaleLinear().domain(timeExtent)
      .range([0, animationDuration]);

    svg.selectAll("circle")
      .data(earthquakes)
      .join("circle")
      .attr("cx", (d: earthquake) => projection([d.lon, d.lat])[0])
      .attr("cy", (d: earthquake) => projection([d.lon, d.lat])[1])
      .attr("fill", (d: earthquake) => colorScale(d.ampl))
      .attr("r", 0)
      .transition()
      .duration(transitionDuration)
      .delay((d: earthquake) => delayScale(d.time))
      .attr("r", (d: earthquake) => rScale(d.ampl))
      .transition()
      .duration(transitionDuration)
      .attr("r", 0);

    const dateParagraph = document.querySelector(`#${id}-date`);
    if (dateParagraph) {
      const interval = 100;
      let duration = 0;
      const intervalId = setInterval(() => {
        if (duration > animationDuration) {
          clearInterval(intervalId);
        } else {
          const date = new Date(delayScale.invert(duration));
          dateParagraph.innerHTML = formatDate(
            date,
            "YYYY-MM-DD",
            { utc: true },
          );
          duration += interval;
        }
      }, interval);
      return intervalId;
    }
  }
}
```

On y est presque ! Mais il reste encore √† g√©rer le bouton et le paragraphe de date une fois l‚Äôanimation termin√©e.

![Tremblements de terre anim√©s apparaissant et disparaissant sur une carte cr√©√©e avec D3.](/assets/d3-map/animating-circles.gif)

On peut ajuster notre `$effect` dans le composant `<Map />` pour corriger les derniers d√©tails.

D‚Äôabord, on r√©cup√®re le `intervalId` depuis `drawMap`. On cr√©e aussi un `setTimeout`, qui d√©clenche une fonction apr√®s un certain temps. Dans ce cas, si `animationDuration + transitionDuration` est √©coul√©, cela signifie que le dernier cercle a termin√© son animation. On peut alors repasser l‚Äô√©tat `animate` √† `false`, ce qui met √† jour le texte du bouton. On efface aussi le contenu du paragraphe de date.

Mais attention: lorsqu‚Äôon travaille avec des √©v√©nements ou des minuteries, il est important de se rappeler qu‚Äôil faut **les nettoyer manuellement**. Par exemple, que se passe-t-il si un utilisateur clique plusieurs fois sur le bouton ? Tel quel, cela cr√©erait plusieurs appels √† `setInterval`, et le paragraphe de date serait mis √† jour de mani√®re chaotique !

C‚Äôest pourquoi, √† la fin du `$effect`, on ajoute une fonction de nettoyage. Cette fonction est appel√©e **avant** que l‚Äôeffet ne soit r√©ex√©cut√© ‚Äî parfait pour annuler les pr√©c√©dents `setInterval` et `setTimeout` avant d‚Äôen d√©marrer de nouveaux.


```ts showLineNumbers filename="src/components/Map.svelte" {20, 30-36, 38-41}
<script lang="ts">
    import earthquakesRaw from "../data/earthquakes.json";
    import drawMap from "../helpers/drawMap";

    const { id }: { id: string } = $props();

    const earthquakes = earthquakesRaw.map((d) => ({
        ...d,
        time: new Date(d.time),
    }));

    let width = $state(0);
    let height = $state(0);

    let animate = $state(false);
    const animationDuration = 10000;
    const transitionDuration = 500;

    $effect(() => {
        const intervalId = drawMap(
            id,
            earthquakes,
            width,
            height,
            animate,
            animationDuration,
            transitionDuration,
        );

        const timeoutId = setTimeout(() => {
            animate = false;
            const dateParagraph = document.querySelector(`#${id}-date`);
            if (dateParagraph) {
                dateParagraph.textContent = "";
            }
        }, animationDuration + transitionDuration);

        return () => {
            clearInterval(intervalId);
            clearTimeout(timeoutId);
        };
    });
</script>

<button
    onclick={() => {
        animate = !animate;
    }}>{animate ? "Stop ‚èπ" : "Play ‚èµ"}</button
>
<p id={`${id}-date`}></p>
<div>
    <svg {id} bind:clientWidth={width} bind:clientHeight={height}></svg>
</div>

<style>
    div {
        width: 100%;
    }
    svg {
        aspect-ratio: 16/9;
    }
    p {
        display: inline;
    }
</style>
```

Et √ßa fonctioooooonne ! Une magnifique carte anim√©e des tremblements de terre, r√©alis√©e avec D3.js et Svelte !

![Animation finale des tremblements de terre sur une carte cr√©√©e avec D3 et Svelte.](/assets/d3-map/final-animation.gif)

## G√©n√©rer la page

Jusqu‚Äô√† maintenant, nous avons ex√©cut√© notre page via un serveur local. Si vous souhaitez construire votre site web, lancez la commande `deno task build`. Svelte va alors minimiser et optimiser votre code, et g√©n√©rer les fichiers du site dans le dossier `build`. Vous pourrez ensuite h√©berger ces fichiers sur un serveur pour partager votre travail avec le monde entier !

## Conclusion

F√©licitations ! Vous avez cod√© une carte anim√©e fluide. Ce n‚Äô√©tait pas une mince affaire, mais vous √™tes all√© jusqu‚Äôau bout !

Si vous souhaitez explorer d‚Äôautres exemples avec D3, n‚Äôh√©sitez pas √† consulter la [galerie D3](https://observablehq.com/@d3/gallery), en particulier la [section Cartes](https://observablehq.com/@d3/gallery#maps). Tout le code y est en code ouvert !

J‚Äôesp√®re que cette le√ßon vous a plu, et j‚Äôai h√¢te de voir votre prochaine carte publi√©e sur le Web ! üòä

<NoticeEnd lang="fr" />
