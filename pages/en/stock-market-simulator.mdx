---
title: Stock market simulator üìà
description: Learn how to fetch stock market data and code a returns simulator with TypeScript.
---

import { Callout } from "nextra/components";
import { NoticeIntro, NoticeEnd } from "../../components/Notices.jsx"

# Stock market simulator üìà

Welcome to this new project! We are going to fetch historical stock market data and use it to estimate how much we would have gained or lost by investing in publicly traded companies.

Here's how the project will look like at the end. The screenshot below shows you the result of $1,000 invested in January 2020 in Apple, as of February 2025.

Note that I am expecting you finished the **First steps üßë‚Äçüéì** and **Pushing further üöÄ** sections before diving into this project. This project is meant to practise everything we've seen so far in this course.

![A VS Code screenshot showing a script simulating the stock market](/assets/stock-market-simulator/final-result.png)

<NoticeIntro />

## What's the question?

It's always important to clearly identify the question we want to answer before diving too fast into an ocean of data.

So, today, our question is:
- How much would have gain or lost by investing in a given publicly traded company at a specific date?

To answer this, we need to calculate the difference between the initial amount and the final amount.

We can also identify three variables that will impact the result:
- The choosen company
- The initial amount of money
- The data of the investment

With this in mind, let's start!

## Setup

Create a new folder with:
- A `main.ts` file with `console.log("Hello!");` in it.
- An empty `deno.json`.

And then run `deno -A --watch --check main.ts`.

![A VS Code screenshot showing a script logging "Hello!" to the terminal.](/assets/stock-market-simulator/setup.png)

## The data

### Yahoo Finance

To run our simulator, we need to feed it with the historical stock market prices. One of the most common data source for financial data is [Yahoo Finance](https://finance.yahoo.com/).

On the [home page](https://finance.yahoo.com/), you can search for a publicly traded company. For example, look for Apple and then click on the relevant result.

![A screenshot showing the Yahoo Finance website.](/assets/stock-market-simulator/search-apple.png)

You'll end up on the Apple stocks page. On the left side, click on *Historical data*.

![A screenshot showing the Yahoo Finance website.](/assets/stock-market-simulator/apple-page.png)

The data is now showed as a table and you can retrieve all of the data available since the company offers public stocks.

The columns that really interest us are the **Date** and the **Adj close** price.

![A screenshot showing the Yahoo Finance website.](/assets/stock-market-simulator/all-data.png)

That was easy! But how can we get this data in our script? ü§î

### Finding the data

This data doesn't come from nowhere. It probably comes from from an API providing the data to the page. Let's look behind the curtains to figure this out. üßê 

<Callout type="info" emoji="üí°">
    API stands for *Application Programming Interface*. On the web, APIs are often used as a way to transfer data. When you call an API endpoint (with an URL and sometimes parameters), the API sends you back the relevant data. APIs are very useful for websites displaying live data, among other things. Instead of rebuilding and republishing the website with new data, which can be slow and costly, you can just need to update your API endpoints. The APIs answers are often in JSON, but could also be in CSV, XML, and more.
</Callout>

Note that I will be using Google Chrome for the following steps, but you can do the same things with Firefox or Safari.

Open the *Developer tools* and click on the *Network* tab.

![A screenshot showing the Yahoo Finance website with the developer tools open.](/assets/stock-market-simulator/network.png)

This tab shows all requests made by the page. When the page loads, it needs all kind of ressources, like fonts, images, styles and... data! All these requests are shown here and you can explore them.

In our case, we are interested in the Apple stock market data that is displayed as a table on the webpage.

Refresh the page then select the **Max** option one more time to retrieve all of the available data. Then search for the request containing `AAPL`, which the symbol used for Apple on stock markets. It's also the symbol used in the page URL, so it's a good guess.

You'll notice one or more fetch requests starting with `AAPL`. This is very promising!

![A screenshot showing the Yahoo Finance website with the detailed network requests.](/assets/stock-market-simulator/appl-request.png)

Do a right click on one of them and open it in a new tab. Wow! Do you recognize this syntax? It's JSON! And it looks like a look of data. üòè

And if you look closer at the url, you'll notice that they are parameters like `symbol`, `interval`, `period1` and `period2`. There are also `region` and `lang` parameters that might be different for you, depending on your location.

`https://query1.finance.yahoo.com/v8/finance/chart/AAPL?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=345479400&period2=1738778777&symbol=AAPL&userYfid=true&lang=en-CA&region=CA`

Let's explore it more with code.

![A screenshot showing the Yahoo Finance API endpoint.](/assets/stock-market-simulator/raw-data.png)

### Fetching the data

Let's fetch the data coming from the API endpoint we just discovered. To do that, we can write a simple script like below.

```ts showLineNumbers filename="main.ts"
const response = await fetch(
  "https://query1.finance.yahoo.com/v8/finance/chart/AAPL?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=345479400&period2=1738778777&symbol=AAPL&userYfid=true&lang=en-CA&region=CA",
);

const data = await response.json();

console.log(data);
```

It's now a bit clearer what we have.

The data is a big nested object. The dates (timestamp) and the adjusted close prices (adjclose) are stored as arrays.

![A screenshot showing the Yahoo Finance data in VS Code terminal.](/assets/stock-market-simulator/raw-json.png)

To retrieve them, we can traverse the object.

To access the timestamps, we have to:
- get the `chart` object
- then get the `result` array
- then retrieve the first item of the array, which is an object
- in this object, we get the `timestamp` array.

It looks like this.

```ts
const timestamps = data.chart.result[0].timestamp;
```

To access the adjusted close prices, we have to:
- get the `chart` object
- then get the `result` array
- then retrieve the first item of the array, which is an object
- in this object, we get the `indicators` object
- then we get the `adjclose` array
- we get the first item of the array, which is an object
- in this object, we retrieve the `adjclose` values

It looks like this.

```ts
const values = data.chart.result[0].indicators.adjclose[0].adjclose;
```

Don't worry. JSON are not always this complicated on the Web. And after a few projects, the JSON structure will be crystal clear for you! üíé

```ts showLineNumbers filename="main.ts"
const response = await fetch(
  "https://query1.finance.yahoo.com/v8/finance/chart/AAPL?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=345479400&period2=1738778777&symbol=AAPL&userYfid=true&lang=en-CA&region=CA",
);

const data = await response.json();

const timestamps = data.chart.result[0].timestamp;
console.log(timestamps);

const values = data.chart.result[0].indicators.adjclose[0].adjclose;
console.log(values);
```
![A screenshot showing the timestamps and values in the terminal.](/assets/stock-market-simulator/timestamps-values.png)

To avoid filling up the terminal, Deno just logs the first 100 elements of arrays. But have you noticed that the timestamps and values arrays have the same number of elements?

This is a very good sign.

It probably means that the first element in the timestamps array (a date) matches the first element in the values array (an adjusted closing price).

Let's check the last elements to be sure.

Timestamps represent the duration since January 1st 1970. Here's it looks like its in seconds. But in JavaScript, it's in milliseconds. We can easily account for that.

```ts showLineNumbers filename="main.ts" {8, 11, 13}
const response = await fetch(
  "https://query1.finance.yahoo.com/v8/finance/chart/AAPL?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=345479400&period2=1738778777&symbol=AAPL&userYfid=true&lang=en-CA&region=CA",
);

const data = await response.json();

const timestamps = data.chart.result[0].timestamp;
const firstTimestamp = new Date(timestamps[0] * 1000);
const lastTimestamp = new Date(timestamps[timestamps.length - 1] * 1000);

const values = data.chart.result[0].indicators.adjclose[0].adjclose;
const firstValue = values[0];
const lastValue = values[values.length - 1];

console.log({ firstTimestamp, lastTimestamp, firstValue, lastValue });
```

This code logs these values.

```json
{
  firstTimestamp: 1980-12-12T14:30:00.000Z,
  lastTimestamp: 2025-02-05T14:30:00.000Z,
  firstValue: 0.09883447736501694,
  lastValue: 232.47000122070312
}
```

Apple indeed went public on December 12, 1980 with a share price of $0.10 according to [its website](https://investor.apple.com/faq/default.aspx#:~:text=When%20was%20Apple%E2%80%99s,was%20%24.10.) and the latest value correspond with what I am seeing on Yahoo's website as of February 5, 2025! We got our data! ü•≥



![A screenshot showing the Apple stock market value on Yahoo's website.](/assets/stock-market-simulator/latest-yahoo.png)

The current URL has parameters for Apple, but we will want our code to work with any company. So let's extract some parameters values as variables.

By using backticks, we can insert variables into the URL string. So instead of this:

`https://query1.finance.yahoo.com/v8/finance/chart/AAPL?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=345479400&period2=1738778777&symbol=AAPL&userYfid=true&lang=en-CA&region=CA`

We can make the call to the API general with `${symbol}`, `${period1}` and `${period2}`:

`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=${period1}&period2=${period2}&symbol=${symbol}&userYfid=true&lang=en-CA&region=CA`

For `period1`, we could set it to `0`, which means January 1st, 1970, because timestamps are the duration since January 1st, 1970. And for `period2`, we can use `Date.now()` which returns the number of milliseconds since January 1st, 1970, which should give us the latest data available.

```ts showLineNumbers filename="main.ts" {1-7}
const symbol = "AAPL";
const period1 = 0;
const period2 = Date.now();

const response = await fetch(
  `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=${period1}&period2=${period2}&symbol=${symbol}&userYfid=true&lang=en-CA&region=CA`,
);

const data = await response.json();

const timestamps = data.chart.result[0].timestamp;
const firstTimestamp = new Date(timestamps[0] * 1000);
const lastTimestamp = new Date(timestamps[timestamps.length - 1] * 1000);

const values = data.chart.result[0].indicators.adjclose[0].adjclose;
const firstValue = values[0];
const lastValue = values[values.length - 1];

console.log({ firstTimestamp, lastTimestamp, firstValue, lastValue });
```

This code still logs this data, which means the API accepts our more general parameters!

```json
{
  firstTimestamp: 1980-12-12T14:30:00.000Z,
  lastTimestamp: 2025-02-05T14:30:00.000Z,
  firstValue: 0.09883449226617813,
  lastValue: 232.47000122070312
}
```

By the way, this data gathering technique is called *web scraping*. The web is an amazing source of data and we'll do a full lesson about it later.

## Caching

Currently, everytime we update `main.ts` and save it, the code is bein rerun and the data is being refetched.

We don't want to submerge the Yahoo servers with our requests. We must respect their infrastructure. Also, we don't want to get blacklisted... ü´£ So let's cache the data.

Caching can mean different things in different context, but here it would just involve writing the data to a local file and use the local file instead of fetching the data all the time.

Basically, if the local file exists, we should use it. Otherwise, we should fetch the data.

To check whether the file already exists on our machine, we can use the `exists` function from the Deno's standard library [@std/fs](https://jsr.io/@std/fs/doc/~/exists) (*fs* stands for *file system*).

Stop your terminal and install it by running `deno add jsr:@std/fs`, then rewatch `main.ts` by running `deno -A --watch --check main.ts`.

Create a new folder `data` where we will cache the data.

The code below does the caching. Here's what's happening when you run it:
- On line 1, we import the `exists` function from the standard library
- On line 6, we use the `symbol` to create a path for the cached data
- On line 8, we create a `let` variable for the data.
- On line 9, we check if there is already a file for this company. If it's the case, we read the data from this file and put it inside the `data` variable (line 11).
- If the file doesn't exist, the data is not cached. We fetch it (line 14-18), parse it as JSON and put it inside the `data` variable (line 15). Then we cache it by writing a JSON file with the company `path`.
- By 21 and 22, the `data` variable contains data that has been read locally or fetched, so we can retrieve the timesamps and the values!

```ts showLineNumbers filename="main.ts"
import { exists } from "@std/fs";

const symbol = "AAPL";
const period1 = 0;
const period2 = Date.now();
const path = `data/${symbol}.json`;

let data;
if (await exists(path)) {
  console.log("=> Retrieving data from cache...");
  data = JSON.parse(await Deno.readTextFile(path));
} else {
  console.log("=> Fetching data...");
  const response = await fetch(
    `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=${period1}&period2=${period2}&symbol=${symbol}&userYfid=true&lang=en-CA&region=CA`,
  );
  data = await response.json();
  await Deno.writeTextFile(path, JSON.stringify(data));
}

const timestamps = data.chart.result[0].timestamp;
const values = data.chart.result[0].indicators.adjclose[0].adjclose;
```

The first time you'll run this code, you'll see the message from line 13 being logged in the terminal and you'll notice a new file `AAPL.json` being created in `data`.

The data has been fetched and written to a file for next uses. You can check what's in `AAPL.json` if you are curious!

![A screenshot showing the Apple stock market data being fetched.](/assets/stock-market-simulator/data-fetched-aapl.png)

If you rerun `main.ts` by saving it again, you'll see the message logged is the one from line 10. You are now using the cached data! The data is not fetched anymore. It's retrieved from the local file!

![A screenshot showing the Apple stock market data being cached.](/assets/stock-market-simulator/data-cached-aapl.png)

The beauty of this technique is that you can keep data cached for multiple companies. For example, replace `AAPL` in the `symbol` variable with `GOOG` to get the historical stock prices of Alphabet (formely Google) and run the code.

You'll see another file `GOO.json` being created in data.

If you switch back to `AAPL`, the data is still there! Still no need to fetch it.

And if you want more up-to-date prices, just delete the files in `data`, and rerun your code. Easy!

<Callout type="info" emoji="üí°">
    Here, we are using the cache to avoid pinging Yahoo's servers too many times. But caching is also very often used to speed up things. For example, reading a local file is much faster than fetching data over the Internet.
</Callout>

## Cleaning

The values are numbers and don't need any cleaning. But the timesamps are not very convenient to work with. It would be better to convert them to dates.

Before doing so, let's clean up our code first by putting everything we did so far in a `getData` function. It will help keeping `main.ts` organized and make our code easier to understand and debug.

Create a new folder `helpers` and make a new file `getData.ts` in it with the code below.

Since we are using `await` in this function, we must declare it as an `async` function.

We will keep `symbol` in `main.ts`, so here it's the function parameter.

And the function returns the `timestamps` and `values` in an object.

```ts showLineNumbers filename="getData.ts"
import { exists } from "@std/fs";

export default async function getData(symbol: string) {
  const period1 = 0;
  const period2 = Date.now();
  const path = `data/${symbol}.json`;

  let data;
  if (await exists(path)) {
    console.log("=> Retrieving data from cache...");
    data = JSON.parse(await Deno.readTextFile(path));
  } else {
    console.log("=> Fetching data...");
    const response = await fetch(
      `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=${period1}&period2=${period2}&symbol=${symbol}&userYfid=true&lang=en-CA&region=CA`,
    );
    data = await response.json();
    await Deno.writeTextFile(path, JSON.stringify(data));
  }

  const timestamps = data.chart.result[0].timestamp;
  const values = data.chart.result[0].indicators.adjclose[0].adjclose;

  return { timestamps, values };
}
```

In `main.ts`, we can now import and use `getData` with our `symbol`.

```ts showLineNumbers filename="main.ts"
import getData from "./helpers/getData.ts";

const symbol = "AAPL";

const { timestamps, values } = await getData(symbol);

console.log(timestamps, values);
```
<Callout type="info" emoji="üí°">
    You might be wondering what is going on with `const { timestamps, values }`. When you have an object, you can **destructure it** by extracting keys and putting them in variables of the same name directly. So here, since `getData` returns an object with the keys `timestamps` and `values`, we can destructure it to directly create the variables `timestamps` and `values` variables with the relevant data.
</Callout>

Here's how eveything should look now. You can click on the image to make it bigger.

![A screenshot showing main.ts and getData.ts.](/assets/stock-market-simulator/refactor.png)

Now, to clean up our timesamps, let's create another function `cleanTimestamps` in `helpers`.

This function expects a parameter `timestamps` that should be an array of numbers, as indicated by the type `number[]`.

The first thing we could do is to convert the timestamp to proper Dates. These timestamp are in seconds, but they should be in milliseconds. So we multiply them by `1000` before creating `new Date`. We use the `.map()` array method to convert easily all of them.

```ts showLineNumbers filename="cleanTimestamps.ts"
export default function cleanTimestamps(
  timestamps: number[],
) {
  console.log("=> Cleaning timestamps...");

  const cleanedTimestamps = timestamps.map((timestamp) =>
    new Date(timestamp * 1000)
  );

  return cleanedTimestamps;
}
```

We can import this function in `getData.ts` and pass the raw timestamps to it.

```ts showLineNumbers filename="getData.ts" {2, 22}
import { exists } from "@std/fs";
import cleanTimestamps from "./cleanTimestamps.ts";

export default async function getData(symbol: string) {
  const period1 = 0;
  const period2 = Date.now();
  const path = `data/${symbol}.json`;

  let data;
  if (await exists(path)) {
    console.log("=> Retrieving data from cache...");
    data = JSON.parse(await Deno.readTextFile(path));
  } else {
    console.log("=> Fetching data...");
    const response = await fetch(
      `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?events=capitalGain%7Cdiv%7Csplit&formatted=true&includeAdjustedClose=true&interval=1d&period1=${period1}&period2=${period2}&symbol=${symbol}&userYfid=true&lang=en-CA&region=CA`,
    );
    data = await response.json();
    await Deno.writeTextFile(path, JSON.stringify(data));
  }

  const timestamps = cleanTimestamps(data.chart.result[0].timestamp);
  const values = data.chart.result[0].indicators.adjclose[0].adjclose;

  return { timestamps, values };
}
```

You can now see the timestamps converted to dates. The first one is December 12, 1980, which when Apple started being traded on the stock market.

![A screenshot showing timestamps converted to dates.](/assets/stock-market-simulator/to-dates.png)

<NoticeEnd />

## Restructuring the data

Right now, we have two arrays. It would be easier to have just one array with objects instead. Also, we need to calculate the percentage change between days to calculate our investment returns.

Let's create a new function called `restructureData.ts` in the `helpers` folder. The function expects two parameters: `timestamps` as an array of dates and `values` as an array of numbers.

We know there is the same number of values in `timestamps` and `values`. The first timestamp matches the first value, second timestamp the second value, etc.

So we can use a loop to retrieve values at the same index in both arrays and create objects pushed to the `dailyStockData` array. And we can return this array.

```ts showLineNumbers filename="restructureData.ts"
export default function restructureData(
    timestamps: Date[],
    values: number[]
  ) {
  console.log("=> Restructuring data...");

  const dailyStockData = [];
  for (let i = 0; i < timestamps.length; i++) {
    const date = timestamps[i];
    const value = values[i];

    dailyStockData.push({
      date,
      value,
    });
  }

  return dailyStockData;
}
```

We can now import and call this function in `main.ts`. Since `dailyStockData` is an array of objects, we can log it with `console.table`.

To avoid logging thousands of rows in the terminal, we use the `.slice()` array method to pick only the first 10 elements.

```ts showLineNumbers filename="main.ts" {2, 8-10 }
import getData from "./helpers/getData.ts";
import restructureData from "./helpers/restructureData.ts";

const symbol = "AAPL";

const { timestamps, values } = await getData(symbol);

const dailyStockData = restructureData(timestamps, values);

console.table(dailyStockData.slice(0, 10));
```
![A screenshot showing dates and values logged as a table.](/assets/stock-market-simulator/restructure.png)

This is looking good! Now, let's calculate the daily percentage change.

To do that, we need the value of the previous day. Since we are using indexes, we can simply retrieve it by using `i - 1` and then compute the change.

```ts showLineNumbers filename="restructureData.ts" {8-9, 14-15}
export default function restructureData(timestamps: Date[], values: number[]) {
  console.log("=> Restructuring data...");

  const dailyStockData = [];
  for (let i = 0; i < timestamps.length; i++) {
    const date = timestamps[i];
    const value = values[i];
    const previousValue = values[i - 1];
    const percChange = (value - previousValue) / previousValue;

    dailyStockData.push({
      date,
      value,
      previousValue,
      percChange,
    });
  }

  return dailyStockData;
}
```

Oh! But something is wrong... The first `previousValue` is `undefined` and the first `percChange` is `NaN`! üò±

![A screenshot showing dates and values logged as a table. The first row containes undefined and NaN values.](/assets/stock-market-simulator/previous-value.png)

Actually, it makes sense. The first day is... the first day! There is no previous value! When the loop starts, the `i` is `0`. So when the computer looks for `i - 1`, it searches for an element with the index `-1`, and there isn't any!

Let's fix that by overwriting the first `percChange` to `0`.

```ts showLineNumbers filename="restructureData.ts" {19}
export default function restructureData(timestamps: Date[], values: number[]) {
  console.log("=> Restructuring data...");

  const dailyStockData = [];
  for (let i = 0; i < timestamps.length; i++) {
    const date = timestamps[i];
    const value = values[i];
    const previousValue = values[i - 1];
    const percChange = (value - previousValue) / previousValue;

    dailyStockData.push({
      date,
      value,
      previousValue,
      percChange,
    });
  }

  dailyStockData[0].percChange = 0;

  return dailyStockData;
}
```

This is much better!

![A screenshot showing dates and values logged as a table. The NaN value is gone.](/assets/stock-market-simulator/previous-value-fixed.png)

## Calculating returns

We now have everything we need for calculating returns!

Let's create another function `getFinalAmount` in `helpers`. This function will need three parameters:
- The `amount` invested, which must be a `number`
- The `startDate` which is the `Date` of the investment
- The `dailyStockData`, which is an array of objects with:
  - a key `percChange` with a value of type `number`
  - a key `date` with a value of type `Date`

Note that there are other keys in the `dailyStockData` objects, but we don't need them here, so there is no need to specify them.

First, we need to filter our `dailyStockData`. We want to start when the investment has been made. We use the array method `filter` to do that on line 8-10.

Then we create a `let` variable `adjustedAmount` (line 12), that we will use in our loop. At first, it equals the initial `amount`.

Then in our loop, everyday, we calculate the gains or losses and add them to `adjustedAmount` (line 15).

Finally, we return `adjustedAmount`!

```ts showLineNumbers filename="getFinalAmount.ts"
export default function getFinalAmount(
  amount: number,
  startDate: Date,
  dailyStockData: { percChange: number; date: Date }[],
) {
  console.log("=> Calculating final amount...");

  const filteredDailyStockData = dailyStockData.filter((dailyData) =>
    dailyData.date >= startDate
  );

  let adjustedAmount = amount;

  for (const dailyData of filteredDailyStockData) {
    adjustedAmount += adjustedAmount * dailyData.percChange;
  }

  return adjustedAmount;
}
```

In `main.ts`, we can create a variable `amount` and `startDate` to store the initial amount invested and the date of the investment and pass them to our new function.

We store the result of the function `getFinalAmount` into a new variable `finalAmount`.

```ts showLineNumbers filename="main.ts" {2, 6-7, 13-15}
import getData from "./helpers/getData.ts";
import getFinalAmount from "./helpers/getFinalAmount.ts";
import restructureData from "./helpers/restructureData.ts";

const symbol = "AAPL";
const amount = 1000;
const startDate = new Date("2020-01-01");

const { timestamps, values } = await getData(symbol);

const dailyStockData = restructureData(timestamps, values);

const finalAmount = getFinalAmount(amount, startDate, dailyStockData);

console.log(finalAmount);
```

And here's the result! It works! You would have $3,266 today (as of Feb. 2025) if you had invested $1,000 in Apple in January 2020.

![A screenshot showing the final amount invested.](/assets/stock-market-simulator/final-amount.png)

## The results

Let's create a function to better log the results.

In `helpers`, create the function `logResult`.

For the `startDate`, we can convert it to text by using `toISOString`, which returns the investment date in this format: `"2020-01-01T00:00:00.000Z"`. To keep only the date, we split the text on "T". The `split` method returns an array with `["2020-01-01", "00:00:00.000Z"]`. Since we just want the date, we use the index `[0]`.

```ts showLineNumbers filename="logResult.ts"
export default function logResult(
  amount: number,
  symbol: string,
  startDate: Date,
  finalAmount: number,
) {
  console.log(
    `\nIf you had invested $${amount} in ${symbol} on ${
      startDate.toISOString().split("T")[0]
    }, you would have $${Math.round(finalAmount)} today.\n`,
  );
}
```

We can now use this function in `main.ts`.

```ts showLineNumbers filename="main.ts" {4, 16}
import getData from "./helpers/getData.ts";
import getFinalAmount from "./helpers/getFinalAmount.ts";
import restructureData from "./helpers/restructureData.ts";
import logResult from "./helpers/logResult.ts";

const symbol = "AAPL";
const amount = 1000;
const startDate = new Date("2020-01-01");

const { timestamps, values } = await getData(symbol);

const dailyStockData = restructureData(timestamps, values);

const finalAmount = getFinalAmount(amount, startDate, dailyStockData);

logResult(amount, symbol, startDate, finalAmount);
```

Beautiful, isn't it? üòç

![A VS Code screenshot showing a script simulating the stock market](/assets/stock-market-simulator/final-result.png)

## Wait a minute...

Everything works fine with a `startDate` of January 2020... But what would happen if the start date was in 1970, before Apple was publicly traded?

It's impossible! Our code should warn our user!

Update `startDate` with `"1950-01-01"` to test things out... It's returning an amount, but should be throwing an error.

We can update `main.ts` to compare the `startDate` with the first date in `timestamps`. If the `startDate` is earlier than the first `timestamp`, we throw an error with a message.

```ts showLineNumbers filename="main.ts" {8, 12-16}
import getData from "./helpers/getData.ts";
import getFinalAmount from "./helpers/getFinalAmount.ts";
import restructureData from "./helpers/restructureData.ts";
import logResult from "./helpers/logResult.ts";

const symbol = "AAPL";
const amount = 1000;
const startDate = new Date("1950-01-01");

const { timestamps, values } = await getData(symbol);

if (startDate < timestamps[0]) {
  throw new Error(
    "The company was not public at that time. Please choose a later date.",
  );
}

const dailyStockData = restructureData(timestamps, values);

const finalAmount = getFinalAmount(amount, startDate, dailyStockData);

logResult(amount, symbol, startDate, finalAmount);
```
<Callout type="info" emoji="üí°">
    Throwing errors is very useful to stop running your script and provide a message to the user (or yourself). Always aim for clear messages that will help you debug easily or will help the user act accordingly to avoid problems.
</Callout>

That's better. We won't return impossible results now! You can safely play with different `startDate`.

![A screenshot showing an error being thrown.](/assets/stock-market-simulator/error.png)

## Conclusion

Congratulations! You've learnt many things in this project. We dig into Yahoo's website to find their API and then fetch it. We then processed this data to calculate returns based on a invested amount on a specific date. It's a lot!

Now, you can play more with this script. Search for other companies on Yahoo's website and copy-paste the symbols. Test different amounts and investment date!

Or tweak the code to add more functionnalities. Here are some ideas:
- Compare the returns for multiple companies
- Invest in multiple companies at once
- Buy and sell shares at different dates

Have fun! üíÉüï∫