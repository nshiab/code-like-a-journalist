---
title: √âcrire et lire des fichiers avec Deno
description: Apprenez √† √©crire et lire des fichiers avec Deno, y compris la gestion des donn√©es JSON et la compr√©hension des op√©rations asynchrones.
---

import { Callout } from 'nextra/components'
import { NoticeIntro, NoticeEnd } from "../../../components/Notices.jsx"
import YouTube from "../../../components/YouTube.jsx"

# √âcrire et lire des fichiers

<YouTube videoId="4okqZgySMZc" lang="fr"/>

Lorsque vous ex√©cutez votre code, tout est stock√© dans la RAM (m√©moire vive) de votre ordinateur. Ce type de m√©moire est tr√®s rapide, mais si vous arr√™tez votre script ou √©teignez votre ordinateur, tout est perdu. üò±

Si vous voulez conserver certaines donn√©es, vous devez les √©crire dans un fichier, qui sera stock√© dans la m√©moire permanente de votre ordinateur (disque dur). Et pour r√©cup√©rer les donn√©es d‚Äôun fichier, vous devez les lire.

<NoticeIntro lang="fr"/>

## Configuration

Pr√©parons notre environnement de travail pour cette le√ßon.

Cr√©ez un nouveau dossier quelque part sur votre ordinateur, ouvrez-le avec VS Code, et cr√©ez deux fichiers :

- `main.ts`, o√π nous √©crirons notre code. Pour commencer, vous pouvez ajouter `console.log("Hello!");` dedans.
- `deno.json`, qui permet √† VS Code de savoir qu'il s'agit d'un projet Deno et active l'extension Deno. Vous pouvez ajuster les param√®tres dans ce fichier, mais nous le laisserons vide pour l'instant.

Ouvrez le terminal et ex√©cutez la commande suivante : `deno run --watch --check main.ts`

Cette commande efface le terminal et r√©ex√©cute `main.ts` √† chaque fois que vous le sauvegardez (`CMD` + `S` sur Mac ou `CTRL` + `S` sur PC).

Vous pouvez utiliser cette configuration pour tester le code fourni dans cette le√ßon.

![Une capture d'√©cran montrant VS Code ex√©cutant et surveillant un fichier TypeScript.](/assets/pushing-further/files/setup.png)

## √âcrire

Avec Deno, √©crire des fichiers est tr√®s facile. Vous pouvez utiliser l‚Äôobjet global `Deno`, qui est toujours disponible lorsque vous codez, et appeler la m√©thode `.writeTextFile()`.

Cette m√©thode n√©cessite un chemin d'acc√®s comme premier param√®tre et du texte comme deuxi√®me param√®tre. Dans le code ci-dessous, nous voulons cr√©er un fichier nomm√© `hello.txt` contenant `"Hello!"`.

Copiez, collez et sauvegardez ce code dans `main.ts`. Nous parlerons du mot-cl√© `await` dans un instant.

```ts showLineNumbers filename="main.ts"
await Deno.writeTextFile("./hello.txt", "Hello!");
```

Oh‚ÄØ! Quelque chose est apparu dans le terminal. üßê

![Une capture d'√©cran montrant VS Code affichant un avertissement Deno concernant l'√©criture dans le terminal.](/assets/pushing-further/files/allow-write.png)

Deno est tr√®s strict en mati√®re de s√©curit√©. Par d√©faut, il n'autorise pas un script √† √©crire des fichiers sur votre ordinateur. Imaginez ex√©cuter du code provenant d'une source inconnue qui √©crit des fichiers dangereux sur votre syst√®me... Ce serait terrible‚ÄØ! üí£

Pour permettre au script d'√©crire un fichier, vous devez explicitement accorder l'autorisation en ajoutant l'option `--allow-write` √† la commande du terminal.

Au d√©but de cette le√ßon, nous avons ex√©cut√© le script avec‚ÄØ: `deno run --watch --check main.ts`

Arr√™tez-le en cliquant dans votre terminal et en appuyant sur `CTRL + C` (cela fonctionne sur Mac et PC).

Ensuite, relancez-le avec‚ÄØ: `deno run --watch --check --allow-write main.ts`

Et maintenant, √ßa fonctionne‚ÄØ! Un nouveau fichier texte a √©t√© cr√©√© avec son contenu. Vous savez d√©sormais comment stocker des donn√©es de fa√ßon permanente sur votre ordinateur‚ÄØ!

Au fait, soyez prudent‚ÄØ: par d√©faut, `writeTextFile` √©crase les fichiers s'ils existent d√©j√†.

![Une capture d'√©cran montrant VS Code √©crivant un fichier texte avec Deno.](/assets/pushing-further/files/write-working.png)

## Lire

Pour lire des fichiers, vous pouvez utiliser `Deno.readTextFile()`. Cette m√©thode n√©cessite un chemin d'acc√®s.

Mettons √† jour `main.ts` pour lire le fichier que nous avons √©crit plus t√¥t.

```ts showLineNumbers filename="main.ts"
const data = await Deno.readTextFile("./hello.txt");
console.log(data);
```

Oh‚ÄØ! Encore l‚Äôavertissement‚ÄØ! üö®

Par d√©faut, Deno n'autorise pas un script √† lire des fichiers sur votre ordinateur. Encore une fois, c'est une excellente fonctionnalit√© de s√©curit√©. Imaginez ex√©cuter un script inconnu qui lit des fichiers priv√©s contenant des donn√©es confidentielles‚ÄØ! üïµÔ∏è

![Une capture d'√©cran montrant VS Code affichant un avertissement Deno concernant la lecture dans le terminal.](/assets/pushing-further/files/allow-read.png)

Pour permettre au script de lire un fichier, vous devez explicitement accorder l'autorisation en ajoutant l'option `--allow-read` √† la commande du terminal.

Arr√™tez votre script en cliquant dans votre terminal et en appuyant sur `CTRL + C` (cela fonctionne sur Mac et PC).

Ensuite, relancez-le avec‚ÄØ: `deno run --watch --check --allow-read main.ts`

Et maintenant, √ßa fonctionne. Vous avez r√©ussi √† r√©cup√©rer le contenu texte du fichier `hello.txt`‚ÄØ!

![Une capture d'√©cran montrant VS Code lisant un fichier texte avec Deno.](/assets/pushing-further/files/read-working.png)

## Permissions accord√©es üëÆ

Bien que les permissions explicites de Deno soient une excellente fonctionnalit√© de s√©curit√© lors de l'ex√©cution de code inconnu, ce n'est pas tr√®s pratique pendant le d√©veloppement.

Si vous faites confiance au code que vous ex√©cutez (et √† toutes ses d√©pendances‚ÄØ!), vous pouvez utiliser l'option `-A` pour permettre au script de faire tout ce qu'il veut.

Ici, c'est acceptable, car nous ex√©cutons uniquement notre propre code.

Cliquez dans votre terminal, appuyez sur `CTRL + C` pour l'arr√™ter, puis ex√©cutez‚ÄØ: `deno run --watch --check -A main.ts`

Votre script peut maintenant √©crire, lire et bien plus encore‚ÄØ! Nous allons utiliser cette commande pour le reste de cette le√ßon, tout comme pour les prochaines le√ßons.

## JSON

√âcrire des donn√©es sous forme de texte est assez standard. Par exemple, les fichiers CSV sont simplement des fichiers texte avec des virgules repr√©sentant les colonnes.

Cependant, en travaillant avec TypeScript, en particulier pour le Web, vous √©crirez souvent vos donn√©es sous forme de fichiers **JSON**. JSON signifie *JavaScript Object Notation*, et comme TypeScript est bas√© sur le JavaScript, c'est un choix naturel.

Ce format de fichier texte peut stocker des listes, des objets, du texte, des nombres et des bool√©ens, au lieu de simples textes bruts.

Par exemple, dans le script ci-dessous, nous √©crivons la liste d'objets `data` dans le fichier `data.json`.


```ts showLineNumbers filename="main.ts"
const data = [
  { name: "Nael", age: 25 },
  { name: "John", age: 30 },
];

await Deno.writeTextFile(
  "data.json",
  JSON.stringify(data),
);
```
<Callout type="info" emoji="üí°">
    √Ä la ligne 8, nous avons utilis√© l'objet global `JSON`, qui est toujours disponible lorsque vous codez, et sa m√©thode `stringify()`. `writeTextFile` n√©cessite un `string`, mais `data` est une liste d'objets. Nous utilisons donc **stringify** pour transformer `data` en texte JSON. La m√©thode compl√©mentaire est `JSON.parse()`, qui rend leur forme originale √† des listes, objets et valeurs qui ont √©t√© transofrm√© en texte JSON.
</Callout>

![Une capture d'√©cran montrant VS Code √©crivant un fichier JSON avec Deno.](/assets/pushing-further/files/json-write.png)

Comme le fichier a l'extension `.json`, il est compris par VS Code et Deno. Son contenu est affich√© avec les types de donn√©es appropri√©s. Dans la capture d'√©cran ci-dessus, les noms sont mis en √©vidence comme du texte et les √¢ges comme des nombres. Si nous avions tout √©crit dans un fichier `.txt`, tout appara√Ætrait comme du texte brut.

De plus, parce qu'il s'agit d'un fichier JSON, vous pouvez l'importer comme un fichier `.ts` en ajoutant l'assertion `with { type: "json" }`.

```ts showLineNumbers filename="main.ts"
import data from "./data.json" with { type: "json" };

console.log(data);
```
![Une capture d'√©cran montrant VS Code lisant un fichier JSON avec Deno.](/assets/pushing-further/files/json-read.png)

Comme il s'agit de JSON, la v√©rification des types fonctionne directement, ce qui est formidable.

Si vous ajoutez un `.` apr√®s `data`, VS Code sugg√©rera des m√©thodes pour les listes car il sait que les donn√©es stock√©es dans `data.json` sont une liste.

![Une capture d'√©cran montrant VS Code sugg√©rant des m√©thodes pour les tableaux.](/assets/pushing-further/files/json-array-methods.png)

Si vous s√©lectionnez le premier objet de `data` avec `[0]` et tapez un `.` pour acc√©der √† une cl√©, VS Code vous proposera les cl√©s pr√©sentes dans l'objet. Comme c'est un fichier JSON, il peut inf√©rer les types.

![Une capture d'√©cran montrant VS Code lisant un fichier JSON avec Deno.](/assets/pushing-further/files/json-object-methods.png)

Et si vous essayez d'acc√©der √† des cl√©s qui n'existent pas dans les objets, vous obtiendrez une erreur. N'est-ce pas incroyable ? üòç

![Une capture d'√©cran montrant VS Code lisant un fichier JSON avec Deno.](/assets/pushing-further/files/json-object-error.png)

## √Ä propos de `await`

Il existe deux types de fonctions et de m√©thodes : **synchrones** et **asynchrones**.

Dans la [le√ßon sur les fonctions](/pushing-further/functions), nous avons √©crit des fonctions synchrones. Vous n'aviez pas besoin d'ajouter `await` devant elles.

Lorsque votre ordinateur rencontre une fonction, une m√©thode ou une instruction **synchrone**, il **attend** que tout soit termin√© avant de passer √† la suivante. Cela fonctionne comme attendu : la ligne 1 de votre code est ex√©cut√©e, puis la ligne 2, puis la ligne 3, et ainsi de suite.

Cependant, lorsque votre ordinateur rencontre une fonction ou une m√©thode **asynchrone**, il commence √† l'ex√©cuter *en arri√®re-plan* mais **n'attend pas** qu'elle soit termin√©e. Pendant que la t√¢che s'ex√©cute *en arri√®re-plan*, il passe imm√©diatement √† l'instruction suivante. L'*arri√®re-plan* est une simplification de ce qui se passe vraiment, mais vous comprenez le concept.

Puisque `writeTextFile` et `readTextFile` sont asynchrones, cela signifie que vous pouvez √©crire ou lire plusieurs fichiers **concurremment**, ce qui peut consid√©rablement acc√©l√©rer le temps de traitement de votre script (si utilis√© correctement üßë‚Äçüî¨).

Cette fonctionnalit√© est √©galement formidable pour le d√©veloppement web. Par exemple, un site avec plusieurs images peut r√©cup√©rer toutes les images en m√™me temps au lieu de les charger une par une, ce qui am√©liore la vitesse et l'exp√©rience utilisateur.

Dans notre contexte, il est plus simple d'ajouter le mot-cl√© `await` pour que l'ordinateur traite le code dans l'ordre affich√©.

Pour identifier une fonction ou une m√©thode asynchrone, survolez-la. Les fonctions asynchrones retourne une promesse (`Promise`). Pas d'inqui√©tude: la v√©rification des types vous alertera si `await` est requis quelque part.

![Une capture d'√©cran montrant VS Code.](/assets/pushing-further/files/promise.png)

## Conclusion

Avec ces nouvelles comp√©tences, vous pouvez maintenant g√©rer efficacement et en toute s√©curit√© les op√©rations sur les fichiers dans vos projets Deno. Bon codage ! ü•≥

<NoticeEnd lang="fr"/>